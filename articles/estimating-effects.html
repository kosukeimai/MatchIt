<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Estimating Effects After Matching • MatchIt</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Estimating Effects After Matching">
<meta property="og:description" content="MatchIt">
<meta property="og:image" content="/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">MatchIt</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">4.4.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/MatchIt.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/matching-methods.html">Matching Methods</a>
    </li>
    <li>
      <a href="../articles/assessing-balance.html">Assessing Balance</a>
    </li>
    <li>
      <a href="../articles/estimating-effects.html">Estimating Effects After Matching</a>
    </li>
    <li>
      <a href="../articles/sampling-weights.html">Matching with Sampling Weights</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/kosukeimai/MatchIt/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="estimating-effects_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Estimating Effects After Matching</h1>
                        <h4 data-toc-skip class="author">Noah Greifer</h4>
            
            <h4 data-toc-skip class="date">2022-05-18</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/kosukeimai/MatchIt/blob/HEAD/vignettes/estimating-effects.Rmd" class="external-link"><code>vignettes/estimating-effects.Rmd</code></a></small>
      <div class="hidden name"><code>estimating-effects.Rmd</code></div>

    </div>

    
    
<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>After assessing balance and deciding on a matching specification, it comes time to estimate the effect of the treatment in the matched sample. How the effect is estimated and interpreted depends on the desired estimand and the type of model used (if any). In addition to estimating effects, estimating the uncertainty of the effects is critical in communicating them and assessing whether the observed effect is compatible with there being no effect in the population. This guide explains how to estimate effects after various forms of matching and with various outcome types. There may be situations that are not covered here for which additional methodological research may be required, but some of the recommended methods here can be used to guide such applications.</p>
<p>This guide is structured as follows: first, information on the concepts related to effect and standard error estimation is presented below. Then, instructions for how to estimate effects and standard errors are described. This section is split up first by the type of matching method performed (matching without replacement, matching with replacement, full matching, and subclassification) and then by the type of outcome (continuous, binary, and survival). Finally recommendations for reporting results and tips to avoid making common mistakes are presented.</p>
<div class="section level3">
<h3 id="identifying-the-estimand">Identifying the estimand<a class="anchor" aria-label="anchor" href="#identifying-the-estimand"></a>
</h3>
<p>Before an effect is estimated, the estimand must be specified and clarified. Although some aspects of the estimand depend not only on how the effect is estimated after matching but also on the matching method itself, other aspects must be considered at the tine of effect estimation and interpretation. Here, we consider three aspects of the estimand: the population the effect is meant to generalize to (the target population), the effect measure, and whether the effect is marginal or conditional.</p>
<p><strong>The target population.</strong> Different matching methods allow you to estimate effects that can generalize to different target populations. The most common estimand in matching the average treatment effect in the treated (ATT), which is the average effect of treatment for those who receive treatment. This estimand is estimable for matching methods that do not change the treated units (i.e., by weighting or discarding units) and is requested in <code><a href="../reference/matchit.html">matchit()</a></code> by setting <code>estimand = "ATT"</code> (which is the default). The average treatment effect in the population (ATE) is the average effect of treatment for the population from which the sample is a random sample. This estimand is estimable only for methods that allow the ATE and either do not discard units from the sample or explicit target full sample balance, which in <code>MatchIt</code> is limited to full matching, subclassification, and template matching when setting <code>estimand = "ATE"</code>. When treated units are discarded (e.g., through the use of common support restrictions, calipers, cardinality matching, or [coarsened] exact matching), the estimand corresponds to neither the population ATT nor the population ATE, but rather to an average treatment effect in the remaining matched sample (ATM), which may not correspond to any specific target population. See <span class="citation">Greifer and Stuart (<a href="#ref-greiferChoosingEstimandWhen2021" role="doc-biblioref">2021</a>)</span> for a discussion on the substantive considerations involved when choosing the target population of the estimand.</p>
<p><strong>Marginal and conditional effects.</strong> A marginal effect is a comparison between the expected potential outcome under treatment and the expected potential outcome under control. This is the same quantity estimated in randomized trials without blocking or covariate adjustment and is particularly useful for quantifying the overall effect of a policy or population-wide intervention. A conditional effect is the comparison between the expected potential outcomes in the treatment groups within strata. This is useful for identifying the effect of a treatment for an individual patient or a subset of the population.</p>
<p><strong>Effect measures.</strong> The outcome types we consider here are continuous, with the effect measured by the mean difference; binary, with the effect measured by the risk difference (RD), risk ratio (RR), or odds ratio (OR); and time-to-event (i.e., survival), with the effect measured by the hazard ratio (HR). The RR, OR, and HR are <em>noncollapsible</em> effect measures, which means the marginal effect on that scale is not a (possibly) weighted average of the conditional effects within strata, even if the stratum-specific effects are of the same magnitude. For these effect measures, it is critical to distinguish between marginal and conditional effects because different statistical methods target different types of effects. The mean difference and RD are <em>collapsible</em> effect measures, so the same methods can be used to estimate marginal and conditional effects.</p>
<p>In this guide, we will provide examples for estimating the ATT, ATE, and ATM for each of the three outcomes types. Our primary focus will be on marginal effects, which are appropriate for all effect measures, easily interpretable, and require few modeling assumptions. We will include a short section on estimating the conditional OR. The “Common Mistakes” section includes examples of commonly used methods that estimate conditional rather than marginal effects and should not be used when marginal effects are desired.</p>
</div>
<div class="section level3">
<h3 id="modeling-the-outcome">Modeling the Outcome<a class="anchor" aria-label="anchor" href="#modeling-the-outcome"></a>
</h3>
<p>The type and form of the model used to estimate the treatment effect depend on the effect measure desired, whether a marginal or conditional effect is desired, whether covariates are to be included in the model, and whether effect modification by the covariates is present. For continuous outcomes, one can use a linear model regressing the outcome on the treatment; for binary outcomes, one can use a generalized linear model with a link function appropriate for the desired effect measure (e.g., a logistic link for the OR); for time-to-event outcomes, one can use a Cox proportional hazards model.</p>
<p>An additional decision to make is whether (and how) to include covariates in the outcome model. One may ask, why use matching at all if you are going to model the outcome with covariates anyway? Matching reduces the dependence of the effect estimate on correct specification of the outcome model; this is the central thesis of <span class="citation">Ho et al. (<a href="#ref-ho2007" role="doc-biblioref">2007</a>)</span>. Including covariates in the outcome model after matching has several functions: it can increase precision in the effect estimate, reduce the bias due to residual imbalance, and make the effect estimate “doubly robust”, which means it is consistent if either the matching reduces sufficient imbalance in the covariates or if the outcome model is correct. For these reasons, we recommend covariate adjustment after matching when possible. There is some evidence that covariate adjustment is most helpful for covariates with standardized mean differences greater than .1 <span class="citation">(Nguyen et al. <a href="#ref-nguyen2017" role="doc-biblioref">2017</a>)</span>, so these covariates and covariates thought to be highly predictive of the outcome should be prioritized in treatment effect models if not all can be included due to sample size constraints.</p>
<p>For continuous outcomes, we can simply include the covariates in the regression of the outcome on the treatment in the matched sample (i.e., using the matching weights). Because the mean difference is collapsible, the effect estimate conditioning on the covariates is still a marginal effect estimate. This is not the case with binary and time-to-event outcomes; including covariates in the outcome model makes the treatment effect a conditional effect. To recover a marginal effect while including covariates in an outcome model, one has to perform a marginal effects procedure, also known as g-computation <span class="citation">(Snowden, Rose, and Mortimer <a href="#ref-snowden2011" role="doc-biblioref">2011</a>)</span> or regression estimation <span class="citation">(Schafer and Kang <a href="#ref-schafer2008" role="doc-biblioref">2008</a>)</span>, which involves simulating the average potential outcomes under each treatment level and computing the effect as a contrast between those average potential outcomes. G-computation can also be used to estimate marginal effects when modeling effect modification by the covariates. We demonstrate examples of this below.</p>
<p>Although there are many possible ways to include covariates (i.e., not just main effects but interactions, smoothing terms like splines, or other nonlinear transformations), it is important not to engage in specification search (i.e., trying many outcomes models in search of the “best” one). Doing so can invalidate results and yield a conclusion that fails to replicate. For this reason, we recommend only including the same terms included in the propensity score model unless there is a strong <em>a priori</em> and justifiable reason to model the outcome differently. Second, it is important not to interpret the coefficients and tests of the other covariates in the outcome model. These are not causal effects and their estimates may be severely confounded. Only the treatment effect estimate can be interpreted as causal assuming the relevant assumptions about unconfoundedness are met. Inappropriately interpreting the coefficients of covariates in the outcome model is known as the Table 2 fallacy <span class="citation">(Westreich and Greenland <a href="#ref-westreich2013" role="doc-biblioref">2013</a>)</span>. To avoid this, in all examples that incorporate covariates in the outcome model, we restrict the output of outcome regression models to just the treatment coefficient.</p>
</div>
<div class="section level3">
<h3 id="estimating-standard-errors-and-confidence-intervals">Estimating Standard Errors and Confidence Intervals<a class="anchor" aria-label="anchor" href="#estimating-standard-errors-and-confidence-intervals"></a>
</h3>
<p>Uncertainty estimation (i.e., of standard errors, confidence intervals, and p-values) may consider the variety of sources of uncertainty present in the analysis, including (but not limited to!) estimation of the propensity score (if used), matching (i.e., because treated units might be matched to different control units if others had been sampled), and estimation of the treatment effect (i.e., because of sampling error). In general, there are no analytic solutions to all these issues, so much of the research done on uncertainty estimation after matching has relied on simulation studies. The two primary methods that have been shown to perform well in matched samples are using cluster-robust standard errors and the bootstrap.</p>
<div class="section level4">
<h4 id="robust-and-cluster-robust-standard-errors">Robust and Cluster-Robust Standard Errors<a class="anchor" aria-label="anchor" href="#robust-and-cluster-robust-standard-errors"></a>
</h4>
<p><strong>Robust standard errors.</strong> Also known as sandwich standard errors (due to the form of the formula for computing them), heteroscedasticity-consistent standard errors, or Huber-White standard errors, robust standard errors are an adjustment to the usual maximum likelihood or ordinary least squares standard errors that are robust to violations of some of the assumptions required for usual standard errors to be valid <span class="citation">(MacKinnon and White <a href="#ref-mackinnon1985" role="doc-biblioref">1985</a>)</span>. Although there has been some debate about their utility <span class="citation">(King and Roberts <a href="#ref-king2015" role="doc-biblioref">2015</a>)</span>, robust standard errors rarely degrade inferences and often improve them. Generally, robust standard errors <strong>must</strong> be used when any non-uniform weights are included in the estimation (e.g., with full matching or inverse probability weighting).</p>
<p><strong>Cluster-robust standard errors.</strong> A version of robust standard errors known as cluster-robust standard errors <span class="citation">(Liang and Zeger <a href="#ref-liang1986" role="doc-biblioref">1986</a>)</span> can be used to account for dependence between observations within clusters (e.g., matched pairs). <span class="citation">Abadie and Spiess (<a href="#ref-abadie2019" role="doc-biblioref">2019</a>)</span> demonstrate analytically that cluster-robust standard errors are generally valid after matching, whereas regular robust standard errors can over- or under-estimate the true sampling variability of the effect estimator depending on the specification of the outcome model (if any) and degree of effect modification. A plethora of simulation studies have further confirmed the validity of cluster-robust standard errors after matching <span class="citation">(e.g., Austin <a href="#ref-austin2009a" role="doc-biblioref">2009</a>, <a href="#ref-austin2013" role="doc-biblioref">2013</a><a href="#ref-austin2013" role="doc-biblioref">a</a>; Austin and Small <a href="#ref-austin2014" role="doc-biblioref">2014</a>; Gayat et al. <a href="#ref-gayat2012" role="doc-biblioref">2012</a>; Wan <a href="#ref-wan2019" role="doc-biblioref">2019</a>)</span>. Given this evidence favoring the use of cluster-robust standard errors, we recommend them in most cases and use them judiciously in the this guide<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>Here, we will use linear and generalized linear models as implemented by <code><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm()</a></code> and <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code> and use <code><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">lmtest::coeftest()</a></code> and <code><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">lmtest::coefci()</a></code> along with <code><a href="https://sandwich.R-Forge.R-project.org//reference/vcovHC.html" class="external-link">sandwich::vcovHC()</a></code> for robust standard errors and <code><a href="https://sandwich.R-Forge.R-project.org//reference/vcovCL.html" class="external-link">sandwich::vcovCL()</a></code> for cluster-robust standard errors. There are several “types” (e.g., HC0, HC1, etc.) of robust standard errors that adjust the original standard errors in different ways; although more research is required on the benefits of using different types for estimating standard errors after matching, we use the default types here.</p>
</div>
<div class="section level4">
<h4 id="bootstrapping">Bootstrapping<a class="anchor" aria-label="anchor" href="#bootstrapping"></a>
</h4>
<p>Bootstrapping is a technique used to simulate the sampling distribution of an estimator by repeatedly drawing samples with replacement and estimating the effect in each bootstrap sample <span class="citation">(Efron and Tibshirani <a href="#ref-efron1993" role="doc-biblioref">1993</a>)</span>. From the bootstrap distribution, standard errors and confidence interval can be computed in several ways, including using the standard deviation of the bootstrap estimates as the standard error estimate or using the 2.5 and 97.5 percentiles as 95% confidence interval bounds. Bootstrapping tends to be most useful when no analytic estimator of a standard error is possible or has been derived yet. Although <span class="citation">Abadie and Imbens (<a href="#ref-abadie2008" role="doc-biblioref">2008</a>)</span> found analytically that the bootstrap is inappropriate for matched samples, simulation evidence has found it to be adequate in many cases <span class="citation">(Hill and Reiter <a href="#ref-hill2006" role="doc-biblioref">2006</a>; Austin and Small <a href="#ref-austin2014" role="doc-biblioref">2014</a>; Austin and Stuart <a href="#ref-austin2017" role="doc-biblioref">2017</a>)</span>. It is the most accessible method for computing standard errors after g-computation for nonlinear models.</p>
<p>Typically, bootstrapping involves performing the entire estimation process in each bootstrap sample, including propensity score estimation, matching, and effect estimation. This tends to be the most straightforward route, though intervals from this method may be conservative in some cases (i.e., they are wider than necessary to achieve nominal coverage) <span class="citation">(Austin and Small <a href="#ref-austin2014" role="doc-biblioref">2014</a>)</span>. Less conservative and more accurate intervals have been found when using different forms of the bootstrap, including the wild bootstrap develop by <span class="citation">Bodory et al. (<a href="#ref-bodory2020" role="doc-biblioref">2020</a>)</span> and the matched bootstrap described by <span class="citation">Austin and Small (<a href="#ref-austin2014" role="doc-biblioref">2014</a>)</span> and <span class="citation">Abadie and Spiess (<a href="#ref-abadie2019" role="doc-biblioref">2019</a>)</span>. The block bootstrap involves sampling matched pairs/strata of units from the matched sample and performing the analysis within each sample composed of the sampled pairs. <span class="citation">Abadie and Spiess (<a href="#ref-abadie2019" role="doc-biblioref">2019</a>)</span> derived analytically that the block bootstrap is valid for estimating SEs and CIs in the same circumstances cluster robust SEs are; indeed, the block bootstrap SE is known to approximate the cluster-robust SE <span class="citation">(Cameron and Miller <a href="#ref-cameron2015" role="doc-biblioref">2015</a>)</span>. We use <code><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot()</a></code> from the <code>boot</code> package to implement bootstrapping.</p>
<p>With bootstrapping, more bootstrap replications are always better but can take time and increase the chances that at least one error will occur within the bootstrap analysis (e.g., a bootstrap sample with zero treated units or zero units with an event). In general, numbers of replications upwards of 999 are recommended, with values one less than a multiple of 100 preferred to avoid interpolation when using the percentiles as confidence interval limits <span class="citation">(MacKinnon <a href="#ref-mackinnon2006" role="doc-biblioref">2006</a>)</span>. There are several methods of computing bootstrap confidence intervals, but the bias-corrected accelerated (BCa) bootstrap confidence interval often performs best <span class="citation">(Austin and Small <a href="#ref-austin2014" role="doc-biblioref">2014</a>; Carpenter and Bithell <a href="#ref-carpenter2000" role="doc-biblioref">2000</a>)</span> and is easy to implement, simply by setting <code>type = "bca"</code> in the call to <code><a href="https://rdrr.io/pkg/boot/man/boot.ci.html" class="external-link">boot.ci()</a></code> after running <code><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot()</a></code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="estimating-treatment-effects-and-standard-errors-after-matching">Estimating Treatment Effects and Standard Errors After Matching<a class="anchor" aria-label="anchor" href="#estimating-treatment-effects-and-standard-errors-after-matching"></a>
</h2>
<p>Below, we describe effect estimation after several methods of matching. We consider four broad types of matching that require their own specific methods for estimation effects: 1) pair matching without replacement, 2) pair matching with replacement, 3) full matching, and 4) stratification. In some cases, methods for estimating effects are similar across methods, and we err on the side of redundancy here in our instructions. We also consider three different outcome types: 1) continuous, 2) binary, and 3) survival.</p>
<p>We’ll be using a simulated toy dataset <code>d</code> with several outcome types. Code to generate the dataset is at the end of this document. The focus here is not on evaluating the methods but simply on demonstrating them. In all cases, the correct propensity score model is used. Below we display the first six rows of <code>d</code>:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">d</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">##   A      X1      X2      X3       X4 X5      X6      X7      X8       X9      Y_C Y_B     Y_S</span>
<span class="co">## 1 0  0.1725 -1.4283 -0.4103 -2.36059  1 -1.1199  0.6398 -0.4840 -0.59385  0.07104   0  278.46</span>
<span class="co">## 2 0 -1.0959  0.8463  0.2456 -0.12333  1 -2.2687 -1.4491 -0.5514 -0.31439  0.15619   0  330.63</span>
<span class="co">## 3 0  0.1768  0.7905 -0.8436  0.82366  1 -0.2221  0.2971 -0.6966 -0.69516 -0.85180   1  369.94</span>
<span class="co">## 4 0 -0.4595  0.1726  1.9542 -0.62661  1 -0.4019 -0.8294 -0.5384  0.20729 -2.35184   0   91.06</span>
<span class="co">## 5 1  0.3563 -1.8121  0.8135 -0.67189  1 -0.8297  1.7297 -0.6439 -0.02648  0.68058   0  182.73</span>
<span class="co">## 6 0 -2.4313 -1.7984 -1.2940  0.04609  1 -1.2419 -1.1252 -1.8659 -0.56513 -5.62260   0 2563.73</span></code></pre>
<p><code>A</code> is the treatment variable, <code>X1</code> through <code>X9</code> are covariates, <code>Y_C</code> is a continuous outcome, <code>Y_B</code> is a binary outcome, and <code>Y_S</code> is a survival outcome.</p>
<p>We will need to the following packages to perform the desired analyses:</p>
<ul>
<li>
<code>lmtest</code> provides the <code><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest()</a></code> and <code><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coefci()</a></code> functions for estimating coefficients, standard errors, and confidence intervals incorporating robust standard errors</li>
<li>
<code>sandwich</code> provides robust and cluster robust standard errors through the <code><a href="https://sandwich.R-Forge.R-project.org//reference/vcovHC.html" class="external-link">vcovHC()</a></code> and <code><a href="https://sandwich.R-Forge.R-project.org//reference/vcovCL.html" class="external-link">vcovCL()</a></code> functions, respectively</li>
<li>
<code>boot</code> provides the <code><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot()</a></code> and <code><a href="https://rdrr.io/pkg/boot/man/boot.ci.html" class="external-link">boot.ci()</a></code> functions for performing bootstrapping and estimating bootstrap effects, standard errors, and confidence intervals.</li>
<li>
<code>survival</code> provides the functions <code><a href="https://rdrr.io/pkg/survival/man/survdiff.html" class="external-link">survdiff()</a></code> and <code><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph()</a></code> to perform the log-rank test for differences in survival curves and estimate the coefficients in a Cox-proportional hazards model for the marginal hazard ratio, respectively, which we will use for survival outcomes.</li>
</ul>
<p>Of course, we also need <code>MatchIt</code> to perform the matching.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://kosukeimai.github.io/MatchIt/" class="external-link">"MatchIt"</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st">"lmtest"</span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://sandwich.R-Forge.R-project.org/" class="external-link">"sandwich"</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st">"boot"</span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/therneau/survival" class="external-link">"survival"</a></span><span class="op">)</span></code></pre></div>
<p>Other packages may be of use but are not used here. The <code>margins</code> package can be useful for computing marginal effects and standard errors without bootstrapping. Some examples using <code>margins</code> are presented. The <code>survey</code> package can be used to estimate robust standard errors incorporating weights and provides functions for survey-weighted generalized linear models and Cox-proportional hazards models. It is often used with propensity score weighting. The <code>Zelig</code> package provides a broad interface to estimating marginal and conditional effects using simulation and was included in the original documentation for <code>MatchIt</code>. The <code>lme4</code> (and <code>lmerTest</code>) package performs mixed effects modeling, which can be useful for accounting for pair membership or other clustering features of the data.</p>
<p>Because different matching methods require different treatments, instructions for each method are organized in the following sections, as designated by the table below. It is important to ensure the right methods are used with the matching specification used in order for the estimated effects and standard errors to be valid.</p>
<table class="table">
<colgroup>
<col width="59%">
<col width="40%">
</colgroup>
<thead><tr class="header">
<th>Section</th>
<th>Matching Method</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="#after-pair-matching-without-replacement">After Pair Matching Without Replacement</a></td>
<td>Nearest neighbor matching without replacement</td>
</tr>
<tr class="even">
<td>-</td>
<td>Optimal matching</td>
</tr>
<tr class="odd">
<td>-</td>
<td>Genetic matching without replacement</td>
</tr>
<tr class="even">
<td>-</td>
<td>Coarsened exact matching with <code>k2k = TRUE</code>
</td>
</tr>
<tr class="odd">
<td><a href="#after-pair-matching-with-replacement">After Pair Matching With Replacement</a></td>
<td>Nearest neighbor matching with replacement</td>
</tr>
<tr class="even">
<td>-</td>
<td>Genetic matching with replacement</td>
</tr>
<tr class="odd">
<td><a href="#after-full-matching">After Full Matching</a></td>
<td>Full matching</td>
</tr>
<tr class="even">
<td></td>
<td>Cardinality and template matching</td>
</tr>
<tr class="odd">
<td><a href="#after-stratum-matching">After Stratum Matching</a></td>
<td>Propensity score subclassification</td>
</tr>
<tr class="even">
<td>-</td>
<td>Exact matching</td>
</tr>
<tr class="odd">
<td>-</td>
<td>Coarsened exact matching with <code>k2k = FALSE</code> (the default)</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="after-pair-matching-without-replacement">After Pair Matching Without Replacement<a class="anchor" aria-label="anchor" href="#after-pair-matching-without-replacement"></a>
</h3>
<p>Pair matching without replacement yields the simplest way to estimate treatment effects and standard errors. In general, whether a caliper, common support restriction, exact matching specification, or <span class="math inline">\(k\)</span>:1 matching specification is used, estimating the effect in the matched dataset (i.e., the output of <code><a href="../reference/match.data.html">match.data()</a></code>) is straightforward and involves fitting a model for the outcome that incorporates the matching weights<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>.</p>
<p>First, we will perform nearest 1:1 neighbor propensity score matching without replacement.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mNN</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">d</span><span class="op">)</span>

<span class="va">mNN</span></code></pre></div>
<pre><code><span class="co">## A matchit object</span>
<span class="co">##  - method: 1:1 nearest neighbor matching without replacement</span>
<span class="co">##  - distance: Propensity score</span>
<span class="co">##              - estimated with logistic regression</span>
<span class="co">##  - number of obs.: 2000 (original), 882 (matched)</span>
<span class="co">##  - target estimand: ATT</span>
<span class="co">##  - covariates: X1, X2, X3, X4, X5, X6, X7, X8, X9</span></code></pre>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">md</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mNN</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">md</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">##    A       X1      X2      X3      X4 X5      X6      X7      X8       X9      Y_C Y_B     Y_S distance weights subclass</span>
<span class="co">## 1  0  0.17254 -1.4283 -0.4103 -2.3606  1 -1.1199  0.6398 -0.4840 -0.59385  0.07104   0  278.46  0.08461       1      167</span>
<span class="co">## 3  0  0.17677  0.7905 -0.8436  0.8237  1 -0.2221  0.2971 -0.6966 -0.69516 -0.85180   1  369.94  0.22210       1      210</span>
<span class="co">## 5  1  0.35631 -1.8121  0.8135 -0.6719  1 -0.8297  1.7297 -0.6439 -0.02648  0.68058   0  182.73  0.43291       1      322</span>
<span class="co">## 9  0  0.78080  1.3137  0.6580  0.8540  1  0.9495 -0.5731 -0.2362 -0.14580 15.89771   1   67.53  0.15751       1        3</span>
<span class="co">## 10 1 -0.56513 -0.1053 -0.1369  1.6233  1 -0.5304 -0.3342  0.4184  0.46308  1.07888   1  113.70  0.16697       1        1</span>
<span class="co">## 11 0  0.07053 -0.1320 -1.8882  0.3077  0 -1.6558  0.8405 -0.5723 -1.01382 -6.55597   0 1632.69  0.45623       1      298</span></code></pre>
<p>Typically one would assess balance and ensure that this matching specification works, but we will skip that step here to focus on effect estimation. See <code><a href="../articles/MatchIt.html">vignette("MatchIt")</a></code> and <code><a href="../articles/assessing-balance.html">vignette("assessing-balance")</a></code> for more information on this necessary step. Because we did not use a caliper, the target estimand is the ATT.</p>
<div class="section level4">
<h4 id="for-continuous-outcomes">For continuous outcomes<a class="anchor" aria-label="anchor" href="#for-continuous-outcomes"></a>
</h4>
<p>For continuous outcomes, estimating effects is fairly straightforward using linear regression. We perform all analyses using the matched dataset, <code>md</code>, which contains only units retained in the sample.</p>
<p><strong>Without covariate adjustment.</strong> To estimate the effect without covariate adjustment, we can run the following:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Linear model without covariates</span>
<span class="va">fit1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span></code></pre></div>
<p>First, we will estimate the standard errors while accounting for pair membership using cluster-robust standard errors.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Cluster-robust standard errors</span>
<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit1</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## t test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">## (Intercept)    1.779      0.303    5.88  5.8e-09 ***</span>
<span class="co">## A              2.114      0.409    5.18  2.8e-07 ***</span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<p><strong>Using the bootstrap.</strong> We demonstrate bootstrapping here using the block bootstrap as recommended by <span class="citation">Abadie and Spiess (<a href="#ref-abadie2019" role="doc-biblioref">2019</a>)</span>. The process is generalizable to other matching methods for which cluster-robust standard errors are valid and to other outcome types. We first need to write a function, <code>est_fun</code>, which takes in a vector of pair identifiers and an ordering and outputs an effect estimate. This function should include the effect estimation, though no standard error is required.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Block bootstrap confidence interval</span>
<span class="co"># library(boot)</span>

<span class="va">pair_ids</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/levels.html" class="external-link">levels</a></span><span class="op">(</span><span class="va">md</span><span class="op">$</span><span class="va">subclass</span><span class="op">)</span>

<span class="va">est_fun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">pairs</span>, <span class="va">i</span><span class="op">)</span> <span class="op">{</span>
  
  <span class="co">#Compute number of times each pair is present</span>
  <span class="va">numreps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">pairs</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span>
  
  <span class="co">#For each pair p, copy corresponding md row indices numreps[p] times</span>
  <span class="va">ids</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">pair_ids</span><span class="op">[</span><span class="va">pair_ids</span> <span class="op"><a href="https://rdrr.io/r/base/match.html" class="external-link">%in%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">numreps</span><span class="op">)</span><span class="op">]</span>,
                       <span class="kw">function</span><span class="op">(</span><span class="va">p</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">md</span><span class="op">$</span><span class="va">subclass</span> <span class="op">==</span> <span class="va">p</span><span class="op">)</span>, 
                                              <span class="va">numreps</span><span class="op">[</span><span class="va">p</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
  
  <span class="co">#Subset md with block bootstrapped ids</span>
  <span class="va">md_boot</span> <span class="op">&lt;-</span> <span class="va">md</span><span class="op">[</span><span class="va">ids</span>,<span class="op">]</span>
  
  <span class="co">#Effect estimation</span>
  <span class="va">fit_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md_boot</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>
  
  <span class="co">#Return the coefficient on treatment</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fit_boot</span><span class="op">)</span><span class="op">[</span><span class="st">"A"</span><span class="op">]</span><span class="op">)</span>
<span class="op">}</span>

<span class="va">boot_est</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot</a></span><span class="op">(</span><span class="va">pair_ids</span>, <span class="va">est_fun</span>, R <span class="op">=</span> <span class="fl">499</span><span class="op">)</span>
<span class="va">boot_est</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## ORDINARY NONPARAMETRIC BOOTSTRAP</span>
<span class="co">## </span>
<span class="co">## </span>
<span class="co">## Call:</span>
<span class="co">## boot(data = pair_ids, statistic = est_fun, R = 499)</span>
<span class="co">## </span>
<span class="co">## </span>
<span class="co">## Bootstrap Statistics :</span>
<span class="co">##     original   bias    std. error</span>
<span class="co">## t1*    2.114 0.003777      0.3862</span></code></pre>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.ci.html" class="external-link">boot.ci</a></span><span class="op">(</span><span class="va">boot_est</span>, type <span class="op">=</span> <span class="st">"bca"</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS</span>
<span class="co">## Based on 499 bootstrap replicates</span>
<span class="co">## </span>
<span class="co">## CALL : </span>
<span class="co">## boot.ci(boot.out = boot_est, type = "bca")</span>
<span class="co">## </span>
<span class="co">## Intervals : </span>
<span class="co">## Level       BCa          </span>
<span class="co">## 95%   ( 1.317,  2.758 )  </span>
<span class="co">## Calculations and Intervals on Original Scale</span>
<span class="co">## Some BCa intervals may be unstable</span></code></pre>
<p>The value <code>t1*</code> in the <code>Bootstrap Statistics</code> table contains the effect estimate and its bootstrap standard error, and the interval in the confidence interval output is the bootstrap confidence interval computed using the specified type (here, <code>"bca"</code>).</p>
<p><strong>With covariate adjustment.</strong> Including covariates in the outcome model is straightforward with a continuous outcome. We can include main effects for each variable and use the coefficient on the treatment as the treatment effect estimate. It can also be helpful to include interactions between the covariates and treatment if effect modification is suspected, though it is important to center the covariates at their means in the focal (i.e., treated) group if the coefficient on the treatment is to be interpreted as an average treatment effect estimate (which we demonstrate with full matching). A marginal effects procedure can also be used, which we demonstrate with binary outcomes. Below we simply include main effects of each covariate, which is the most typical way to include covariates.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Linear model with covariates</span>
<span class="va">fit3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span> <span class="op">+</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
             <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">md</span>,
           weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit3</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span><span class="op">)</span><span class="op">[</span><span class="st">"A"</span>,,drop<span class="op">=</span><span class="cn">FALSE</span><span class="op">]</span></code></pre></div>
<pre><code><span class="co">##   Estimate Std. Error t value  Pr(&gt;|t|)</span>
<span class="co">## A    2.029     0.3202   6.338 3.735e-10</span></code></pre>
<p>As previously mentioned, it is important to avoid interpreting coefficients in the outcome model on predictors other than the treatment, as the coefficients do no correspond to causal effects and are likely confounded. In the code above, we restricted the output to just the treatment effect. Note that sometimes the intercept of the outcome model can be useful as an estimate of the average potential outcome under control, but the covariates in the model (if any) must be centered at their means in the target population to allow for this interpretation. Without centering the covariates, the intercept is uninterpretable.</p>
</div>
<div class="section level4">
<h4 id="for-binary-outcomes">For binary outcomes<a class="anchor" aria-label="anchor" href="#for-binary-outcomes"></a>
</h4>
<p>For binary outcomes, effect estimation can be a bit more challenging, especially when including covariates. There are several measures of the effect one can consider, which include the odds ratio (OR), risk ratio/relative risk (RR), and risk difference (RD).</p>
<p><strong>Without covariate adjustment.</strong> When omitting covariates from the outcome model, effect and standard error estimation is fairly straightforward. Below we demonstrate how to estimate the marginal log OR after nearest neighbor matching without replacement.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Generalized linear model without covariates</span>
<span class="va">fit4</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">Y_B</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, weights <span class="op">=</span> <span class="va">weights</span>, 
            family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial</a></span><span class="op">(</span>link <span class="op">=</span> <span class="st">"logit"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>By specifying <code>link = "logit"</code>, we fit a logistic regression model to estimate the marginal OR for treatment. To estimate the marginal RR we can specify <code>link = "log"</code>, and to estimate the RD we can specify <code>link = "identity"</code> or use <code><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm()</a></code> instead of <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code>. Below we estimate cluster-robust standard errors, though it should be noted that these standard errors can be biased for the OR and should be used with caution <span class="citation">(Austin <a href="#ref-austin2007a" role="doc-biblioref">2007</a>)</span>. Because we want the OR and the effects are estimated on the log OR scale, we have to exponentiate the coefficient on treatment to arrive at the OR (one would do this when estimating the OR or RR, but not the RD).</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Cluster-robust standard errors</span>
<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit4</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## z test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error z value Pr(&gt;|z|)    </span>
<span class="co">## (Intercept)   -0.939      0.106   -8.85  &lt; 2e-16 ***</span>
<span class="co">## A              0.834      0.143    5.82  5.7e-09 ***</span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fit4</span><span class="op">)</span><span class="op">)</span> <span class="co">#OR</span></code></pre></div>
<pre><code><span class="co">## (Intercept)           A </span>
<span class="co">##      0.3912      2.3030</span></code></pre>
<p><strong>With covariate adjustment and bootstrapping.</strong> If we want to include covariates in the model, we have to do some additional work to estimate the effect and its standard error. This is because the coefficient on treatment in a nonlinear model with covariates corresponds to the conditional rather than marginal effect. To estimate a marginal effect, we have to perform a marginal effects procedure, which is equivalent to g-computation in the matched set. First we estimate an outcome model including the covariates, and then we use the predictions from the outcome model to compute the contrast of the average potential outcomes under treatment and control. Bootstrapping is the most straightforward method to estimate standard errors. We demonstrate this below using the block bootstrap as recommended by <span class="citation">Abadie and Spiess (<a href="#ref-abadie2019" role="doc-biblioref">2019</a>)</span>.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Block bootstrap confidence interval</span>
<span class="co"># library(boot)</span>

<span class="va">pair_ids</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/levels.html" class="external-link">levels</a></span><span class="op">(</span><span class="va">md</span><span class="op">$</span><span class="va">subclass</span><span class="op">)</span>

<span class="va">est_fun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">pairs</span>, <span class="va">i</span><span class="op">)</span> <span class="op">{</span>
  
  <span class="co">#Compute number of times each pair is present</span>
  <span class="va">numreps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">pairs</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span>
  
  <span class="co">#For each pair p, copy corresponding md row indices numreps[p] times</span>
  <span class="va">ids</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">pair_ids</span><span class="op">[</span><span class="va">pair_ids</span> <span class="op"><a href="https://rdrr.io/r/base/match.html" class="external-link">%in%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">numreps</span><span class="op">)</span><span class="op">]</span>,
                       <span class="kw">function</span><span class="op">(</span><span class="va">p</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">md</span><span class="op">$</span><span class="va">subclass</span> <span class="op">==</span> <span class="va">p</span><span class="op">)</span>, 
                                              <span class="va">numreps</span><span class="op">[</span><span class="va">p</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
  
  <span class="co">#Subset md with block bootstrapped ids</span>
  <span class="va">md_boot</span> <span class="op">&lt;-</span> <span class="va">md</span><span class="op">[</span><span class="va">ids</span>,<span class="op">]</span>
  
  <span class="co">#Fitting outcome the model</span>
  <span class="va">fit_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">Y_B</span> <span class="op">~</span> <span class="va">A</span> <span class="op">+</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                    <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">md_boot</span>, 
                  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial</a></span><span class="op">(</span>link <span class="op">=</span> <span class="st">"logit"</span><span class="op">)</span>,
                  weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>
  
  <span class="co">#Estimate potential outcomes for each unit</span>
  <span class="co">#Under control</span>
  <span class="va">md_boot</span><span class="op">$</span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fl">0</span>
  <span class="va">P0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit_boot</span>, <span class="va">md_boot</span>, type <span class="op">=</span> <span class="st">"response"</span><span class="op">)</span>,
                      w <span class="op">=</span> <span class="va">md_boot</span><span class="op">$</span><span class="va">weights</span><span class="op">)</span>
  <span class="va">Odds0</span> <span class="op">&lt;-</span> <span class="va">P0</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">P0</span><span class="op">)</span>
  
  <span class="co">#Under treatment</span>
  <span class="va">md_boot</span><span class="op">$</span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fl">1</span>
  <span class="va">P1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit_boot</span>, <span class="va">md_boot</span>, type <span class="op">=</span> <span class="st">"response"</span><span class="op">)</span>,
                      w <span class="op">=</span> <span class="va">md_boot</span><span class="op">$</span><span class="va">weights</span><span class="op">)</span>
  <span class="va">Odds1</span> <span class="op">&lt;-</span> <span class="va">P1</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">P1</span><span class="op">)</span>

  <span class="co">#Return marginal odds ratio</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">Odds1</span> <span class="op">/</span> <span class="va">Odds0</span><span class="op">)</span>
<span class="op">}</span>

<span class="va">boot_est</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot</a></span><span class="op">(</span><span class="va">pair_ids</span>, <span class="va">est_fun</span>, R <span class="op">=</span> <span class="fl">499</span><span class="op">)</span>
<span class="va">boot_est</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## ORDINARY NONPARAMETRIC BOOTSTRAP</span>
<span class="co">## </span>
<span class="co">## </span>
<span class="co">## Call:</span>
<span class="co">## boot(data = pair_ids, statistic = est_fun, R = 499)</span>
<span class="co">## </span>
<span class="co">## </span>
<span class="co">## Bootstrap Statistics :</span>
<span class="co">##     original  bias    std. error</span>
<span class="co">## t1*    2.225  0.0291      0.2727</span></code></pre>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.ci.html" class="external-link">boot.ci</a></span><span class="op">(</span><span class="va">boot_est</span>, type <span class="op">=</span> <span class="st">"bca"</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS</span>
<span class="co">## Based on 499 bootstrap replicates</span>
<span class="co">## </span>
<span class="co">## CALL : </span>
<span class="co">## boot.ci(boot.out = boot_est, type = "bca")</span>
<span class="co">## </span>
<span class="co">## Intervals : </span>
<span class="co">## Level       BCa          </span>
<span class="co">## 95%   ( 1.785,  2.827 )  </span>
<span class="co">## Calculations and Intervals on Original Scale</span>
<span class="co">## Some BCa intervals may be unstable</span></code></pre>
<p>To use bootstrapping for the RR or RD, the part of the code that computes the marginal OR can be replaced with code to compute the marginal RR (<code>P1 / P0</code>) or marginal RD (<code>P1 - P0</code>). Interactions between the treatment and covariates can be included in the outcome model; no other part of the procedure needs to be changed. Doing so can add robustness when effect modification is possible.</p>
</div>
<div class="section level4">
<h4 id="for-survival-outcomes">For survival outcomes<a class="anchor" aria-label="anchor" href="#for-survival-outcomes"></a>
</h4>
<p>There are several measures of effect size for survival outcomes. When using the Cox proportional hazards model, the quantity of interest is the HR between the treated and control groups. As with the OR, the HR is non-collapsible, which means the estimated HR will only be a valid estimate of the marginal HR when no other covariates are included in the model. Other effect measures, such as the difference in mean survival times or probability of survival after a given time, can be treated just like continuous and binary outcomes as previously described. Here we describe estimating the marginal HR.</p>
<p><strong>Without covariate adjustment.</strong> Below we demonstrate estimation of the marginal hazard ratio using <code><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph()</a></code> from the <code>survival</code> package. To request cluster-robust standard errors as recommended by <span class="citation">Austin (<a href="#ref-austin2013a" role="doc-biblioref">2013</a><a href="#ref-austin2013a" role="doc-biblioref">b</a>)</span>, we need to supply pair membership (stored in the <code>subclass</code> column of <code>md</code>) to the <code>cluster</code> argument and set <code>robust = TRUE</code>.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Cox Regression for marginal HR</span>
<span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">Y_S</span><span class="op">)</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, robust <span class="op">=</span> <span class="cn">TRUE</span>, 
      weights <span class="op">=</span> <span class="va">weights</span>, cluster <span class="op">=</span> <span class="va">subclass</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## Call:</span>
<span class="co">## coxph(formula = Surv(Y_S) ~ A, data = md, weights = weights, </span>
<span class="co">##     robust = TRUE, cluster = subclass)</span>
<span class="co">## </span>
<span class="co">##   coef exp(coef) se(coef) robust se z     p</span>
<span class="co">## A 0.43      1.53     0.07      0.07 6 1e-09</span>
<span class="co">## </span>
<span class="co">## Likelihood ratio test=39  on 1 df, p=5e-10</span>
<span class="co">## n= 882, number of events= 882</span></code></pre>
<p>The <code>coef</code> column contains the log HR, and <code>exp(coef)</code> contains the HR. Remember to always use the <code>robust se</code> for the standard error of the log HR. The displayed z-test p-value results from using the robust standard error.</p>
<p><strong>Using the bootstrap.</strong> <span class="citation">Austin and Small (<a href="#ref-austin2014" role="doc-biblioref">2014</a>)</span> found bootstrap confidence intervals to work well for marginal hazard ratios. Below we demonstrate this using similar code as before to implement the block bootstrap:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Block bootstrap confidence interval</span>
<span class="co"># library(boot)</span>

<span class="va">pair_ids</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/levels.html" class="external-link">levels</a></span><span class="op">(</span><span class="va">md</span><span class="op">$</span><span class="va">subclass</span><span class="op">)</span>

<span class="va">est_fun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">pairs</span>, <span class="va">i</span><span class="op">)</span> <span class="op">{</span>
  
  <span class="co">#Compute number of times each pair is present</span>
  <span class="va">numreps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">pairs</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span>
  
  <span class="co">#For each pair p, copy corresponding md row indices numreps[p] times</span>
  <span class="va">ids</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">pair_ids</span><span class="op">[</span><span class="va">pair_ids</span> <span class="op"><a href="https://rdrr.io/r/base/match.html" class="external-link">%in%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">numreps</span><span class="op">)</span><span class="op">]</span>,
                       <span class="kw">function</span><span class="op">(</span><span class="va">p</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">md</span><span class="op">$</span><span class="va">subclass</span> <span class="op">==</span> <span class="va">p</span><span class="op">)</span>, 
                                              <span class="va">numreps</span><span class="op">[</span><span class="va">p</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
  
  <span class="co">#Subset md with block bootstrapped ids</span>
  <span class="va">md_boot</span> <span class="op">&lt;-</span> <span class="va">md</span><span class="op">[</span><span class="va">ids</span>,<span class="op">]</span>
  
  <span class="co">#Effect estimation</span>
  <span class="va">cox_fit_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">Y_S</span><span class="op">)</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md_boot</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>
  
  <span class="co">#Compute the marginal HR by exponentiating the coefficient</span>
  <span class="co">#on treatment</span>
  <span class="va">HR</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">cox_fit_boot</span><span class="op">)</span><span class="op">[</span><span class="st">"A"</span><span class="op">]</span><span class="op">)</span>
  
  <span class="co">#Return the HR</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">HR</span><span class="op">)</span>
<span class="op">}</span>

<span class="va">boot_est</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot</a></span><span class="op">(</span><span class="va">pair_ids</span>, <span class="va">est_fun</span>, R <span class="op">=</span> <span class="fl">499</span><span class="op">)</span>
<span class="va">boot_est</span>
<span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.ci.html" class="external-link">boot.ci</a></span><span class="op">(</span><span class="va">boot_est</span>, type <span class="op">=</span> <span class="st">"bca"</span><span class="op">)</span></code></pre></div>
<p><strong>With covariate adjustment.</strong> As with binary outcomes, if covariates are included in the model, the resulting hazard ratios will be conditional rather than marginal. <span class="citation">Austin, Thomas, and Rubin (<a href="#ref-austin2020" role="doc-biblioref">2020</a>)</span> describe several ways of including covariates in a model to estimate the marginal HR, but because they do not develop standard errors and little research has been done on this method, we will not present it here.</p>
</div>
</div>
<div class="section level3">
<h3 id="after-pair-matching-with-replacement">After Pair Matching With Replacement<a class="anchor" aria-label="anchor" href="#after-pair-matching-with-replacement"></a>
</h3>
<p>Pair matching with replacement makes estimating effects and standard errors a bit less straightforward. Control units paired with multiple treated units belong to multiple pairs at the same time and appear multiple times in the matched dataset. Effect and standard error estimation need to account for control unit multiplicity (i.e., repeated use) and within-pair correlations <span class="citation">(Hill and Reiter <a href="#ref-hill2006" role="doc-biblioref">2006</a>; Austin and Cafri <a href="#ref-austin2020a" role="doc-biblioref">2020</a>)</span>.</p>
<p><code>MatchIt</code> provides two interfaces for extracting the matched dataset after matching with replacement. The first uses <code><a href="../reference/match.data.html">match.data()</a></code> and provides the same output as when used after matching without replacement, except that the <code>subclass</code> column is absent because units are not assigned to a single subclass but rather to several. Control units will have weights that differ from 1 to reflect their use as matches for multiple treated units. When using the <code><a href="../reference/match.data.html">match.data()</a></code> interface, including the weights in the estimation of effects is crucial. Because pair membership is omitted, accounting for it (if desired) must be done by conditioning on covariates used to match the pairs or by bootstrapping the entire process.</p>
<p>The second interface uses <code><a href="../reference/match.data.html">get_matches()</a></code>, which functions similarly to <code><a href="../reference/match.data.html">match.data()</a></code> except that the dataset contains one row per unit per pair, so control units matched to multiple treated units will have multiple rows in the dataset, and a <code>subclass</code> column is included denoting pair membership. In the <code><a href="../reference/match.data.html">get_matches()</a></code> output, each reused control unit will have multiple rows, identical to each other except with different <code>subclass</code> membership. When performing k:1 matching, weights must also be included in effect estimation when using <code><a href="../reference/match.data.html">get_matches()</a></code>.</p>
<p>Here we will demonstrate the estimation of effects using both <code><a href="../reference/match.data.html">match.data()</a></code> and <code><a href="../reference/match.data.html">get_matches()</a></code> output. The <code><a href="../reference/match.data.html">match.data()</a></code> output is preferred when pair membership is not directly included in the analysis, and the <code><a href="../reference/match.data.html">get_matches()</a></code> output is preferred when pair membership is to be included. Here will will use 3:1 matching with replacement and with a caliper; note that because a caliper was used, the estimand corresponds to neither the ATT nor the ATE but rather to an ATM.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mNNr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">d</span>,
               link <span class="op">=</span> <span class="st">"linear.logit"</span>, caliper <span class="op">=</span> <span class="fl">.1</span>,
               ratio <span class="op">=</span> <span class="fl">3</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>

<span class="va">mNNr</span></code></pre></div>
<pre><code><span class="co">## A matchit object</span>
<span class="co">##  - method: 3:1 nearest neighbor matching with replacement</span>
<span class="co">##  - distance: Propensity score [caliper]</span>
<span class="co">##              - estimated with logistic regression and linearized</span>
<span class="co">##  - caliper: &lt;distance&gt; (0.13)</span>
<span class="co">##  - number of obs.: 2000 (original), 1040 (matched)</span>
<span class="co">##  - target estimand: ATT</span>
<span class="co">##  - covariates: X1, X2, X3, X4, X5, X6, X7, X8, X9</span></code></pre>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#match.data output</span>
<span class="va">md</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mNNr</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">md</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## [1] 1040</span></code></pre>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">md</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">##    A      X1      X2      X3      X4 X5      X6      X7      X8       X9      Y_C Y_B    Y_S distance weights</span>
<span class="co">## 1  0  0.1725 -1.4283 -0.4103 -2.3606  1 -1.1199  0.6398 -0.4840 -0.59385  0.07104   0 278.46   -2.381  0.9571</span>
<span class="co">## 3  0  0.1768  0.7905 -0.8436  0.8237  1 -0.2221  0.2971 -0.6966 -0.69516 -0.85180   1 369.94   -1.253  0.4785</span>
<span class="co">## 5  1  0.3563 -1.8121  0.8135 -0.6719  1 -0.8297  1.7297 -0.6439 -0.02648  0.68058   0 182.73   -0.270  1.0000</span>
<span class="co">## 7  0  1.8402  1.7601 -1.0746 -1.6428  1  1.4482  0.7131  0.6972 -0.94673  4.28651   1  97.49   -2.281  0.4785</span>
<span class="co">## 9  0  0.7808  1.3137  0.6580  0.8540  1  0.9495 -0.5731 -0.2362 -0.14580 15.89771   1  67.53   -1.677  0.4785</span>
<span class="co">## 10 1 -0.5651 -0.1053 -0.1369  1.6233  1 -0.5304 -0.3342  0.4184  0.46308  1.07888   1 113.70   -1.607  1.0000</span></code></pre>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#get_matches output</span>
<span class="va">gm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">get_matches</a></span><span class="op">(</span><span class="va">mNNr</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">gm</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## [1] 1681</span></code></pre>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">gm</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">##    id subclass weights A       X1      X2       X3      X4 X5      X6      X7      X8       X9     Y_C Y_B    Y_S distance</span>
<span class="co">## 1   5        1  1.0000 1  0.35631 -1.8121  0.81349 -0.6719  1 -0.8297  1.7297 -0.6439 -0.02648  0.6806   0 182.73  -0.2700</span>
<span class="co">## 2 740        1  0.3333 0  0.02725 -0.4570 -0.32506  1.1203  1  0.3795  0.6468 -0.9992  0.01917 -0.9042   1 215.25  -0.2736</span>
<span class="co">## 3 939        1  0.3333 0  0.92888 -0.2562  0.39077  0.3305  1  0.2654  1.2038  0.1720  1.21006  7.8923   0  83.85  -0.2736</span>
<span class="co">## 4 860        1  0.3333 0 -0.88047  0.9117 -0.38871  1.0696  0  1.7953  0.2470 -1.6115  1.49297  5.3808   0 236.01  -0.2752</span>
<span class="co">## 5  10        2  1.0000 1 -0.56513 -0.1053 -0.13685  1.6233  1 -0.5304 -0.3342  0.4184  0.46308  1.0789   1 113.70  -1.6073</span>
<span class="co">## 6 399        2  0.3333 0  0.80396 -0.8760  0.03938 -0.5895  1  0.2819 -0.6540 -0.5423  1.16852  4.4816   1 117.28  -1.6065</span></code></pre>
<p>The <code><a href="../reference/match.data.html">get_matches()</a></code> output provides some additional information about the match. We can count how many times control units are reused and how many units are in each match strata (not all will have 3 control units due to the caliper).</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Number of time control units are rematched</span>
<span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">gm</span><span class="op">$</span><span class="va">id</span><span class="op">[</span><span class="va">gm</span><span class="op">$</span><span class="va">A</span> <span class="op">==</span> <span class="fl">0</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">##   1   2   3   4   5   6   7   8   9  10  13  14 </span>
<span class="co">## 332 138  62  29  19   9  14   4   2   2   1   1</span></code></pre>
<p>Here we can see that 332 control units were only used in one pair each, and one control unit was paired with 14 treated units (i.e., heavily reused).</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Number of control units in each match stratum</span>
<span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">gm</span><span class="op">$</span><span class="va">subclass</span><span class="op">[</span><span class="va">gm</span><span class="op">$</span><span class="va">A</span> <span class="op">==</span> <span class="fl">0</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">##   1   2   3 </span>
<span class="co">##   9   9 409</span></code></pre>
<p>Here we can see that 409 treated units have three matches, nine have two matches, and nine only have one match. The caliper did not end up restricting too many matches.</p>
<div class="section level4">
<h4 id="for-continuous-outcomes-1">For continuous outcomes<a class="anchor" aria-label="anchor" href="#for-continuous-outcomes-1"></a>
</h4>
<p><strong>Without covariate adjustment.</strong> For continuous outcomes, we can regress the outcome on the treatment and include the weights in the estimation. We do this regardless of whether we are using the <code><a href="../reference/match.data.html">match.data()</a></code> output or the <code><a href="../reference/match.data.html">get_matches()</a></code> output (if we were doing 1:1 matching, the weights would not be necessary when using the <code><a href="../reference/match.data.html">get_matches()</a></code> output, but they don’t change the results if included).</p>
<p>If we don’t mind ignoring pair membership, we can use the <code><a href="../reference/match.data.html">match.data()</a></code> output to estimate the effect and standard errors. Here we use <code><a href="https://sandwich.R-Forge.R-project.org//reference/vcovHC.html" class="external-link">vcovHC()</a></code> to estimate regular robust standard errors that ignoring pairing. <span class="citation">Hill and Reiter (<a href="#ref-hill2006" role="doc-biblioref">2006</a>)</span> found these standard errors to be conservative for continuous outcomes.</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#match.data() output</span>
<span class="va">fit1md</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit1md</span>, vcov. <span class="op">=</span> <span class="va">vcovHC</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## t test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">## (Intercept)    1.798      0.420    4.28  2.0e-05 ***</span>
<span class="co">## A              2.065      0.514    4.02  6.3e-05 ***</span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<p>If we want to incorporate pair membership into the standard error estimation, we have to use the <code><a href="../reference/match.data.html">get_matches()</a></code> output. In addition to supplying pair membership (<code>subclass</code>) to the standard error estimator, we also supply unit ID (<code>id</code>) to account for the fact that several rows may refer to the same control unit.</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#get_matches() output</span>
<span class="va">fit1gm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">gm</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit1gm</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span> <span class="op">+</span> <span class="va">id</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## t test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">## (Intercept)    1.798      0.416    4.32  1.7e-05 ***</span>
<span class="co">## A              2.065      0.510    4.05  5.4e-05 ***</span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<p>Note that the effect estimates are identical; only the standard errors and p-values differ between the approaches<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<p><strong>Using the bootstrap.</strong> We can also use bootstrapping to estimate standard errors and confidence intervals. Although <span class="citation">Abadie and Imbens (<a href="#ref-abadie2008" role="doc-biblioref">2008</a>)</span> demonstrated analytically that bootstrap standard errors may be invalid for matching with replacement, simulation work by <span class="citation">Hill and Reiter (<a href="#ref-hill2006" role="doc-biblioref">2006</a>)</span> and <span class="citation">Bodory et al. (<a href="#ref-bodory2020" role="doc-biblioref">2020</a>)</span> has found that bootstrap standard errors are adequate and generally slightly conservative. Given this disagreement, it may be worth proceeding with caution when using bootstrapping to estimate standard errors after matching with replacement. Simulation experiments with matching with replacement have only considered the full bootstrap and found it to yield confidence intervals with approximately nominal coverage, so we recommend this approach over the block bootstrap for now and demonstrate it below.</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Full bootstrap confidence interval</span>
<span class="co"># library(boot)</span>

<span class="va">est_fun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">i</span><span class="op">)</span> <span class="op">{</span>
  <span class="co">#Matching function</span>
  <span class="va">mNNr_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                         <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span>,
                       link <span class="op">=</span> <span class="st">"linear.logit"</span>, caliper <span class="op">=</span> <span class="fl">.1</span>,
                       ratio <span class="op">=</span> <span class="fl">3</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
  <span class="va">md_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mNNr_boot</span><span class="op">)</span>
  
  <span class="co">#Effect estimation</span>
  <span class="va">fit_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md_boot</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>
  
  <span class="co">#Return the coefficient on treatment</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fit_boot</span><span class="op">)</span><span class="op">[</span><span class="st">"A"</span><span class="op">]</span><span class="op">)</span>
<span class="op">}</span>

<span class="va">boot_est</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot</a></span><span class="op">(</span><span class="va">d</span>, <span class="va">est_fun</span>, R <span class="op">=</span> <span class="fl">499</span><span class="op">)</span>
<span class="va">boot_est</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## ORDINARY NONPARAMETRIC BOOTSTRAP</span>
<span class="co">## </span>
<span class="co">## </span>
<span class="co">## Call:</span>
<span class="co">## boot(data = d, statistic = est_fun, R = 499)</span>
<span class="co">## </span>
<span class="co">## </span>
<span class="co">## Bootstrap Statistics :</span>
<span class="co">##     original  bias    std. error</span>
<span class="co">## t1*    2.065 -0.1287      0.4398</span></code></pre>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.ci.html" class="external-link">boot.ci</a></span><span class="op">(</span><span class="va">boot_est</span>, type <span class="op">=</span> <span class="st">"perc"</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS</span>
<span class="co">## Based on 499 bootstrap replicates</span>
<span class="co">## </span>
<span class="co">## CALL : </span>
<span class="co">## boot.ci(boot.out = boot_est, type = "perc")</span>
<span class="co">## </span>
<span class="co">## Intervals : </span>
<span class="co">## Level     Percentile     </span>
<span class="co">## 95%   ( 1.049,  2.796 )  </span>
<span class="co">## Calculations and Intervals on Original Scale</span></code></pre>
<p><strong>With covariate adjustment.</strong> We can include covariates in the outcome model just as we could when matching without replacement. <span class="citation">Hill and Reiter (<a href="#ref-hill2006" role="doc-biblioref">2006</a>)</span> found that standard errors that fail to account for pair membership can have lower the nominal confidence interval coverage, so we recommend using the <code><a href="../reference/match.data.html">get_matches()</a></code> output to address both multiplicity and clustering.</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fit2md</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span> <span class="op">+</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">gm</span>, 
             weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit1gm</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span> <span class="op">+</span> <span class="va">id</span><span class="op">)</span><span class="op">[</span><span class="st">"A"</span>,,drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span></code></pre></div>
<pre><code><span class="co">##   Estimate Std. Error t value  Pr(&gt;|t|)</span>
<span class="co">## A    2.065       0.51   4.048 5.392e-05</span></code></pre>
<p>Remember that the coefficients and tests on the predictors other than the treatment should not be interpreted because they may be subject to confounding even if the treatment is not, so we omit them here.</p>
</div>
<div class="section level4">
<h4 id="for-binary-outcomes-1">For binary outcomes<a class="anchor" aria-label="anchor" href="#for-binary-outcomes-1"></a>
</h4>
<p>The primary difference between dealing with binary and continuous outcomes is the noncollapsibility of the effect measures for binary outcomes, meaning that including covariates in the outcome model is less straightforward because the coefficient on treatment does not correspond to the marginal treatment effect. Similar to continuous outcomes, when estimating the treatment effect, we can use either the output of <code><a href="../reference/match.data.html">match.data()</a></code> or the output of <code><a href="../reference/match.data.html">get_matches()</a></code>, only the latter of which allows us to account both for multiplicity in the control units and for pair membership. Below we’ll demonstrate estimating the marginal OR accounting for pair membership using the <code><a href="../reference/match.data.html">get_matches()</a></code> output. Then we will demonstrate using the bootstrap to estimate standard errors that include covariates in the model. Note that there has been little research on the use of matching with replacement with binary outcomes, so one should proceed with caution and consider using a better-studied matching method.</p>
<p><strong>Without covariate adjustment.</strong> We include the weights in the call to <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code> and we include both <code>subclass</code> and <code>id</code> as clustering variables in computing the cluster-robust standard errors, just as we would with a continuous outcome. We can use <code>family = quasibinomial</code> instead of <code>family = binomial</code> to avoid a warning due to the use of weights; the estimates will be the same either way. To estimate the marginal RR or RD, <code>"logit"</code> would be replaced with <code>"log"</code> or <code>"identity"</code>, respectively.</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fit3gm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">Y_B</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">gm</span>, weights <span class="op">=</span> <span class="va">weights</span>,
              family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">quasibinomial</a></span><span class="op">(</span>link <span class="op">=</span> <span class="st">"logit"</span><span class="op">)</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit3gm</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span> <span class="va">subclass</span> <span class="op">+</span> <span class="va">id</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## z test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error z value Pr(&gt;|z|)    </span>
<span class="co">## (Intercept)   -0.766      0.139   -5.50  3.9e-08 ***</span>
<span class="co">## A              0.639      0.169    3.78  0.00016 ***</span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fit3gm</span><span class="op">)</span><span class="op">)</span> <span class="co">#OR</span></code></pre></div>
<pre><code><span class="co">## (Intercept)           A </span>
<span class="co">##      0.4648      1.8954</span></code></pre>
<p><strong>With covariate adjustment and bootstrapping.</strong> To include covariates, we can use the bootstrap as we did before when matching without replacement. It doesn’t matter whether the <code><a href="../reference/match.data.html">match.data()</a></code> or <code><a href="../reference/match.data.html">get_matches()</a></code> output is used because, as we saw before, both yield the same effect estimate in each bootstrap replication. Here we use the full bootstrap rather than the block bootstrap because the performance of the block bootstrap after matching with replacement has not been evaluated.</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Bootstrap confidence intervals</span>
<span class="co"># library(boot)</span>

<span class="va">est_fun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">i</span><span class="op">)</span> <span class="op">{</span>
  <span class="co">#Matching function</span>
  <span class="va">mNNr_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span>,
               link <span class="op">=</span> <span class="st">"linear.logit"</span>, caliper <span class="op">=</span> <span class="fl">.1</span>,
               ratio <span class="op">=</span> <span class="fl">3</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
  <span class="va">md_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mNNr_boot</span><span class="op">)</span>
  
  <span class="co">#Fitting the model</span>
  <span class="va">fit_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">Y_B</span> <span class="op">~</span> <span class="va">A</span> <span class="op">+</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                    <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">md_boot</span>, 
                  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">quasibinomial</a></span><span class="op">(</span>link <span class="op">=</span> <span class="st">"logit"</span><span class="op">)</span>,
                  weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>
  
  <span class="co">#Estimate potential outcomes for each unit</span>
  <span class="va">md_boot</span><span class="op">$</span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fl">0</span>
  <span class="va">P0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit_boot</span>, <span class="va">md_boot</span>, type <span class="op">=</span> <span class="st">"response"</span><span class="op">)</span>,
                      w <span class="op">=</span> <span class="va">md_boot</span><span class="op">$</span><span class="va">weights</span><span class="op">)</span>
  <span class="va">Odds0</span> <span class="op">&lt;-</span> <span class="va">P0</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">P0</span><span class="op">)</span>
  
  <span class="va">md_boot</span><span class="op">$</span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fl">1</span>
  <span class="va">P1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit_boot</span>, <span class="va">md_boot</span>, type <span class="op">=</span> <span class="st">"response"</span><span class="op">)</span>,
                      w <span class="op">=</span> <span class="va">md_boot</span><span class="op">$</span><span class="va">weights</span><span class="op">)</span>
  <span class="va">Odds1</span> <span class="op">&lt;-</span> <span class="va">P1</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">P1</span><span class="op">)</span>

  <span class="co">#Return marginal odds ratio</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">Odds1</span> <span class="op">/</span> <span class="va">Odds0</span><span class="op">)</span>
<span class="op">}</span>

<span class="va">boot_est</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot</a></span><span class="op">(</span><span class="va">d</span>, <span class="va">est_fun</span>, R <span class="op">=</span> <span class="fl">4999</span><span class="op">)</span>
<span class="va">boot_est</span>
<span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.ci.html" class="external-link">boot.ci</a></span><span class="op">(</span><span class="va">boot_est</span>, type <span class="op">=</span> <span class="st">"bca"</span><span class="op">)</span></code></pre></div>
<p>As before, to use bootstrapping for the RR or RD, the part of the code that computes the marginal OR can be replaced with code to compute the marginal RR (<code>P1 / P0</code>) or marginal RD (<code>P1 - P0</code>). The outcome model can additionally include treatment-covariate interactions if desired.</p>
</div>
<div class="section level4">
<h4 id="for-survival-outcomes-1">For survival outcomes<a class="anchor" aria-label="anchor" href="#for-survival-outcomes-1"></a>
</h4>
<p>Standard error estimation for the marginal HR after matching with replacement is not a well-studied area, with <span class="citation">Austin and Cafri (<a href="#ref-austin2020a" role="doc-biblioref">2020</a>)</span> providing the sole examination into appropriate methods for doing so. With survival outcomes, other matching methods may be more appropriate until matching with replacement is better understood. Here we provide an example that implements the recommendations by <span class="citation">Austin and Cafri (<a href="#ref-austin2020a" role="doc-biblioref">2020</a>)</span>. Any other methods (e.g., bootstrap) should be used with caution until they have been formally evaluated.</p>
<p><strong>Without covariate adjustment.</strong> According to the results of Austin and Cafri’s <span class="citation">(<a href="#ref-austin2020a" role="doc-biblioref">2020</a>)</span> simulation studies, when prevalence of the treatment is low (&lt;30%), a standard error that does not involve pair membership is sufficient. When treatment prevalence is higher, the standard error that ignores pair membership may be too low, and the authors recommend a custom standard error estimator that uses information about both multiplicity and pairing.</p>
<p>For the continuous and binary outcomes, accounting for both multiplicity and pair membership is fairly straightforward thanks to the ability of the <code>sandwich</code> package functions to include multiple sources of clustering. Unfortunately, this must be done manually for survival models. We perform this analysis below, adapting code from the appendix of <span class="citation">Austin and Cafri (<a href="#ref-austin2020a" role="doc-biblioref">2020</a>)</span> to the <code><a href="../reference/match.data.html">get_matches()</a></code> output.</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Austin &amp; Cafri's (2020) SE estimator</span>
<span class="va">fs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">Y_S</span><span class="op">)</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">gm</span>, robust <span class="op">=</span> <span class="cn">TRUE</span>, 
      weights <span class="op">=</span> <span class="va">weights</span>, cluster <span class="op">=</span> <span class="va">subclass</span><span class="op">)</span>
<span class="va">Vs</span> <span class="op">&lt;-</span> <span class="va">fs</span><span class="op">$</span><span class="va">var</span>
<span class="va">ks</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nlevels.html" class="external-link">nlevels</a></span><span class="op">(</span><span class="va">gm</span><span class="op">$</span><span class="va">subclass</span><span class="op">)</span>

<span class="va">fi</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">Y_S</span><span class="op">)</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">gm</span>, robust <span class="op">=</span> <span class="cn">TRUE</span>, 
      weights <span class="op">=</span> <span class="va">weights</span>, cluster <span class="op">=</span> <span class="va">id</span><span class="op">)</span>
<span class="va">Vi</span> <span class="op">&lt;-</span> <span class="va">fi</span><span class="op">$</span><span class="va">var</span>
<span class="va">ki</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">gm</span><span class="op">$</span><span class="va">id</span><span class="op">)</span><span class="op">)</span>

<span class="va">fc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">Y_S</span><span class="op">)</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">gm</span>, robust <span class="op">=</span> <span class="cn">TRUE</span>, 
      weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>
<span class="va">Vc</span> <span class="op">&lt;-</span> <span class="va">fc</span><span class="op">$</span><span class="va">var</span>
<span class="va">kc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">gm</span><span class="op">)</span>

<span class="co">#Compute the variance</span>
<span class="va">V</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">ks</span><span class="op">/</span><span class="op">(</span><span class="va">ks</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">*</span><span class="va">Vs</span> <span class="op">+</span> <span class="op">(</span><span class="va">ki</span><span class="op">/</span><span class="op">(</span><span class="va">ki</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">*</span><span class="va">Vi</span> <span class="op">-</span> <span class="op">(</span><span class="va">kc</span><span class="op">/</span><span class="op">(</span><span class="va">kc</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">*</span><span class="va">Vc</span>

<span class="co">#Sneak it back into the fit object</span>
<span class="va">fc</span><span class="op">$</span><span class="va">var</span> <span class="op">&lt;-</span> <span class="va">V</span>

<span class="va">fc</span></code></pre></div>
<pre><code><span class="co">## Call:</span>
<span class="co">## coxph(formula = Surv(Y_S) ~ A, data = gm, weights = weights, </span>
<span class="co">##     robust = TRUE)</span>
<span class="co">## </span>
<span class="co">##   coef exp(coef) se(coef) robust se z     p</span>
<span class="co">## A 0.44      1.55     0.07      0.07 6 1e-09</span>
<span class="co">## </span>
<span class="co">## Likelihood ratio test=40  on 1 df, p=2e-10</span>
<span class="co">## n= 1681, number of events= 1681</span></code></pre>
<p>The <code>robust se</code> column contains the computed standard error, and the reported Z-test uses this standard error. The <code>se(coef)</code> column should be ignored.</p>
</div>
</div>
<div class="section level3">
<h3 id="after-full-matching">After Full Matching<a class="anchor" aria-label="anchor" href="#after-full-matching"></a>
</h3>
<p>Full matching presents fairly straightforward methods of effect and standard error estimation. The most common and recommended way to estimate effects after full matching is to use the computed matching weights to estimate weighted effects. These matching weights function essentially like inverse probability weights and can be treated as such in all analyses, including with respect to standard error estimation. For empirical comparisons between full matching and propensity score weighting, see Austin and Stuart <span class="citation">(<a href="#ref-austin2015b" role="doc-biblioref">2015</a><a href="#ref-austin2015b" role="doc-biblioref">b</a>, <a href="#ref-austin2017" role="doc-biblioref">2017</a>, <a href="#ref-austin2015a" role="doc-biblioref">2015</a><a href="#ref-austin2015a" role="doc-biblioref">a</a>)</span>.</p>
<p>Standard error estimation involves using a cluster-robust standard error as recommended by <span class="citation">Austin and Stuart (<a href="#ref-austin2017" role="doc-biblioref">2017</a>)</span>. Including covariates can improve precision and add robustness when valid. Note that the methods described here also work for other estimators that rely on matching weights, including cardinality and template matching and matching without replacement. The main difference is that full matching can be used to estimate the ATE, which we demonstrate below.</p>
<p>Below, we perform optimal full propensity score matching. Here we use full matching to estimate the ATE, but the procedure is nearly identical when estimating the ATT, and we point out any differences.</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mF</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">d</span>,
              method <span class="op">=</span> <span class="st">"full"</span>, estimand <span class="op">=</span> <span class="st">"ATE"</span><span class="op">)</span>

<span class="va">mF</span></code></pre></div>
<pre><code><span class="co">## A matchit object</span>
<span class="co">##  - method: Optimal full matching</span>
<span class="co">##  - distance: Propensity score</span>
<span class="co">##              - estimated with logistic regression</span>
<span class="co">##  - number of obs.: 2000 (original), 2000 (matched)</span>
<span class="co">##  - target estimand: ATE</span>
<span class="co">##  - covariates: X1, X2, X3, X4, X5, X6, X7, X8, X9</span></code></pre>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">md</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mF</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">md</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">##   A      X1      X2      X3       X4 X5      X6      X7      X8       X9      Y_C Y_B     Y_S distance weights subclass</span>
<span class="co">## 1 0  0.1725 -1.4283 -0.4103 -2.36059  1 -1.1199  0.6398 -0.4840 -0.59385  0.07104   0  278.46  0.08461  0.8315       57</span>
<span class="co">## 2 0 -1.0959  0.8463  0.2456 -0.12333  1 -2.2687 -1.4491 -0.5514 -0.31439  0.15619   0  330.63  0.01855  0.7899      132</span>
<span class="co">## 3 0  0.1768  0.7905 -0.8436  0.82366  1 -0.2221  0.2971 -0.6966 -0.69516 -0.85180   1  369.94  0.22210  0.9094       97</span>
<span class="co">## 4 0 -0.4595  0.1726  1.9542 -0.62661  1 -0.4019 -0.8294 -0.5384  0.20729 -2.35184   0   91.06  0.04180  0.8166      136</span>
<span class="co">## 5 1  0.3563 -1.8121  0.8135 -0.67189  1 -0.8297  1.7297 -0.6439 -0.02648  0.68058   0  182.73  0.43291  0.3307      205</span>
<span class="co">## 6 0 -2.4313 -1.7984 -1.2940  0.04609  1 -1.2419 -1.1252 -1.8659 -0.56513 -5.62260   0 2563.73  0.04998  0.7976      169</span></code></pre>
<p>A benefit of full matching is that no units are discarded, which has the potential to improve precision and prevent bias due to incomplete matching. However, the “effective” sample size implied by the matching weights is lower than the actual remaining sample size, so one should not always expect full matching to yield more precise estimates than other forms of matching.</p>
<div class="section level4">
<h4 id="for-continuous-outcomes-2">For continuous outcomes<a class="anchor" aria-label="anchor" href="#for-continuous-outcomes-2"></a>
</h4>
<p><strong>Without covariate adjustment.</strong> Estimating effects and standard errors for continuous outcomes after full matching involves including the matching weights in the outcome model and using a cluster-robust standard error. For cardinality or template matching, a regular robust standard error can be requested using <code>vcovHC</code> and omitting the <code>cluster</code> argument in the code below.</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fit1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit1</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## t test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">## (Intercept)    1.454      0.252    5.76  9.9e-09 ***</span>
<span class="co">## A              1.722      0.513    3.35  0.00081 ***</span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<p><strong>Using the bootstrap.</strong> Computing bootstrap standard errors and confidence intervals after full matching is identical to doing so after pair matching without replacement, so we do not demonstrate it again here. Covariates can be included in the outcome model used in the bootstrap replications. See below for a note on centering the covariates when including treatment-covariate interactions, as this must be done when using the bootstrap as well.</p>
<p><strong>With covariate adjustment.</strong> As previously mentioned, it is generally acceptable to include just the main effects, but including interactions between the treatment and covariates can be beneficial when effect modification by the covariates may be present. Because we have not demonstrated this strategy so far, we demonstrate it below.</p>
<p>In order to interpret the coefficient on treatment as a marginal effect estimate, we need to center the covariates at their means in the target population (i.e., the original sample for the ATE, the treated units for the ATT, or the retained units for an ATM); we could also use a marginal effects procedure as has been demonstrated with binary outcomes for other matching methods. Below we use the strategy of centering the covariates at their means. Note that when factor predictors are present, they need to be split into dummy (0/1) variables prior to centering. The <code><a href="https://ngreifer.github.io/cobalt/reference/splitfactor.html" class="external-link">splitfactor()</a></code> function in <code>cobalt</code> can make this straightforward. Although this procedure is more involved compared to simply including main effects, it can provide extra precision and robustness.</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Estimating a covariate-adjusted marginal effect</span>
<span class="co">#with treatment-covariate interactions</span>

<span class="co">#Create a new dataset for centered variables</span>
<span class="va">md_cen</span> <span class="op">&lt;-</span> <span class="va">md</span>

<span class="va">covs_to_center</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"X1"</span>, <span class="st">"X2"</span>, <span class="st">"X3"</span>, <span class="st">"X4"</span>, <span class="st">"X5"</span>,
                    <span class="st">"X6"</span>, <span class="st">"X7"</span>, <span class="st">"X8"</span>, <span class="st">"X9"</span><span class="op">)</span>
<span class="va">md_cen</span><span class="op">[</span><span class="va">covs_to_center</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/scale.html" class="external-link">scale</a></span><span class="op">(</span><span class="va">md_cen</span><span class="op">[</span><span class="va">covs_to_center</span><span class="op">]</span>, 
                                scale <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span>

<span class="co">#Fit the model with every covariate interacting with treatment</span>
<span class="va">fit2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span> <span class="op">*</span> <span class="op">(</span><span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                      <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span><span class="op">)</span>,
           data <span class="op">=</span> <span class="va">md_cen</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>

<span class="co">#Only output the intercept and coefficient on treatment</span>
<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit2</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>,<span class="op">]</span></code></pre></div>
<pre><code><span class="co">##             Estimate Std. Error t value  Pr(&gt;|t|)</span>
<span class="co">## (Intercept)    1.396     0.1643   8.497 3.754e-17</span>
<span class="co">## A              1.844     0.4293   4.295 1.828e-05</span></code></pre>
<p>Remember not to interpret the coefficients on the covariates or the treatment-covariate interactions, as they are likely confounded. To keep the output clean, above we restricted the output to just the intercept and coefficient on treatment. Another benefit of centering the covariates is that we can interpret the intercept as an estimate of the average potential outcome under control.</p>
<p>Note that the above strategy can be applied to all matching methods when analyzing continuous outcomes (but not binary or survival outcomes, which require bootstrapping to validly estimate standard errors with covariate adjustment). It is critical to center the covariates at their means in the target group, which may require some additional programming for estimands other than the ATE.</p>
</div>
<div class="section level4">
<h4 id="for-binary-outcomes-2">For binary outcomes<a class="anchor" aria-label="anchor" href="#for-binary-outcomes-2"></a>
</h4>
<p>Using full matching with binary outcomes was described by <span class="citation">Austin and Stuart (<a href="#ref-austin2017" role="doc-biblioref">2017</a>)</span>. In general, the procedures look similar to how they do with other matching methods.</p>
<p><strong>Without covariate adjustment.</strong> We can use a weighted generalized linear model regressing the outcome on the treatment with a link function appropriate to the effect measure of interest. Below we demonstrate estimating the marginal OR after full matching in a model without covariates:</p>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fit3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">Y_B</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, weights <span class="op">=</span> <span class="va">weights</span>,
            family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">quasibinomial</a></span><span class="op">(</span>link <span class="op">=</span> <span class="st">"logit"</span><span class="op">)</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit3</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## z test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error z value Pr(&gt;|z|)    </span>
<span class="co">## (Intercept)  -0.9125     0.0835   -10.9  &lt; 2e-16 ***</span>
<span class="co">## A             0.5700     0.1727     3.3  0.00097 ***</span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<div class="sourceCode" id="cb70"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fit3</span><span class="op">)</span><span class="op">)</span> <span class="co">#OR</span></code></pre></div>
<pre><code><span class="co">## (Intercept)           A </span>
<span class="co">##      0.4015      1.7683</span></code></pre>
<p>As with matching with replacement, we include weights in the call to <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code> and set <code>family = quasibinomial()</code> to prevent a warning that occurs when using weights with binomial regression models (though the results do not differ). Setting <code>link = "logit"</code> provides the marginal OR; for the marginal RR, we would replace <code>"logit"</code> with <code>"log"</code>, and for the marginal RD, we would replace <code>"logit"</code> with <code>"identity"</code> and not exponentiate the coefficient.</p>
<p><strong>With covariate adjustment and bootstrapping.</strong> To include covariates in the model, a marginal effects procedure must be used with bootstrapping to recover the marginal effect because the coefficient on treatment in such a model corresponds to a conditional effect. A bootstrap must be used to estimate the standard error and confidence interval of the marginal effect. Either the full bootstrap or block bootstrap can be used, though the performance of the latter has not been formally evaluated (but because it is an approximation to cluster-robust standard errors, which are valid, it is likely valid). The code for the full bootstrap with full matching is identical to the code for bootstrapping with binary outcomes for pair matching with replacement (except that the call to <code><a href="../reference/matchit.html">matchit()</a></code> in the <code>est_fun</code> function must be adjusted to perform full matching), and the code for the block bootstrap with full matching is identical to the code for bootstrapping with binary outcomes for pair matching without replacement, so we do not repeat it here.</p>
</div>
<div class="section level4">
<h4 id="for-survival-outcomes-2">For survival outcomes<a class="anchor" aria-label="anchor" href="#for-survival-outcomes-2"></a>
</h4>
<p><span class="citation">Austin and Stuart (<a href="#ref-austin2015b" role="doc-biblioref">2015</a><a href="#ref-austin2015b" role="doc-biblioref">b</a>)</span> describe the use of the full matching with survival outcomes.</p>
<p><strong>Without covariate adjustment.</strong> To estimate the marginal HR, we can regress the outcome on the treatment in a Cox regression model weighted by the matching weights and including subclasses as a cluster. Below we demonstrate how to estimate the marginal HR and its standard error after full matching.</p>
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">Y_S</span><span class="op">)</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, robust <span class="op">=</span> <span class="cn">TRUE</span>, 
      weights <span class="op">=</span> <span class="va">weights</span>, cluster <span class="op">=</span> <span class="va">subclass</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## Call:</span>
<span class="co">## coxph(formula = Surv(Y_S) ~ A, data = md, weights = weights, </span>
<span class="co">##     robust = TRUE, cluster = subclass)</span>
<span class="co">## </span>
<span class="co">##   coef exp(coef) se(coef) robust se z     p</span>
<span class="co">## A 0.43      1.53     0.05      0.09 5 6e-07</span>
<span class="co">## </span>
<span class="co">## Likelihood ratio test=56  on 1 df, p=6e-14</span>
<span class="co">## n= 2000, number of events= 2000</span></code></pre>
<p>To perform the log-rank test or compute survival curves after full matching, functions designed for performing these tasks with inverse probability weights can be used with the matching weights; the <code>RISCA</code> package offers functionality for this purpose.</p>
<p>Including covariates in the model is less straightforward because the resulting HR estimate is conditional rather than marginal.</p>
</div>
</div>
<div class="section level3">
<h3 id="after-stratum-matching">After Stratum Matching<a class="anchor" aria-label="anchor" href="#after-stratum-matching"></a>
</h3>
<p>Stratum matching includes exact matching, coarsened exact matching, and propensity score subclassification. There are two natural ways to estimate marginal effects after stratum matching: the first is to estimate stratum-specific treatment effects and pool them, and the second is to use the stratum weights to estimate a single marginal effect. This latter approach is also known as marginal mean weighting through stratification (MMWS), and is described in detail by <span class="citation">Hong (<a href="#ref-hong2010" role="doc-biblioref">2010</a>)</span><a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>. When done properly, both methods should yield similar or identical estimates of the treatment effect. MMWS is generally preferable because it is far simpler to implement and avoids issues of noncollapsibility with non-continuous outcomes. All of the methods described above for use with full matching also work with MMWS because the formation of the weights is the same; the only difference is that it is not appropriate to use cluster-robust standard errors with MMWS because of how few clusters are present.</p>
<p>Unless exact matching is used, estimating stratum-specific treatment effects can be fraught because balance may not be achieved within strata even if balance is achieved across strata. Stratum-specific effects should be interpreted with caution. Stratum-specific effects are conditional effects, but conditional on stratum membership, which may not always be a useful conditioning variable.</p>
<p>For each outcome type, we focus on estimating marginal effects using MMWS and using the strata directly. Below, we perform propensity score subclassification for the ATT using 8 subclasses.</p>
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mS</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">d</span>,
              method <span class="op">=</span> <span class="st">"subclass"</span>, estimand <span class="op">=</span> <span class="st">"ATT"</span>,
              subclass <span class="op">=</span> <span class="fl">8</span><span class="op">)</span>

<span class="va">mS</span></code></pre></div>
<pre><code><span class="co">## A matchit object</span>
<span class="co">##  - method: Subclassification (8 subclasses)</span>
<span class="co">##  - distance: Propensity score</span>
<span class="co">##              - estimated with logistic regression</span>
<span class="co">##  - number of obs.: 2000 (original), 2000 (matched)</span>
<span class="co">##  - target estimand: ATT</span>
<span class="co">##  - covariates: X1, X2, X3, X4, X5, X6, X7, X8, X9</span></code></pre>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">md</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mS</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">md</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">##   A      X1      X2      X3       X4 X5      X6      X7      X8       X9      Y_C Y_B     Y_S distance weights subclass</span>
<span class="co">## 1 0  0.1725 -1.4283 -0.4103 -2.36059  1 -1.1199  0.6398 -0.4840 -0.59385  0.07104   0  278.46  0.08461  0.2458        1</span>
<span class="co">## 2 0 -1.0959  0.8463  0.2456 -0.12333  1 -2.2687 -1.4491 -0.5514 -0.31439  0.15619   0  330.63  0.01855  0.2458        1</span>
<span class="co">## 3 0  0.1768  0.7905 -0.8436  0.82366  1 -0.2221  0.2971 -0.6966 -0.69516 -0.85180   1  369.94  0.22210  1.0742        3</span>
<span class="co">## 4 0 -0.4595  0.1726  1.9542 -0.62661  1 -0.4019 -0.8294 -0.5384  0.20729 -2.35184   0   91.06  0.04180  0.2458        1</span>
<span class="co">## 5 1  0.3563 -1.8121  0.8135 -0.67189  1 -0.8297  1.7297 -0.6439 -0.02648  0.68058   0  182.73  0.43291  1.0000        5</span>
<span class="co">## 6 0 -2.4313 -1.7984 -1.2940  0.04609  1 -1.2419 -1.1252 -1.8659 -0.56513 -5.62260   0 2563.73  0.04998  0.2458        1</span></code></pre>
<div class="section level4">
<h4 id="for-continuous-outcomes-3">For continuous outcomes<a class="anchor" aria-label="anchor" href="#for-continuous-outcomes-3"></a>
</h4>
<p>For continuous outcomes, we can use either MMWS or compute the weighted average of within-subclass effects. First we illustrate weighting.</p>
<p><strong>Without covariate adjustment.</strong> With weighting, we can supply the weights that are in the <code><a href="../reference/match.data.html">match.data()</a></code> output to a call to <code><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm()</a></code> to perform weighted least squares regression, as we did with full matching. We need a robust standard error estimator to account for the weights. Note that the subclasses don’t even need to enter this analysis; they are fully incorporated through the MMWS weights<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>. We use <code><a href="https://sandwich.R-Forge.R-project.org//reference/vcovHC.html" class="external-link">vcovHC()</a></code> to estimate the regular robust standard error instead of the cluster-robust standard error used with other methods.</p>
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fit1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit1</span>, vcov. <span class="op">=</span> <span class="va">vcovHC</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## t test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">## (Intercept)    1.964      0.287    6.85  9.8e-12 ***</span>
<span class="co">## A              1.930      0.407    4.74  2.2e-06 ***</span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<p>We can also fit a model within each subclass to estimate the within-stratum treatment effects and then compute a weighted average of them to be used as the marginal effect. The stratum weights in the weighted average must be equal to the proportion of treated units in each subclass if the ATT is targeted. If the ATE is targeted, the weights must be equal to the proportion of all units in each subclass. There are other ways to construct weight to minimize variance at the expense of losing the original target population <span class="citation">(Rudolph et al. <a href="#ref-rudolph2016" role="doc-biblioref">2016</a>)</span>.</p>
<p>Instead of fitting separate models for each subclass, we can fit a single model that fully interacts the treatment with subclass membership and then perform a linear hypothesis test. To do so, we use the form <code>Y ~ S + S:A - 1</code> in the call to <code><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm()</a></code>. This includes main effects for subclass and treatment interaction terms for each subclass and omits an intercept. The fit of this model is equivalent to that of a traditional full factorial model, so no information is lost using this parameterization and using it makes it easier to construct the stratum weights. This estimates the subclass-specific intercept and subclass-specific treatment effect in each subclass. We would use a robust standard error to account for different residual variance across subclasses.</p>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fit2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">subclass</span> <span class="op">+</span> <span class="va">subclass</span><span class="op">:</span><span class="va">A</span> <span class="op">-</span> <span class="fl">1</span>, data <span class="op">=</span> <span class="va">md</span><span class="op">)</span>

<span class="co">#Within-subclass effects</span>
<span class="co"># coeftest(fit2, vcov. = vcovHC)</span></code></pre></div>
<p>The within-subclass effects should only be trusted if balance is achieved in each subclass. In this example, balance has not been achieved within some subclasses, so we would not interpret these effects. Next we construct the weights to form the weighted average of the subclass effects. The weights take the form of a linear contrast matrix with zeroes for the subclass-specific intercepts and the subclass proportions for the corresponding subclass-specific treatment effect coefficients.</p>
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Subclass weights for ATT</span>
<span class="va">sub_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/with.html" class="external-link">with</a></span><span class="op">(</span><span class="va">md</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/nlevels.html" class="external-link">nlevels</a></span><span class="op">(</span><span class="va">subclass</span><span class="op">)</span><span class="op">)</span>, 
                    <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">subclass</span><span class="op">[</span><span class="va">A</span><span class="op">==</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">A</span><span class="op">==</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>

<span class="co">#Subclass weights for ATE (requires estimand = "ATE" in matchit())</span>
<span class="co"># sub_w &lt;- with(md, c(rep(0, nlevels(subclass)), </span>
<span class="co">#                     table(subclass)/nrow(md)))</span>

<span class="co">#Marginal effect</span>
<span class="op">(</span><span class="va">est</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fit2</span><span class="op">)</span>, <span class="va">sub_w</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## [1] 1.93</span></code></pre>
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#SE of marginal effect</span>
<span class="op">(</span><span class="va">se</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/drop.html" class="external-link">drop</a></span><span class="op">(</span><span class="va">sub_w</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://sandwich.R-Forge.R-project.org//reference/vcovHC.html" class="external-link">vcovHC</a></span><span class="op">(</span><span class="va">fit2</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">sub_w</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## [1] 0.4036</span></code></pre>
<div class="sourceCode" id="cb85"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#CI</span>
<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span>ci_low <span class="op">=</span> <span class="va">est</span> <span class="op">-</span> <span class="fl">1.96</span><span class="op">*</span><span class="va">se</span>, ci_hi <span class="op">=</span> <span class="va">est</span> <span class="op">+</span> <span class="fl">1.96</span><span class="op">*</span><span class="va">se</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## ci_low  ci_hi </span>
<span class="co">##  1.139  2.721</span></code></pre>
<p>The following lines would have produced the same output but require the <code>margins</code> package:</p>
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Using margins() from margins</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="fu">margins</span><span class="fu">::</span><span class="fu">margins</span><span class="op">(</span><span class="va">fit2</span>, variables <span class="op">=</span> <span class="st">"A"</span>, 
                         data <span class="op">=</span> <span class="va">md</span><span class="op">[</span><span class="va">md</span><span class="op">$</span><span class="va">A</span> <span class="op">==</span> <span class="fl">1</span>,<span class="op">]</span>,
                         vcov <span class="op">=</span> <span class="fu"><a href="https://sandwich.R-Forge.R-project.org//reference/vcovHC.html" class="external-link">vcovHC</a></span><span class="op">(</span><span class="va">fit2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="co">#For ATE, omit the second line. </span></code></pre></div>
<p><strong>With covariate adjustment.</strong> To include covariates in the model when using MMWS, we can modify the code used for weighting after full matching, the only difference being that regular robust standard errors should be used with MMWS. As before, treatment-covariate interactions are optional but can reduce bias and improve precision when there effect modification by the covariates. When including these interactions in the outcome model, it is important to center the covariates at their means in the target population (i.e., the full sample for the ATE and the treated units for the ATT) in order to interpret the coefficient on treatment as a marginal effect.</p>
<p>To include covariates in the model when combining subclass-specific effect estimates, it can be challenging to correctly parameterize the model so that the linear contrast matrix method works as expected. The simplest way would be to include covariates as desired, which include as main effects, interactions with treatment, interactions with subclass, or all three, and use the <code>margins()</code> code above, which should automatically provide the correct output.</p>
</div>
<div class="section level4">
<h4 id="for-binary-outcomes-3">For binary outcomes<a class="anchor" aria-label="anchor" href="#for-binary-outcomes-3"></a>
</h4>
<p>Using stratification with binary outcomes is slightly more complicated than it is with continuous outcomes. This is because the OR and RR are not collapsible, so the marginal OR and RR cannot be computed as the weighted average of the stratum-specific effects. Instead, one must compute the average of the predicted stratum-specific risks under each treatment and then compute the marginal effect estimate from these marginal risks. Although stratum-specific conditional ORs are valid effect measures, they generally do not correspond to meaningful subpopulation effects unless the strata themselves are meaningful subpopulations. After exact matching or coarsened exact matching, strata may be meaningful because they correspond to specific combinations of covariates that may come close to designating specific patient attributes, but after propensity score subclassification, the strata correspond to propensity score bins, which are generally not meaningful. Although some researchers have interpreted stratum-specific effects after propensity score subclassification as representing effects at various risks or propensities for treatment, because the primary purpose of the propensity score is as a balancing score and not as an accurate estimate of propensity for treatment, such an interpretation should be regarded with caution.</p>
<p><span class="citation">Austin (<a href="#ref-austin2007a" role="doc-biblioref">2007</a>)</span> compared several methods of propensity score adjustment for estimating marginal ORs, including two methods based on propensity score stratification, one of which involved the stratified Mantel-Haenszel estimator, and the other of which involved averaging stratum-specific effects. Both of these estimate a common conditional OR, not a marginal OR <span class="citation">(Forbes and Shortreed <a href="#ref-forbes2008" role="doc-biblioref">2008</a>; Stampf et al. <a href="#ref-stampf2010" role="doc-biblioref">2010</a>)</span>, and both yielded positively biased effect estimates for non-null treatment effects, a common pattern when using conditional effect estimates as estimates of marginal effects. Given the difficulties in estimating marginal ORs after stratification, the most straightforward way to do so is to use MMWS. We do, however, also demonstrate estimating the marginal odds ratio and its standard error using bootstrapping in a way that can incorporate covariate adjustment and allow for differential effect modification across strata.</p>
<p><strong>Without covariate adjustment.</strong> As before, we can supply the stratification weights to a weighted generalized linear model with just the treatment as the sole predictor, and the coefficient on treatment will correspond to a marginal treatment effect. We use <code><a href="https://sandwich.R-Forge.R-project.org//reference/vcovHC.html" class="external-link">vcovHC()</a></code> to estimate the regular robust standard error.</p>
<div class="sourceCode" id="cb88"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fit3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">Y_B</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, weights <span class="op">=</span> <span class="va">weights</span>,
            family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">quasibinomial</a></span><span class="op">(</span>link <span class="op">=</span> <span class="st">"logit"</span><span class="op">)</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fit3</span>, vcov. <span class="op">=</span> <span class="va">vcovHC</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## z test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error z value Pr(&gt;|z|)    </span>
<span class="co">## (Intercept)   -0.831      0.108   -7.71  1.3e-14 ***</span>
<span class="co">## A              0.726      0.144    5.04  4.6e-07 ***</span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<div class="sourceCode" id="cb90"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fit3</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## (Intercept)           A </span>
<span class="co">##      0.4357      2.0675</span></code></pre>
<p>As with other matching methods, we include weights in the call to <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code> and set <code>family = quasibinomial()</code> to prevent a warning that occurs when using weights with binomial regression models (though the results do not differ). Setting <code>link = "logit"</code> provides the marginal OR; for the marginal RR, we would replace <code>"logit"</code> with <code>"log"</code>, and for the marginal RD, we would replace <code>"logit"</code> with <code>"identity"</code> and not exponentiate the coefficient.</p>
<p><strong>With covariate adjustment and bootstrapping.</strong> We can use bootstrapping to estimate the marginal OR and its standard error by estimating the average of the stratum-specific risks under each treatment level, computing the marginal risks under each treatment, and computing marginal effects from the marginal risks. This also makes it fairly straightforward to include covariates in the model. Below we illustrate bootstrapping for the marginal OR with covariates included in the outcome model.</p>
<div class="sourceCode" id="cb92"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Bootstrap confidence intervals</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">boot</span><span class="op">)</span>

<span class="va">est_fun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">i</span><span class="op">)</span> <span class="op">{</span>
  <span class="co">#Subclassification function</span>
  <span class="va">mS_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                       <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span>,
                     method <span class="op">=</span> <span class="st">"subclass"</span>, estimand <span class="op">=</span> <span class="st">"ATT"</span>,
                     subclass <span class="op">=</span> <span class="fl">8</span><span class="op">)</span>
  <span class="va">md_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mS_boot</span><span class="op">)</span>
  
  <span class="co">#Fitting the model</span>
  <span class="va">fit_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">Y_B</span> <span class="op">~</span> <span class="va">A</span> <span class="op">*</span> <span class="op">(</span><span class="va">subclass</span> <span class="op">+</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                    <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">md_boot</span>,
                  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">quasibinomial</a></span><span class="op">(</span>link <span class="op">=</span> <span class="st">"logit"</span><span class="op">)</span><span class="op">)</span>
  
  <span class="co">#Estimate potential outcomes for each unit</span>
  
  <span class="co">## Subset to just the treated for the ATT; remove this for the ATE</span>
  <span class="va">md_boot</span> <span class="op">&lt;-</span> <span class="va">md_boot</span><span class="op">[</span><span class="va">md_boot</span><span class="op">$</span><span class="va">A</span> <span class="op">==</span> <span class="fl">1</span>,<span class="op">]</span>
  <span class="co">##</span>
  
  <span class="va">md_boot</span><span class="op">$</span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fl">0</span>
  <span class="va">P0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit_boot</span>, <span class="va">md_boot</span>, type <span class="op">=</span> <span class="st">"response"</span><span class="op">)</span><span class="op">)</span>
  <span class="va">Odds0</span> <span class="op">&lt;-</span> <span class="va">P0</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">P0</span><span class="op">)</span>
  
  <span class="va">md_boot</span><span class="op">$</span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fl">1</span>
  <span class="va">P1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit_boot</span>, <span class="va">md_boot</span>, type <span class="op">=</span> <span class="st">"response"</span><span class="op">)</span><span class="op">)</span>
  <span class="va">Odds1</span> <span class="op">&lt;-</span> <span class="va">P1</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">P1</span><span class="op">)</span>

  <span class="co">#Return marginal odds ratio</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">Odds1</span> <span class="op">/</span> <span class="va">Odds0</span><span class="op">)</span>
<span class="op">}</span>

<span class="va">boot_est</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot</a></span><span class="op">(</span><span class="va">d</span>, <span class="va">est_fun</span>, R <span class="op">=</span> <span class="fl">4999</span><span class="op">)</span>
<span class="va">boot_est</span>
<span class="fu"><a href="https://rdrr.io/pkg/boot/man/boot.ci.html" class="external-link">boot.ci</a></span><span class="op">(</span><span class="va">boot_est</span>, type <span class="op">=</span> <span class="st">"bca"</span><span class="op">)</span></code></pre></div>
<p>In this example, we included interactions between treatment and subclass and between treatment and each covariate. Note that because we are interested in the ATT, we restricted the sample used to compute the predicted marginal risks (<code>P0</code>) and (<code>P1</code>) to just those with <code>A = 1</code>. If we were instead estimating the ATE, we would supply <code>"ATE"</code> that to the <code>estimand</code> argument in the call to <code><a href="../reference/matchit.html">matchit()</a></code> and skip the step of restricting the data used for prediction of the marginal risks.</p>
<p>As with other methods, to estimate the marginal RR or RD using the above code, the returned object can instead be specified as <code>P1 / P0</code> or <code>P1 - P0</code>, respectively.</p>
</div>
<div class="section level4">
<h4 id="for-survival-outcomes-3">For survival outcomes<a class="anchor" aria-label="anchor" href="#for-survival-outcomes-3"></a>
</h4>
<p>Like ORs, HRs are not collapsible, so it is not straightforward to estimate marginal HRs using within-stratum HRs. <span class="citation">Austin (<a href="#ref-austin2013" role="doc-biblioref">2013</a><a href="#ref-austin2013" role="doc-biblioref">a</a>)</span> examined the performance of several propensity score subclassification-based estimators of the marginal HR and found all to be positively biased for non-null effects, consistent with the use of conditional effect estimates as estimates of marginal effects; indeed, the subclassification methods examined all relied on pooling stratum-specific effects. Given these difficulties, the most straightforward method to estimate marginal HRs is to use MMWS weights. We demonstrate this below using essentially the same syntax as used with full matching, only omitting subclass membership as a clustering variable.</p>
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">Y_S</span><span class="op">)</span> <span class="op">~</span> <span class="va">A</span>, data <span class="op">=</span> <span class="va">md</span>, robust <span class="op">=</span> <span class="cn">TRUE</span>, 
      weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## Call:</span>
<span class="co">## coxph(formula = Surv(Y_S) ~ A, data = md, weights = weights, </span>
<span class="co">##     robust = TRUE)</span>
<span class="co">## </span>
<span class="co">##   coef exp(coef) se(coef) robust se z     p</span>
<span class="co">## A 0.46      1.58     0.05      0.07 7 2e-11</span>
<span class="co">## </span>
<span class="co">## Likelihood ratio test=64  on 1 df, p=1e-15</span>
<span class="co">## n= 2000, number of events= 2000</span></code></pre>
<p>The robust standard error must be used because of the MMWS weights.</p>
</div>
</div>
<div class="section level3">
<h3 id="estimating-conditional-effects">Estimating Conditional Effects<a class="anchor" aria-label="anchor" href="#estimating-conditional-effects"></a>
</h3>
<p>As discussed previously, with binary and time-to-event outcomes, marginal and conditional effects generally differ. Though we have primarily focused on marginal effects, we offer some guidance here on estimating conditional effect as well. Estimating conditional effects typically involves modeling the outcome, and inferences are dependent on this model being correct, even in the presence is perfect covariate balance. Matching provides robustness to some forms of misspecification, however, by limiting the range of the covariate space. So, even though outcome modeling is required, matching prior to modeling the outcome can be beneficial in terms of reducing bias due to model misspecification.</p>
<p>On some effect measures, conditional effects typically vary depending on the covariate values at which the conditional effect is to be estimated; for example, the decrease in the risk of death (i.e., on the RD scale) corresponding to receipt of a treatment for a patient with a high baseline risk of death will by higher than that for a patient with a low baseline risk of death. In this sense, there is necessarily effect modification of the RD by baseline risk (which depends on a patient’s covariate values). Similarly, for an exposure that increases the risk by a factor (e.g., doubles the risk, for a RR of 2), a patient with a high baseline risk cannot experience the same change in risk as a patient with a low baseline risk could; for example, a RR of 2 is impossible for a patient with a baseline risk of .6 but is certainly plausible for a patient with a baseline risk of .02. In this sense, there is necessarily effect modification of the RR by baseline risk. This is not true for the OR; it is plausible that the effect on the OR scale could be consistent across levels of levels of the predictors because any OR is compatible with any possible baselines risk. For this reason, we only consider estimating the conditional OR and not other effect measures.</p>
<p>Although several methods exist for estimating conditional ORs after matching or subclassification, the one that generally works well is to run a logistic regression of the outcome on the treatment and covariates and use the coefficient on treatment as an estimate of the effect on the log OR scale. We demonstrate this below using 1:1 nearest neighbor propensity score matching for the ATT:</p>
<div class="sourceCode" id="cb95"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mF</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">d</span>,
              method <span class="op">=</span> <span class="st">"nearest"</span><span class="op">)</span>

<span class="va">md</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mF</span><span class="op">)</span>

<span class="va">fitcond</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">Y_B</span> <span class="op">~</span> <span class="va">A</span> <span class="op">+</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">md</span>, 
             weights <span class="op">=</span> <span class="va">weights</span>, family <span class="op">=</span> <span class="va">binomial</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fitcond</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span><span class="op">)</span><span class="op">[</span><span class="st">"A"</span>,,drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span></code></pre></div>
<pre><code><span class="co">##   Estimate Std. Error z value  Pr(&gt;|z|)</span>
<span class="co">## A    1.072     0.1653   6.482 9.055e-11</span></code></pre>
<div class="sourceCode" id="cb97"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fitcond</span><span class="op">)</span><span class="op">[</span><span class="st">"A"</span><span class="op">]</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">##    A </span>
<span class="co">## 2.92</span></code></pre>
<p>As with other covariate-adjusted models, it is important not to interpret the coefficients on covariates other than treatment to avoid committing the table 2 fallacy. Other causes of the outcome can be included in the outcome model even if they were not the focus of matching as long as they are not (even possibly) caused by the treatment.</p>
<p>Alternative methods of estimating conditional effects include conditional logistic regression after matching and estimating stratum-specific effects after subclassification. We recommend using covariate-adjusted logistic regression models instead because the conditional effect is better defined (i.e., conditional on the specific covariates included in the model) and depends less on the estimand targeted <span class="citation">(Forbes and Shortreed <a href="#ref-forbes2008" role="doc-biblioref">2008</a>)</span>.</p>
</div>
<div class="section level3">
<h3 id="moderation-analysis">Moderation Analysis<a class="anchor" aria-label="anchor" href="#moderation-analysis"></a>
</h3>
<p>Moderation analysis involves determining whether a treatment effect differs across levels of another variable. The use of matching with moderation analysis is described in <span class="citation">Green and Stuart (<a href="#ref-greenExaminingModerationAnalyses2014" role="doc-biblioref">2014</a>)</span>. The goal is to achieve balance within each subgroup of the potential moderating variable, and there are several ways of doing so. Broadly, one can either perform matching in the full dataset, perhaps requiring exact matching on the moderator, or one can perform completely separate analyses in each subgroup. We’ll demonstrate both approaches below. The chosen approach should be that which achieves the best balance, though we don’t demonstrate assessing balance here to maintain focus on effect estimation. We’ll consider the binary variable <code>X5</code> to be the potential moderator of the effect of <code>A</code> on <code>Y_C</code>.</p>
<p>The first approach involves pooling information across subgroups. This could involve estimating propensity scores using a single model for both groups but exact matching on the potential moderator. The propensity score model could include moderator-by-covariate interactions to allow the propensity score model to vary across subgroups on some covariates. Below, we’ll estimate a propensity score using a single propensity score model with a few moderator-by-covariate interactions and exact matching on the moderator, <code>X5</code>. We’ll perform nearest neighbor matching on the propensity score.</p>
<div class="sourceCode" id="cb99"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mP</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X5</span><span class="op">*</span><span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> 
                <span class="va">X5</span><span class="op">*</span><span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X5</span><span class="op">*</span><span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">d</span>,
              exact <span class="op">=</span> <span class="op">~</span><span class="va">X5</span>, method <span class="op">=</span> <span class="st">"nearest"</span><span class="op">)</span>
<span class="va">mP</span></code></pre></div>
<pre><code><span class="co">## A matchit object</span>
<span class="co">##  - method: 1:1 nearest neighbor matching without replacement</span>
<span class="co">##  - distance: Propensity score</span>
<span class="co">##              - estimated with logistic regression</span>
<span class="co">##  - number of obs.: 2000 (original), 882 (matched)</span>
<span class="co">##  - target estimand: ATT</span>
<span class="co">##  - covariates: X1, X2, X5, X3, X4, X6, X7, X8, X9</span></code></pre>
<p>Although it is straightforward to assess balance overall using <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>, it is more challenging to assess balance within subgroups. The easiest way to check subgroup balance would be to use <code><a href="https://ngreifer.github.io/cobalt/reference/bal.tab.html" class="external-link">cobalt::bal.tab()</a></code>, which has a <code>cluster</code> argument that can be used to assess balance within subgroups, e.g., by <code>cobalt::bal.tab(mP, cluster = "X5")</code>. See the vignette “Appendix 2: Using cobalt with Clustered, Multiply Imputed, and Other Segmented Data” on the <code>cobalt</code> <a href="https://ngreifer.github.io/cobalt/index.html" class="external-link">website</a> for details.</p>
<p>If we are satisfied with balance, we can then estimate the subgroup effects using an outcome model with an interaction between the treatment and the moderator.</p>
<div class="sourceCode" id="cb101"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mdP</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mP</span><span class="op">)</span>

<span class="va">fitP</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span> <span class="op">*</span> <span class="va">X5</span>, data <span class="op">=</span> <span class="va">mdP</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fitP</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## t test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)   </span>
<span class="co">## (Intercept)   0.7500     0.4515    1.66   0.0970 . </span>
<span class="co">## A             2.2073     0.6703    3.29   0.0010 **</span>
<span class="co">## X5            1.7413     0.6070    2.87   0.0042 **</span>
<span class="co">## A:X5         -0.0275     0.8791   -0.03   0.9751   </span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<p>A second approach is to perform the matching analyses separately and then combine the matched samples. We demonstrate this below. First, we split the data by levels of <code>X5</code>.</p>
<div class="sourceCode" id="cb103"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">d_X5_0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/subset.html" class="external-link">subset</a></span><span class="op">(</span><span class="va">d</span>, <span class="va">X5</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">d_X5_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/subset.html" class="external-link">subset</a></span><span class="op">(</span><span class="va">d</span>, <span class="va">X5</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p>Next we perform separate matching analyses in each new dataset,</p>
<div class="sourceCode" id="cb104"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mS0</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">d_X5_0</span>,
               method <span class="op">=</span> <span class="st">"nearest"</span><span class="op">)</span>

<span class="va">mS1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matchit.html">matchit</a></span><span class="op">(</span><span class="va">A</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> 
                 <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span>, data <span class="op">=</span> <span class="va">d_X5_1</span>,
               method <span class="op">=</span> <span class="st">"nearest"</span><span class="op">)</span></code></pre></div>
<p>It is straightforward to assess balance within each subgroup using <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>, and <code>cobalt</code> functions can be used as well. We omit this step here, but you should not!</p>
<p>To estimate the subgroup effects, we need to combine the matched datasets, which we can do using <code><a href="../reference/rbind.matchdata.html">rbind.matchdata()</a></code> (a special <code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind()</a></code> method for <code>matchdata</code> objects). Then we estimate the moderation effect just as we did previously.</p>
<div class="sourceCode" id="cb105"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mdS0</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mS0</span><span class="op">)</span>
<span class="va">mdS1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match.data.html">match.data</a></span><span class="op">(</span><span class="va">mS1</span><span class="op">)</span>

<span class="va">mdS</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">mdS0</span>, <span class="va">mdS1</span><span class="op">)</span>

<span class="va">fitS</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">Y_C</span> <span class="op">~</span> <span class="va">A</span> <span class="op">*</span> <span class="va">X5</span>, data <span class="op">=</span> <span class="va">mdS</span>, weights <span class="op">=</span> <span class="va">weights</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/pkg/lmtest/man/coeftest.html" class="external-link">coeftest</a></span><span class="op">(</span><span class="va">fitS</span>, vcov. <span class="op">=</span> <span class="va">vcovCL</span>, cluster <span class="op">=</span> <span class="op">~</span><span class="va">subclass</span><span class="op">)</span></code></pre></div>
<pre><code><span class="co">## </span>
<span class="co">## t test of coefficients:</span>
<span class="co">## </span>
<span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">## (Intercept)    0.720      0.421    1.71  0.08766 .  </span>
<span class="co">## A              2.237      0.641    3.49  0.00051 ***</span>
<span class="co">## X5             2.160      0.576    3.75  0.00019 ***</span>
<span class="co">## A:X5          -0.446      0.842   -0.53  0.59670    </span>
<span class="co">## ---</span>
<span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></code></pre>
<p>There are benefits to using either approach, and <span class="citation">Green and Stuart (<a href="#ref-greenExaminingModerationAnalyses2014" role="doc-biblioref">2014</a>)</span> find that either can be successful at balancing the subgroups. The first approach may be most effective with small samples, where separate propensity score models would be fit with greater uncertainty and an increased possibility of perfect prediction or failure to converge <span class="citation">(Wang et al. <a href="#ref-wangRelativePerformancePropensity2018" role="doc-biblioref">2018</a>)</span>. The second approach may be more effective with larger samples or with matching methods that target balance in the matched sample, such as genetic matching <span class="citation">(Kreif et al. <a href="#ref-kreifMethodsEstimatingSubgroup2012" role="doc-biblioref">2012</a>)</span>. With genetic matching, separate subgroup analyses ensure balance is optimized within each subgroup rather than just overall.</p>
</div>
<div class="section level3">
<h3 id="reporting-results">Reporting Results<a class="anchor" aria-label="anchor" href="#reporting-results"></a>
</h3>
<p>It is important to be as thorough and complete as possible when describing the methods of estimating the treatment effect and the results of the analysis. This improves transparency and replicability of the analysis. Results should at least include the following:</p>
<ul>
<li>a description of the outcome model used (e.g., logistic regression, a linear model with treatment-covariate interactions and mean-centered covariates, a Cox proportional hazards model with the matching weights applied)</li>
<li>the way the effect was estimated (e.g., as the coefficient on treatment in the outcome model, as the result of a marginal effects procedure)</li>
<li>the way standard errors and confidence intervals were estimated (e.g., using robust standard errors, using cluster-robust standard errors with pair membership as the cluster, using the BCa bootstrap with 4999 bootstrap replications and the entire process of matching and effect estimation included in each replication)</li>
<li>R packages and functions used in estimating the effect and its standard error (e.g., <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code> in base R, <code><a href="https://sandwich.R-Forge.R-project.org//reference/vcovCL.html" class="external-link">vcovCL()</a></code> in <code>sandwich</code>, <code><a href="https://rdrr.io/pkg/boot/man/boot.html" class="external-link">boot()</a></code> and <code><a href="https://rdrr.io/pkg/boot/man/boot.ci.html" class="external-link">boot.ci()</a></code> in <code>boot</code>)</li>
<li>The effect and its standard error and confidence interval</li>
</ul>
<p>All this is in addition to information about the matching method, propensity score estimation procedure (if used), balance assessment, etc. mentioned in the other vignettes.</p>
</div>
</div>
<div class="section level2">
<h2 id="common-mistakes">Common Mistakes<a class="anchor" aria-label="anchor" href="#common-mistakes"></a>
</h2>
<p>There are a few common mistakes that should be avoided. It is important not only to avoid these mistakes in one’s own research but also to be able to spot these mistakes in others’ analyses.</p>
<div class="section level3">
<h3 id="failing-to-include-weights">1. Failing to include weights<a class="anchor" aria-label="anchor" href="#failing-to-include-weights"></a>
</h3>
<p>Several methods involve weights that are to be used in estimating the treatment effect. With full matching and stratification matching (when analyzed using MMWS), the weights do the entire work of balancing the covariates across the treatment groups. Omitting weights essentially ignores the entire purpose of matching. Some cases are less obvious. When performing matching with replacement and estimating the treatment effect using the <code><a href="../reference/match.data.html">match.data()</a></code> output, weights must be included to ensure control units matched to multiple treated units are weighted accordingly. Similarly, when performing k:1 matching where not all treated units receive k matches, weights are required to account for the differential weight of the matched control units. The only time weights can be omitted after pair matching is when performing 1:1 matching without replacement. Including weights even in this scenario will not affect the analysis and it can be good practice to always include weights to prevent this error from occurring. There are some scenarios where weights are not useful because the conditioning occurs through some other means, such as when using the pooling strategy rather than MMWS for estimating marginal effects after stratification.</p>
</div>
<div class="section level3">
<h3 id="failing-to-use-robust-or-cluster-robust-standard-errors">2. Failing to use robust or cluster-robust standard errors<a class="anchor" aria-label="anchor" href="#failing-to-use-robust-or-cluster-robust-standard-errors"></a>
</h3>
<p>Robust standard errors are required when using weights to estimate the treatment effect. The model-based standard errors resulting from weighted least squares or maximum likelihood are inaccurate when using matching weights because they assume weights are frequency weights rather than probability weights. Cluster-robust standard errors account for both the matching weights and pair membership and should be used when appropriate (i.e., with all matching methods other than stratification matching). Sometimes, researchers use functions in the <code>survey</code> package to estimate robust standard errors, especially with inverse probability weighting; this is a valid way to compute robust standard errors and will give similar results to <code><a href="https://sandwich.R-Forge.R-project.org//reference/vcovHC.html" class="external-link">sandwich::vcovHC()</a></code>.</p>
</div>
<div class="section level3">
<h3 id="interpreting-conditional-effects-as-marginal-effects">3. Interpreting conditional effects as marginal effects<a class="anchor" aria-label="anchor" href="#interpreting-conditional-effects-as-marginal-effects"></a>
</h3>
<p>The distinction between marginal and conditional effects is not always clear both in methodological and applied papers. Some statistical methods are valid only for estimating conditional effects and they should not be used to estimate marginal effects (without further modification). Sometimes conditional effects are desirable, and such methods may be useful for them, but when marginal effects are the target of inference, it is critical not to inappropriately interpret estimates resulting from statistical methods aimed at estimating conditional effects as marginal effects. Although this issue is particularly salient with binary and survival outcomes due to the general noncollapsibility of the OR, RR, and HR, this can also occur with linear models for continuous outcomes or the RD.</p>
<p>The following methods estimate <strong>conditional effects</strong> for binary or survival outcomes (with noncollapsible effect measures) and should <strong>not</strong> be used to estimate marginal effects:</p>
<ul>
<li>Logistic regression or Cox proportional hazards model with covariates and/or the propensity score included, using the coefficient on treatment as the effect estimate</li>
<li>Conditional logistic regression after matching</li>
<li>Stratified Cox regression after matching</li>
<li>Averaging stratum-specific effect estimates after stratification, including using Mantel-Haenszel OR pooling</li>
<li>Including pair or stratum fixed or random effects in a logistic regression model, using the coefficient on treatment as the effect estimate</li>
</ul>
<p>In addition, with continuous outcomes, conditional effects can be mistakenly interpreted as marginal effect estimates when treatment-covariate interactions are present in the outcome model. If the covariates are not centered at their mean in the target population (e.g., the treated group for the ATT, the full sample for the ATE, or the remaining matched sample for an ATM), the coefficient on treatment will not correspond to the marginal effect in the target population; it will correspond to the effect of treatment when the covariate values are equal to zero, which may not be meaningful or plausible. Marginal effects procedures (e.g., using the <code>margins</code> package or manually with bootstrapping as demonstrated above) are always the safest way to include covariates in the outcome model, especially in the presence of treatment-covariate interactions. Appropriately centering the covariates is a shortcut that is required when using the coefficient on treatment as a marginal effect estimate for continuous outcomes (demonstrated previously for full matching).</p>
</div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs">
<div id="ref-abadie2008">
<p>Abadie, Alberto, and Guido W. Imbens. 2008. “On the Failure of the Bootstrap for Matching Estimators.” <em>Econometrica</em> 76 (6): 1537–57. <a href="https://www.jstor.org/stable/40056514" class="external-link">https://www.jstor.org/stable/40056514</a>.</p>
</div>
<div id="ref-abadie2019">
<p>Abadie, Alberto, and Jann Spiess. 2019. “Robust Post-Matching Inference,” January, 34.</p>
</div>
<div id="ref-austin2007a">
<p>Austin, Peter C. 2007. “The Performance of Different Propensity Score Methods for Estimating Marginal Odds Ratios.” <em>Statistics in Medicine</em> 26 (16): 3078–94. <a href="https://doi.org/10.1002/sim.2781" class="external-link">https://doi.org/10.1002/sim.2781</a>.</p>
</div>
<div id="ref-austin2009a">
<p>———. 2009. “Type I Error Rates, Coverage of Confidence Intervals, and Variance Estimation in Propensity-Score Matched Analyses.” <em>The International Journal of Biostatistics</em> 5 (1). <a href="https://doi.org/10.2202/1557-4679.1146" class="external-link">https://doi.org/10.2202/1557-4679.1146</a>.</p>
</div>
<div id="ref-austin2013">
<p>———. 2013a. “The Performance of Different Propensity Score Methods for Estimating Marginal Hazard Ratios.” <em>Statistics in Medicine</em> 32 (16): 2837–49. <a href="https://doi.org/10.1002/sim.5705" class="external-link">https://doi.org/10.1002/sim.5705</a>.</p>
</div>
<div id="ref-austin2013a">
<p>———. 2013b. “The Use of Propensity Score Methods with Survival or Time-to-Event Outcomes: Reporting Measures of Effect Similar to Those Used in Randomized Experiments.” <em>Statistics in Medicine</em> 33 (7): 1242–58. <a href="https://doi.org/10.1002/sim.5984" class="external-link">https://doi.org/10.1002/sim.5984</a>.</p>
</div>
<div id="ref-austin2020a">
<p>Austin, Peter C., and Guy Cafri. 2020. “Variance Estimation When Using Propensity-Score Matching with Replacement with Survival or Time-to-Event Outcomes.” <em>Statistics in Medicine</em> 39 (11): 1623–40. <a href="https://doi.org/10.1002/sim.8502" class="external-link">https://doi.org/10.1002/sim.8502</a>.</p>
</div>
<div id="ref-austin2014">
<p>Austin, Peter C., and Dylan S. Small. 2014. “The Use of Bootstrapping When Using Propensity-Score Matching Without Replacement: A Simulation Study.” <em>Statistics in Medicine</em> 33 (24): 4306–19. <a href="https://doi.org/10.1002/sim.6276" class="external-link">https://doi.org/10.1002/sim.6276</a>.</p>
</div>
<div id="ref-austin2017">
<p>Austin, Peter C., and Elizabeth A. Stuart. 2017. “Estimating the Effect of Treatment on Binary Outcomes Using Full Matching on the Propensity Score.” <em>Statistical Methods in Medical Research</em> 26 (6): 2505–25. <a href="https://doi.org/10.1177/0962280215601134" class="external-link">https://doi.org/10.1177/0962280215601134</a>.</p>
</div>
<div id="ref-austin2015a">
<p>———. 2015a. “The Performance of Inverse Probability of Treatment Weighting and Full Matching on the Propensity Score in the Presence of Model Misspecification When Estimating the Effect of Treatment on Survival Outcomes.” <em>Statistical Methods in Medical Research</em> 26 (4): 1654–70. <a href="https://doi.org/10.1177/0962280215584401" class="external-link">https://doi.org/10.1177/0962280215584401</a>.</p>
</div>
<div id="ref-austin2015b">
<p>———. 2015b. “Optimal Full Matching for Survival Outcomes: A Method That Merits More Widespread Use.” <em>Statistics in Medicine</em> 34 (30): 3949–67. <a href="https://doi.org/10.1002/sim.6602" class="external-link">https://doi.org/10.1002/sim.6602</a>.</p>
</div>
<div id="ref-austin2020">
<p>Austin, Peter C., Neal Thomas, and Donald B. Rubin. 2020. “Covariate-Adjusted Survival Analyses in Propensity-Score Matched Samples: Imputing Potential Time-to-Event Outcomes.” <em>Statistical Methods in Medical Research</em> 29 (3): 728–51. <a href="https://doi.org/10.1177/0962280218817926" class="external-link">https://doi.org/10.1177/0962280218817926</a>.</p>
</div>
<div id="ref-bodory2020">
<p>Bodory, Hugo, Lorenzo Camponovo, Martin Huber, and Michael Lechner. 2020. “The Finite Sample Performance of Inference Methods for Propensity Score Matching and Weighting Estimators.” <em>Journal of Business &amp; Economic Statistics</em> 38 (1): 183–200. <a href="https://doi.org/10.1080/07350015.2018.1476247" class="external-link">https://doi.org/10.1080/07350015.2018.1476247</a>.</p>
</div>
<div id="ref-cameron2015">
<p>Cameron, A. Colin, and Douglas L. Miller. 2015. “A Practitioner’s Guide to Cluster-Robust Inference.” <em>Journal of Human Resources</em> 50 (2): 317–72. <a href="https://doi.org/10.3368/jhr.50.2.317" class="external-link">https://doi.org/10.3368/jhr.50.2.317</a>.</p>
</div>
<div id="ref-carpenter2000">
<p>Carpenter, James, and John Bithell. 2000. “Bootstrap Confidence Intervals: When, Which, What? A Practical Guide for Medical Statisticians.” <em>Statistics in Medicine</em> 19 (9): 1141–64. <a href="https://doi.org/10.1002/(SICI)1097-0258(20000515)19:9%3C1141::AID-SIM479%3E3.0.CO;2-F" class="external-link">https://doi.org/10.1002/(SICI)1097-0258(20000515)19:9&lt;1141::AID-SIM479&gt;3.0.CO;2-F</a>.</p>
</div>
<div id="ref-efron1993">
<p>Efron, Bradley, and Robert J. Tibshirani. 1993. <em>An Introduction to the Bootstrap</em>. Springer US.</p>
</div>
<div id="ref-forbes2008">
<p>Forbes, Andrew, and Susan Shortreed. 2008. “Inverse Probability Weighted Estimation of the Marginal Odds Ratio: Correspondence Regarding ‘the Performance of Different Propensity Score Methods for Estimating Marginal Odds Ratios’ by P. Austin, Statictics in Medicine, 2007; 26:30783094.” <em>Statistics in Medicine</em> 27 (26): 5556–9. <a href="https://doi.org/10.1002/sim.3362" class="external-link">https://doi.org/10.1002/sim.3362</a>.</p>
</div>
<div id="ref-gayat2012">
<p>Gayat, Etienne, Matthieu Resche-Rigon, Jean-Yves Mary, and Raphaël Porcher. 2012. “Propensity Score Applied to Survival Data Analysis Through Proportional Hazards Models: A Monte Carlo Study.” <em>Pharmaceutical Statistics</em> 11 (3): 222–29. <a href="https://doi.org/10.1002/pst.537" class="external-link">https://doi.org/10.1002/pst.537</a>.</p>
</div>
<div id="ref-greenExaminingModerationAnalyses2014">
<p>Green, Kerry M., and Elizabeth A. Stuart. 2014. “Examining Moderation Analyses in Propensity Score Methods: Application to Depression and Substance Use.” <em>Journal of Consulting and Clinical Psychology</em>, Advances in Data Analytic Methods, 82 (5): 773–83. <a href="https://doi.org/10.1037/a0036515" class="external-link">https://doi.org/10.1037/a0036515</a>.</p>
</div>
<div id="ref-greiferChoosingEstimandWhen2021">
<p>Greifer, Noah, and Elizabeth A. Stuart. 2021. “Choosing the Estimand When Matching or Weighting in Observational Studies.” <em>arXiv:2106.10577 [Stat]</em>, June. <a href="https://arxiv.org/abs/2106.10577" class="external-link">https://arxiv.org/abs/2106.10577</a>.</p>
</div>
<div id="ref-hill2006">
<p>Hill, Jennifer, and Jerome P. Reiter. 2006. “Interval Estimation for Treatment Effects Using Propensity Score Matching.” <em>Statistics in Medicine</em> 25 (13): 2230–56. <a href="https://doi.org/10.1002/sim.2277" class="external-link">https://doi.org/10.1002/sim.2277</a>.</p>
</div>
<div id="ref-ho2007">
<p>Ho, Daniel E., Kosuke Imai, Gary King, and Elizabeth A. Stuart. 2007. “Matching as Nonparametric Preprocessing for Reducing Model Dependence in Parametric Causal Inference.” <em>Political Analysis</em> 15 (3): 199–236. <a href="https://doi.org/10.1093/pan/mpl013" class="external-link">https://doi.org/10.1093/pan/mpl013</a>.</p>
</div>
<div id="ref-hong2010">
<p>Hong, Guanglei. 2010. “Marginal Mean Weighting Through Stratification: Adjustment for Selection Bias in Multilevel Data.” <em>Journal of Educational and Behavioral Statistics</em> 35 (5): 499–531. <a href="https://doi.org/10.3102/1076998609359785" class="external-link">https://doi.org/10.3102/1076998609359785</a>.</p>
</div>
<div id="ref-king2015">
<p>King, Gary, and Margaret E. Roberts. 2015. “How Robust Standard Errors Expose Methodological Problems They Do Not Fix, and What to Do About It.” <em>Political Analysis</em> 23 (2): 159–79. <a href="https://doi.org/10.1093/pan/mpu015" class="external-link">https://doi.org/10.1093/pan/mpu015</a>.</p>
</div>
<div id="ref-kreifMethodsEstimatingSubgroup2012">
<p>Kreif, Noemi, Richard Grieve, Rosalba Radice, Zia Sadique, Roland Ramsahai, and Jasjeet S. Sekhon. 2012. “Methods for Estimating Subgroup Effects in Cost-Effectiveness Analyses That Use Observational Data.” <em>Medical Decision Making</em> 32 (6): 750–63. <a href="https://doi.org/10.1177/0272989X12448929" class="external-link">https://doi.org/10.1177/0272989X12448929</a>.</p>
</div>
<div id="ref-liang1986">
<p>Liang, Kung-Yee, and Scott L. Zeger. 1986. “Longitudinal Data Analysis Using Generalized Linear Models.” <em>Biometrika</em> 73 (1): 13–22. <a href="https://doi.org/10.1093/biomet/73.1.13" class="external-link">https://doi.org/10.1093/biomet/73.1.13</a>.</p>
</div>
<div id="ref-mackinnon2006">
<p>MacKinnon, James G. 2006. “Bootstrap Methods in Econometrics*.” <em>Economic Record</em> 82 (s1): S2–S18. <a href="https://doi.org/10.1111/j.1475-4932.2006.00328.x" class="external-link">https://doi.org/10.1111/j.1475-4932.2006.00328.x</a>.</p>
</div>
<div id="ref-mackinnon1985">
<p>MacKinnon, James G., and Halbert White. 1985. “Some Heteroskedasticity-Consistent Covariance Matrix Estimators with Improved Finite Sample Properties.” <em>Journal of Econometrics</em> 29 (3): 305–25. <a href="https://doi.org/10.1016/0304-4076(85)90158-7" class="external-link">https://doi.org/10.1016/0304-4076(85)90158-7</a>.</p>
</div>
<div id="ref-nguyen2017">
<p>Nguyen, Tri-Long, Gary S. Collins, Jessica Spence, Jean-Pierre Daurès, P. J. Devereaux, Paul Landais, and Yannick Le Manach. 2017. “Double-Adjustment in Propensity Score Matching Analysis: Choosing a Threshold for Considering Residual Imbalance.” <em>BMC Medical Research Methodology</em> 17: 78. <a href="https://doi.org/10.1186/s12874-017-0338-0" class="external-link">https://doi.org/10.1186/s12874-017-0338-0</a>.</p>
</div>
<div id="ref-rudolph2016">
<p>Rudolph, Kara E., K. Ellicott Colson, Elizabeth A. Stuart, and Jennifer Ahern. 2016. “Optimally Combining Propensity Score Subclasses.” <em>Statistics in Medicine</em> 35 (27): 4937–47. <a href="https://doi.org/10.1002/sim.7046" class="external-link">https://doi.org/10.1002/sim.7046</a>.</p>
</div>
<div id="ref-schafer2008">
<p>Schafer, Joseph L., and Joseph Kang. 2008. “Average Causal Effects from Nonrandomized Studies: A Practical Guide and Simulated Example.” <em>Psychological Methods</em> 13 (4): 279–313. <a href="https://doi.org/10.1037/a0014268" class="external-link">https://doi.org/10.1037/a0014268</a>.</p>
</div>
<div id="ref-snowden2011">
<p>Snowden, Jonathan M., Sherri Rose, and Kathleen M. Mortimer. 2011. “Implementation of G-Computation on a Simulated Data Set: Demonstration of a Causal Inference Technique.” <em>American Journal of Epidemiology</em> 173 (7): 731–38. <a href="https://doi.org/10.1093/aje/kwq472" class="external-link">https://doi.org/10.1093/aje/kwq472</a>.</p>
</div>
<div id="ref-stampf2010">
<p>Stampf, Susanne, Erika Graf, Claudia Schmoor, and Martin Schumacher. 2010. “Estimators and Confidence Intervals for the Marginal Odds Ratio Using Logistic Regression and Propensity Score Stratification.” <em>Statistics in Medicine</em> 29 (7-8): 760–69. <a href="https://doi.org/10.1002/sim.3811" class="external-link">https://doi.org/10.1002/sim.3811</a>.</p>
</div>
<div id="ref-wan2019">
<p>Wan, Fei. 2019. “Matched or Unmatched Analyses with Propensity-Scorematched Data?” <em>Statistics in Medicine</em> 38 (2): 289–300. <a href="https://doi.org/10.1002/sim.7976" class="external-link">https://doi.org/10.1002/sim.7976</a>.</p>
</div>
<div id="ref-wangRelativePerformancePropensity2018">
<p>Wang, Shirley V., Yinzhu Jin, Bruce Fireman, Susan Gruber, Mengdong He, Richard Wyss, HoJin Shin, et al. 2018. “Relative Performance of Propensity Score Matching Strategies for Subgroup Analyses.” <em>American Journal of Epidemiology</em> 187 (8): 1799–1807. <a href="https://doi.org/10.1093/aje/kwy049" class="external-link">https://doi.org/10.1093/aje/kwy049</a>.</p>
</div>
<div id="ref-westreich2013">
<p>Westreich, D., and S. Greenland. 2013. “The Table 2 Fallacy: Presenting and Interpreting Confounder and Modifier Coefficients.” <em>American Journal of Epidemiology</em> 177 (4): 292–98. <a href="https://doi.org/10.1093/aje/kws412" class="external-link">https://doi.org/10.1093/aje/kws412</a>.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="code-to-generate-data-used-in-examples">Code to Generate Data used in Examples<a class="anchor" aria-label="anchor" href="#code-to-generate-data-used-in-examples"></a>
</h2>
<div class="sourceCode" id="cb107"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Generating data similar to Austin (2009) for demonstrating treatment effect estimation</span>
<span class="va">gen_X</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">9</span> <span class="op">*</span> <span class="va">n</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="va">n</span>, ncol <span class="op">=</span> <span class="fl">9</span><span class="op">)</span>
  <span class="va">X</span><span class="op">[</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span><span class="va">X</span><span class="op">[</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;</span> <span class="fl">.5</span><span class="op">)</span>
  <span class="va">X</span>
<span class="op">}</span>

<span class="co">#~20% treated</span>
<span class="va">gen_A</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">X</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">LP_A</span> <span class="op">&lt;-</span> <span class="op">-</span> <span class="fl">1.2</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.5</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2.4</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">7</span><span class="op">]</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.5</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">8</span><span class="op">]</span>
  <span class="va">P_A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Logistic.html" class="external-link">plogis</a></span><span class="op">(</span><span class="va">LP_A</span><span class="op">)</span>
  <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">X</span><span class="op">)</span>, <span class="fl">1</span>, <span class="va">P_A</span><span class="op">)</span>
<span class="op">}</span>

<span class="co"># Continuous outcome</span>
<span class="va">gen_Y_C</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">A</span>, <span class="va">X</span><span class="op">)</span> <span class="op">{</span>
  <span class="fl">2</span><span class="op">*</span><span class="va">A</span> <span class="op">+</span> <span class="fl">2</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fl">2</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="fl">2</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">+</span> <span class="fl">2</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">6</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span>, <span class="fl">0</span>, <span class="fl">5</span><span class="op">)</span>
<span class="op">}</span>
<span class="co">#Conditional:</span>
<span class="co">#  MD: 2</span>
<span class="co">#Marginal:</span>
<span class="co">#  MD: 2</span>

<span class="co"># Binary outcome</span>
<span class="va">gen_Y_B</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">A</span>, <span class="va">X</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">LP_B</span> <span class="op">&lt;-</span> <span class="op">-</span><span class="fl">2</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2.4</span><span class="op">)</span><span class="op">*</span><span class="va">A</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.5</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2.4</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.5</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">6</span><span class="op">]</span>
  <span class="va">P_B</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Logistic.html" class="external-link">plogis</a></span><span class="op">(</span><span class="va">LP_B</span><span class="op">)</span>
  <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span>, <span class="fl">1</span>, <span class="va">P_B</span><span class="op">)</span>
<span class="op">}</span>
<span class="co">#Conditional:</span>
<span class="co">#  OR:   2.4</span>
<span class="co">#  logOR: .875</span>
<span class="co">#Marginal:</span>
<span class="co">#  RD:    .144</span>
<span class="co">#  RR:   1.54</span>
<span class="co">#  logRR: .433</span>
<span class="co">#  OR:   1.92</span>
<span class="co">#  logOR  .655</span>

<span class="co"># Survival outcome</span>
<span class="va">gen_Y_S</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">A</span>, <span class="va">X</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">LP_S</span> <span class="op">&lt;-</span> <span class="op">-</span><span class="fl">2</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2.4</span><span class="op">)</span><span class="op">*</span><span class="va">A</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.5</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">2.4</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1.5</span><span class="op">)</span><span class="op">*</span><span class="va">X</span><span class="op">[</span>,<span class="fl">6</span><span class="op">]</span>
  <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">*</span><span class="fl">2e4</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">LP_S</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span>
<span class="co">#Conditional:</span>
<span class="co">#  HR:   2.4</span>
<span class="co">#  logHR: .875</span>
<span class="co">#Marginal:</span>
<span class="co">#  HR:   1.57</span>
<span class="co">#  logHR: .452</span>

<span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">19599</span><span class="op">)</span>

<span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">2000</span>
<span class="va">X</span> <span class="op">&lt;-</span> <span class="fu">gen_X</span><span class="op">(</span><span class="va">n</span><span class="op">)</span>
<span class="va">A</span> <span class="op">&lt;-</span> <span class="fu">gen_A</span><span class="op">(</span><span class="va">X</span><span class="op">)</span>

<span class="va">Y_C</span> <span class="op">&lt;-</span> <span class="fu">gen_Y_C</span><span class="op">(</span><span class="va">A</span>, <span class="va">X</span><span class="op">)</span>
<span class="va">Y_B</span> <span class="op">&lt;-</span> <span class="fu">gen_Y_B</span><span class="op">(</span><span class="va">A</span>, <span class="va">X</span><span class="op">)</span>
<span class="va">Y_S</span> <span class="op">&lt;-</span> <span class="fu">gen_Y_S</span><span class="op">(</span><span class="va">A</span>, <span class="va">X</span><span class="op">)</span>

<span class="va">d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">A</span>, <span class="va">X</span>, <span class="va">Y_C</span>, <span class="va">Y_B</span>, <span class="va">Y_S</span><span class="op">)</span></code></pre></div>
</div>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>Because they are only appropriate with a large number of clusters, cluster-robust standard errors are generally not used with subclassification methods. Regular robust standard errors are valid with these methods when using the subclassification weights to estimate marginal effects.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Sometimes, an error will occur with this method, which usually means more bootstrap replications are required. The number of replicates must be greater than the original sample size when using the full bootstrap and greater than the number of pairs/strata when using the block bootstrap.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>The matching weights are not necessary when performing 1:1 matching, but we include them here for generality. When weights are not necessary, including them does not affect the estimates. Because it may not always be clear when weights are required, we recommend always including them.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>It is possible to exactly reproduce the <code><a href="../reference/match.data.html">match.data()</a></code> standard error using the <code><a href="../reference/match.data.html">get_matches()</a></code> data, but doing so may require some fiddling due to the defaults in <code>sandwich</code>.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>It is also known as fine stratification weighting, described by Desai et al. [-@desai2017].<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>Including subclass as a main effect in the MMWS-weighted regression will not change the effect estimate but may slightly decrease its estimated standard error.<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Daniel Ho, Kosuke Imai, Gary King, Elizabeth Stuart, Noah Greifer.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.3.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
