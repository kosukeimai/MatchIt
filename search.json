[{"path":"https://kosukeimai.github.io/MatchIt/articles/MatchIt.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"MatchIt: Getting Started","text":"MatchIt implements suggestions Ho et al. (2007) improving parametric statistical models estimating treatment effects observational studies reducing model dependence preprocessing data semi-parametric non-parametric matching methods. appropriately preprocessing MatchIt, researchers can use whatever parametric model used without MatchIt produce inferences robust less sensitive modeling assumptions. MatchIt reduces dependence causal inferences commonly made, hard--justify, statistical modeling assumptions using large range sophisticated matching methods. package includes several popular approaches matching provides access methods implemented packages single, unified, easy--use interface. Matching used context estimating causal effect binary treatment exposure outcome controlling measured pre-treatment variables, typically confounding variables variables prognostic outcome. throughout MatchIt documentation use word “treatment” refer focal causal variable interest, “treated” “control” reflecting names treatment groups. goal matching produce covariate balance, , distributions covariates two groups approximately equal , successful randomized experiment. importance covariate balance allows increased robustness choice model used estimate treatment effect; perfectly balanced samples, simple difference means can valid treatment effect estimate. aim provide full introduction matching causal inference theory, simply explain use MatchIt perform nonparametric preprocessing. excellent accessible introductions matching, see Stuart (2010) Austin (2011). matching analysis involves four primary steps: 1) planning, 2) matching, 3) assessing quality matches, 4) estimating treatment effect uncertainty. briefly discuss steps can implemented MatchIt; included vignettes, steps discussed detail. use Lalonde’s data evaluation National Supported Work program demonstrate MatchIt’s capabilities. First, load MatchIt bring lalonde dataset. statistical quantity interest causal effect treatment (treat) 1978 earnings (re78). variables pre-treatment covariates. See ?lalonde information dataset. particular, analysis concerned marginal, total effect treatment actually received treatment. follows, briefly describe four steps matching analysis implement MatchIt. details, recommend reading vignettes, vignette(\"matching-methods\"), vignette(\"assessing-balance\"), vignette(\"estimating-effects\"), especially users less familiar matching methods. use MatchIt sampling weights, also see vignette(\"sampling-weights\"). important recognize ease using MatchIt imply simplicity matching methods; advanced statistical methods like matching require many decisions made caution use performed statistical training.","code":"library(\"MatchIt\") data(\"lalonde\")  head(lalonde) ##      treat age educ   race married nodegree re74 re75       re78 ## NSW1     1  37   11  black       1        1    0    0  9930.0460 ## NSW2     1  22    9 hispan       0        1    0    0  3595.8940 ## NSW3     1  30   12  black       0        0    0    0 24909.4500 ## NSW4     1  27   11  black       0        1    0    0  7506.1460 ## NSW5     1  33    8  black       0        1    0    0   289.7899 ## NSW6     1  22    9  black       0        1    0    0  4056.4940"},{"path":"https://kosukeimai.github.io/MatchIt/articles/MatchIt.html","id":"planning","dir":"Articles","previous_headings":"","what":"Planning","title":"MatchIt: Getting Started","text":"planning phase matching analysis involves selecting type effect estimated, selecting target population treatment effect generalize, selecting covariates balance required unbiased estimate treatment effect. theoretical steps involve performing analyses data. Ideally, considered prior data collection planning stage study. Thinking early can aid performing complete cost-effective analysis. Selecting type effect estimated. different types effects estimated. presence mediating variables, one might interested direct effect treatment pass mediating variables total effect treatment across causal pathways. Matching well suited estimating total effects, specific mediation methods may better suited mediation-related quantities. One may interested conditional effect marginal effect. conditional effect effect treatment within strata prognostic variables (e.g., patient level), marginal effect average effect treatment population (e.g., implementing broad policy change). Different types matching well suited , common forms best used estimating marginal treatment effects; conditional treatment effects, typically modeling assumptions required matching must done within strata conditioning variables. Matching can reduce reliance correct model specification conditional effects. Selecting target population. target population population effect estimate generalize. Typically, effect estimated sample generalizes population sample probability sample. sample probability sample population (e.g., convenience sample involves patients arbitrary hospital), target population can unclear. Often, target population group units eligible treatment (subset thereof). Causal estimands defined target population generalize. average treatment effect population (ATE) average effect treatment units target population. average treatment effect treated (ATT) average effect treatment units like actually treated. common forms matching best suited estimating ATT, though also available estimating ATE. matching methods distort sample way estimated treatment effect corresponds neither ATE ATT, rather effect unspecified population (sometimes called ATM, average treatment effect remaining matched sample). target population important (e.g., case treatment effect discovery), methods may attractive; otherwise, care taken ensuring effect generalizes target population interest. Different matching methods allow different target populations, important choose matching method allows one estimate desired effect. See Greifer Stuart (2021) guidance making choice. Selecting covariates balance. Selecting covariates carefully critical ensuring resulting treatment effect estimate free confounding can validly interpreted causal effect. estimate total causal effects, covariates must measured prior treatment (otherwise affected treatment). Covariates cause variation outcome selection treatment group; known confounding variables. See VanderWeele (2019) guide covariate selection. Ideally covariates measured without error free missingness.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/MatchIt.html","id":"check-initial-imbalance","dir":"Articles","previous_headings":"","what":"Check Initial Imbalance","title":"MatchIt: Getting Started","text":"planning prior matching, can good idea view initial imbalance one’s data matching attempting eliminate. can using code : first argument formula relating treatment covariates used estimating propensity score balance assessed. data argument specifies dataset variables exist. Typically, method argument specifies method matching performed; , set NULL can assess balance prior matching1. distance argument specifies method estimating propensity score, one-dimensional summary included covariates, computed predicted probability treated group given covariates; , set \"glm\" generalized linear model, implements logistic regression default2 (see ?distance options). assess balance unmatched data using summary(): can see severe imbalances measured standardized mean differences (Std. Mean Diff.), variance ratios (Var. Ratio), empirical cumulative distribution function (eCDF) statistics. Values standardized mean differences eCDF statistics close zero values variance ratios close one indicate good balance, many far ideal values.","code":"# No matching; constructing a pre-match matchit object m.out0 <- matchit(treat ~ age + educ + race + married +                      nodegree + re74 + re75,                   data = lalonde,                   method = NULL,                   distance = \"glm\") # Checking balance prior to matching summary(m.out0) ##  ## Call: ## matchit(formula = treat ~ age + educ + race + married + nodegree +  ##     re74 + re75, data = lalonde, method = NULL, distance = \"glm\") ##  ## Summary of Balance for All Data: ##            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max ## distance          0.5774        0.1822          1.7941     0.9211    0.3774   0.6444 ## age              25.8162       28.0303         -0.3094     0.4400    0.0813   0.1577 ## educ             10.3459       10.2354          0.0550     0.4959    0.0347   0.1114 ## raceblack         0.8432        0.2028          1.7615          .    0.6404   0.6404 ## racehispan        0.0595        0.1422         -0.3498          .    0.0827   0.0827 ## racewhite         0.0973        0.6550         -1.8819          .    0.5577   0.5577 ## married           0.1892        0.5128         -0.8263          .    0.3236   0.3236 ## nodegree          0.7081        0.5967          0.2450          .    0.1114   0.1114 ## re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248   0.4470 ## re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342   0.2876 ##  ## Sample Sizes: ##           Control Treated ## All           429     185 ## Matched       429     185 ## Unmatched       0       0 ## Discarded       0       0"},{"path":"https://kosukeimai.github.io/MatchIt/articles/MatchIt.html","id":"matching","dir":"Articles","previous_headings":"","what":"Matching","title":"MatchIt: Getting Started","text":"Now, matching can performed. several different classes methods matching, described vignette(\"matching-methods\"). , begin briefly demonstrating 1:1 nearest neighbor (NN) matching propensity score, appropriate estimating ATT. One one, treated unit paired available control unit closest propensity score . remaining control units left unmatched excluded analysis. Due theoretical balancing properties propensity score described Rosenbaum Rubin (1983), propensity score matching can effective way achieve covariate balance treatment groups. demonstrate use matchit() perform nearest neighbor propensity score matching. use syntax , time specify method = \"nearest\" implement nearest neighbor matching, using logistic regression propensity score. Many arguments available tuning matching method method propensity score estimation. matching outputs contained m.out1 object. Printing object gives description type matching performed: key components m.out1 object weights (computed matching weights), subclass (matching pair membership), distance (estimated propensity score), match.matrix (control units matched treated unit). can used estimating effect treatment matching detailed vignette(\"estimating-effects\").","code":"# 1:1 NN PS matching w/o replacement m.out1 <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75,                   data = lalonde,                   method = \"nearest\",                   distance = \"glm\") m.out1 ## A `matchit` object ##  - method: 1:1 nearest neighbor matching without replacement ##  - distance: Propensity score ##              - estimated with logistic regression ##  - number of obs.: 614 (original), 370 (matched) ##  - target estimand: ATT ##  - covariates: age, educ, race, married, nodegree, re74, re75"},{"path":"https://kosukeimai.github.io/MatchIt/articles/MatchIt.html","id":"assessing-the-quality-of-matches","dir":"Articles","previous_headings":"","what":"Assessing the Quality of Matches","title":"MatchIt: Getting Started","text":"Although matching propensity score often effective eliminating differences treatment groups achieve covariate balance, performance regard must assessed. covariates remain imbalanced matching, matching considered unsuccessful, different matching specification tried. MatchIt offers tools assessment covariate balance matching. include graphical statistical methods. detail interpretation included plots statistics can found vignette(\"assessing-balance\"). addition covariate balance, quality match determined many units remain matching. Matching often involves discarding units paired units, matching options, setting restrictions common support calipers, can decrease number remaining units. , matching, remaining sample size small, resulting effect estimate may imprecise. many cases, trade-balance remaining sample size. optimally choose among instance fundamental bias-variance trade-problem resolved without substantive knowledge phenomena study. Prospective power analyses can used determine small sample can necessary precision sacrificed. assess quality resulting matches numerically, can use summary() function m.out1 . set un = FALSE suppress display balance matching brevity already saw . (Leaving TRUE, default, display balance matching.) top summary covariate balance matching. Although balance improved covariates, general balance still quite poor, indicating nearest neighbor propensity score matching sufficient removing confounding dataset. final column, Std. Pair Diff, displays average absolute within-pair difference covariate. values small, better balance typically achieved estimated effects robust misspecification outcome model (King Nielsen 2019; Rubin 1973). Next table sample sizes matching. matching procedure left 244 control units unmatched. Ideally, unmatched units far treated units require greater extrapolation retained. can visualize distribution propensity scores matched using plot() type = \"jitter\":  can visually examine balance covariates using plot() type = \"density\":  Imbalances represented differences black (treated) gray (control) distributions. Although married re75 appear improved balance matching, case mixed age.","code":"# Checking balance after NN matching summary(m.out1, un = FALSE) ##  ## Call: ## matchit(formula = treat ~ age + educ + race + married + nodegree +  ##     re74 + re75, data = lalonde, method = \"nearest\", distance = \"glm\") ##  ## Summary of Balance for Matched Data: ##            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max Std. Pair Dist. ## distance          0.5774        0.3629          0.9739     0.7566    0.1321   0.4216          0.9740 ## age              25.8162       25.3027          0.0718     0.4568    0.0847   0.2541          1.3938 ## educ             10.3459       10.6054         -0.1290     0.5721    0.0239   0.0757          1.2474 ## raceblack         0.8432        0.4703          1.0259          .    0.3730   0.3730          1.0259 ## racehispan        0.0595        0.2162         -0.6629          .    0.1568   0.1568          1.0743 ## racewhite         0.0973        0.3135         -0.7296          .    0.2162   0.2162          0.8390 ## married           0.1892        0.2108         -0.0552          .    0.0216   0.0216          0.8281 ## nodegree          0.7081        0.6378          0.1546          .    0.0703   0.0703          1.0106 ## re74           2095.5737     2342.1076         -0.0505     1.3289    0.0469   0.2757          0.7965 ## re75           1532.0553     1614.7451         -0.0257     1.4956    0.0452   0.2054          0.7381 ##  ## Sample Sizes: ##           Control Treated ## All           429     185 ## Matched       185     185 ## Unmatched     244       0 ## Discarded       0       0 plot(m.out1, type = \"jitter\", interactive = FALSE) plot(m.out1, type = \"density\", interactive = FALSE,      which.xs = ~age + married + re75)"},{"path":"https://kosukeimai.github.io/MatchIt/articles/MatchIt.html","id":"trying-a-different-matching-specification","dir":"Articles","previous_headings":"Assessing the Quality of Matches","what":"Trying a Different Matching Specification","title":"MatchIt: Getting Started","text":"Given poor performance nearest neighbor matching example, can try different matching method make changes matching algorithm distance specification. , ’ll try full matching, matches every treated unit least one control every control least one treated unit (Hansen 2004; Stuart Green 2008). ’ll also try different link (probit) propensity score model. can examine balance new matching specification. Balance far better, determined lower standardized mean differences eCDF statistics. balance reported publishing results matching analysis. can done either table, using values resulting summary(), plot, Love plot, can make calling plot() summary() output:  Love plots simple straightforward way summarize balance visually. See vignette(\"assessing-balance\") information customize MatchIt’s Love plot use cobalt, package designed specifically balance assessment reporting compatible MatchIt.","code":"# Full matching on a probit PS m.out2 <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75,                   data = lalonde,                   method = \"full\",                   distance = \"glm\",                   link = \"probit\") m.out2 ## A `matchit` object ##  - method: Optimal full matching ##  - distance: Propensity score ##              - estimated with probit regression ##  - number of obs.: 614 (original), 614 (matched) ##  - target estimand: ATT ##  - covariates: age, educ, race, married, nodegree, re74, re75 # Checking balance after full matching summary(m.out2, un = FALSE) ##  ## Call: ## matchit(formula = treat ~ age + educ + race + married + nodegree +  ##     re74 + re75, data = lalonde, method = \"full\", distance = \"glm\",  ##     link = \"probit\") ##  ## Summary of Balance for Matched Data: ##            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max Std. Pair Dist. ## distance          0.5773        0.5764          0.0045     0.9949    0.0043   0.0486          0.0198 ## age              25.8162       25.5347          0.0393     0.4790    0.0787   0.2742          1.2843 ## educ             10.3459       10.5381         -0.0956     0.6192    0.0253   0.0730          1.2179 ## raceblack         0.8432        0.8389          0.0119          .    0.0043   0.0043          0.0162 ## racehispan        0.0595        0.0492          0.0435          .    0.0103   0.0103          0.4412 ## racewhite         0.0973        0.1119         -0.0493          .    0.0146   0.0146          0.3454 ## married           0.1892        0.1633          0.0660          .    0.0259   0.0259          0.4473 ## nodegree          0.7081        0.6577          0.1110          .    0.0504   0.0504          0.9872 ## re74           2095.5737     2100.2150         -0.0009     1.3467    0.0314   0.1881          0.8387 ## re75           1532.0553     1561.4420         -0.0091     1.5906    0.0536   0.1984          0.8240 ##  ## Sample Sizes: ##               Control Treated ## All            429.       185 ## Matched (ESS)   50.76     185 ## Matched        429.       185 ## Unmatched        0.         0 ## Discarded        0.         0 plot(summary(m.out2))"},{"path":"https://kosukeimai.github.io/MatchIt/articles/MatchIt.html","id":"estimating-the-treatment-effect","dir":"Articles","previous_headings":"","what":"Estimating the Treatment Effect","title":"MatchIt: Getting Started","text":"treatment effects estimated depends form matching performed. See vignette(\"estimating-effects\") information estimate treatment effects variety scenarios (.e., different matching methods outcome types). full matching matching methods, can run regression outcome treatment covariates matched sample (.e., including matching weights) estimate treatment effect using g-computation implemented marginaleffects::avg_comparisons()3. Including covariates used matching effect estimation can provide additional robustness slight imbalances remaining matching can improve precision. full matching successful balancing covariates, ’ll demonstrate estimate treatment effect performing analysis. First, ’ll extract matched dataset matchit object using match_data(). dataset contains matched units adds columns distance, weights, subclass (described previously). can model outcome dataset using standard regression functions R, like lm() glm(), sure include matching weights (stored weights variable match_data() output) estimation4. Finally, use marginaleffects::avg_comparisons() perform g-computation estimate ATT. recommend using cluster-robust standard errors analyses, pair membership clustering variable; avg_comparisons() makes straightforward. outcome model coefficients tests interpreted reported. See vignette(\"estimating-effects\") information estimate effects standard errors different forms matching different outcome types. benefit matching outcome model used estimate treatment effect robust misspecification balance achieved. full matching, able achieve balance, effect estimate depend less form outcome model used used 1:1 matching without replacement matching .","code":"m.data <- match_data(m.out2)  head(m.data) ##      treat age educ   race married nodegree re74 re75       re78  distance weights subclass ## NSW1     1  37   11  black       1        1    0    0  9930.0460 0.6356769       1        1 ## NSW2     1  22    9 hispan       0        1    0    0  3595.8940 0.2298151       1       55 ## NSW3     1  30   12  black       0        0    0    0 24909.4500 0.6813558       1       63 ## NSW4     1  27   11  black       0        1    0    0  7506.1460 0.7690590       1       70 ## NSW5     1  33    8  black       0        1    0    0   289.7899 0.6954138       1       79 ## NSW6     1  22    9  black       0        1    0    0  4056.4940 0.6943658       1       86 library(\"marginaleffects\")  fit <- lm(re78 ~ treat * (age + educ + race + married +                             nodegree + re74 + re75),           data = m.data,           weights = weights)  avg_comparisons(fit,                 variables = \"treat\",                 vcov = ~subclass,                 newdata = subset(treat == 1)) ##  ##  Estimate Std. Error    z Pr(>|z|)   S 2.5 % 97.5 % ##      1977        704 2.81  0.00501 7.6   596   3357 ##  ## Term: treat ## Type:  response  ## Comparison: 1 - 0 ## Columns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted"},{"path":"https://kosukeimai.github.io/MatchIt/articles/MatchIt.html","id":"reporting-results","dir":"Articles","previous_headings":"","what":"Reporting Results","title":"MatchIt: Getting Started","text":"report matching results manuscript research report, key pieces information required. One detailed possible matching procedure decisions made ensure analysis replicable can adequately assessed soundness audience. Key pieces information include 1) matching specification used (including method additional options, like calipers common support restrictions), 2) distance measure used (including estimated e.g., using logistic regression propensity scores), 3) matching methods tried prior settling final specification choices made, 4) balance final matching specification (including standardized mean differences balance statistics variables, powers, interactions; can reported summaries rather full detail), 5) number matched, unmatched, discarded units included effect estimation, 6) method estimating treatment effect standard error confidence interval (including specific model used specific type standard error). See Thoemmes Kim (2011) complete list specific details report. example might write prior analysis: used propensity score matching estimate average marginal effect treatment 1978 earnings received accounting confounding included covariates. first attempted 1:1 nearest neighbor propensity score matching without replacement propensity score estimated using logistic regression treatment covariates. matching specification yielded poor balance, instead tried full matching propensity score, yielded adequate balance, indicated Table 1 Figure 1. propensity score estimated using probit regression treatment covariates, yielded better balance logistic regression. matching, standardized mean differences covariates 0.1 standardized mean differences squares two-way interactions covariates .15, indicating adequate balance. Full matching uses treated control units, units discarded matching. estimate treatment effect standard error, fit linear regression model 1978 earnings outcome treatment, covariates, interaction predictors included full matching weights estimation. lm() function used fit outcome, avg_comparisons() function marginaleffects package used perform g-computation matched sample estimate ATT. cluster-robust variance used estimate standard error matching stratum membership clustering variable. estimated effect $1977 (SE = 704.3, p = 0.005), indicating average effect treatment received increase earnings.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/MatchIt.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"MatchIt: Getting Started","text":"Although covered basics performing matching analysis , use matching full potential, advanced methods available MatchIt considered. recommend reading vignettes included gain better understand MatchIt offer use responsibly effectively. previously stated, ease using MatchIt imply matching causal inference general simple matters; matching advanced statistical technique used care caution. hope capabilities MatchIt ease encourage use nonparametric preprocessing estimating causal effects robust well-justified way.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Assessing Balance","text":"Covariate balance degree distribution covariates similar across levels treatment. three main roles causal effect estimation using matching: 1) target optimize matching, 2) method assessing quality resulting matches, 3) evidence audience estimated effect close true effect. covariate balance achieved, resulting effect estimate less sensitive model misspecification ideally close true treatment effect. benefit randomization covariate balance achieved automatically (expectation), unadjusted effects estimated randomized trial data (absence drop-) can validly interpreted causal effects. using matching recover causal effect estimates form observational data, balance guaranteed must assessed. document provides instructions assessing reporting covariate balance part matching analysis. tools available MatchIt balance assessment used process selecting good matching scheme ensuring chosen scheme adequate. tools implement recommendations Ho et al. (2007) others assessing balance. addition tools available MatchIt, cobalt package suite functions designed assess display balance directly compatible MatchIt objects. cobalt extensive documentation, describe functionality complement tools MatchIt. structure document follows: first, describe recommendations balance checking rationale; next, describe tools assessing balance present MatchIt display use evaluating several matching schemes; finally; briefly describe functionality cobalt extend MatchIt.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"recommendations-for-balance-assessment","dir":"Articles","previous_headings":"","what":"Recommendations for Balance Assessment","title":"Assessing Balance","text":"Assessing balance involves assessing whether distributions covariates similar treated control groups. Balance typically assessed examining univariate balance summary statistics covariate, though complicated methods exist assessing joint distributional balance well. Visual depictions distributional balance can helpful complement numerical summaries, especially hard balance prognostically important covariates. Many recommendations balance assessment described methodological literature. Unfortunately, single best way assess balance weigh balance summary statistics degree form balance yield least bias effect estimate depends unknown qualities outcome data-generating model. Nonetheless, number valuable recommendations can implemented ensure matching successful eliminating reducing bias. review . Common recommendations assessing balance include following: Standardized mean differences. standardized mean difference (SMD) difference means covariate treatment groups standardized standardization factor scale covariates. standardization factor typically standard deviation covariate treated group targeting ATT pooled standard deviation across groups targeting ATE. standardization factor matching ensure changes mean difference confounded changes standard deviation covariate. SMDs close zero indicate good balance. Several recommended thresholds published literature; recommend .1 .05 prognostically important covariates. Higher values may acceptable using covariate adjustment matched sample. addition computing SMDs covariates , important compute squares, cubes, higher exponents well interactions covariates. Several empirical studies examined appropriateness using SMDs balance assessment, including Belitser et al. (2011), Ali et al. (2014), Stuart, Lee, Leacy (2013); general, often high correlation mean maximum absolute SMD degree bias treatment effect. Variance Ratios. variance ratio ratio variance covariate one group . Variance ratios close 1 indicate good balance imply variances samples similar (Austin 2009). Empirical CDF Statistics. Statistics related difference empirical cumulative distribution functions (eCDFs) covariate groups allow assessment imbalance across entire covariate distribution covariate rather just mean variance. maximum eCDF difference, also known Kolmogorov-Smirnov statistic, sometimes recommended useful supplement SMDs assessing balance (Austin Stuart 2015) often used criterion use propensity score methods attempt optimize balance (e.g., McCaffrey, Ridgeway, Morral 2004; Diamond Sekhon 2013). Although mean eCDF difference well studied, provides summary imbalance may missed relying solely maximum difference. Visual Diagnostics. Visual diagnostics eCDF plots, empirical quantile-quantile (eQQ) plots, kernel density plots can used see exactly covariate distributions differ , .e., distribution greatest imbalances (Ho et al. 2007; Austin 2009). can help figure tailor matching method target imbalance specific region covariate distribution. Prognostic scores. prognostic score estimate potential outcome control unit (Hansen 2008). Balance prognostic score shown highly correlated bias effect estimate, making useful tool balance assessment (Stuart, Lee, Leacy 2013). Estimating prognostic score requires access outcome data, using may seen violating principle separating design analysis stages matching analysis (Rubin 2001). However, outcome values control group required use prognostic score, separation maintained. Several multivariate statistics exist summarize balance across entire joint covariate distribution. can functions measures, like mean maximum absolute SMD generalized weighted distance [GWD; Franklin et al. (2014)], sum SMDs covariates squares interactions, separate statistics measure quantities abstract away distribution individual covariates, like L1 distance (Iacus, King, Porro 2011), cross-match test (Heller, Rosenbaum, Small 2010), energy distance (Huling Mak 2020). Balance propensity score often considered useful measure balance, necessarily recommend except supplement balance covariates. Propensity score balance generally good matching method regardless covariate balancing potential propensity score, balanced propensity score imply balanced covariates (Austin 2009). Similarly, may happen covariates may well balanced even propensity score balanced, covariates prioritized propensity score matching specification (e.g., genetic matching). Given observations, propensity score relied upon assessing covariate balance. Simulation studies Stuart, Lee, Leacy (2013) provide evidence recommendation relying propensity score balance. debate use hypothesis tests, t-tests Kolmogorov-Smirnov tests, assessing covariate balance. idea balance tests test null hypothesis matched sample equivalent balance randomized experiment. several problems balance tests, described Ho et al. (2007) Imai, King, Stuart (2008): 1) balance property sample, population sample drawn; 2) power balance tests depends sample size, changes matching even balance change; 3) use hypothesis tests implies uniform decision criterion rejecting null hypothesis (e.g., p-value less .05, potentially corrections multiple comparisons), balance improved without limit. MatchIt report balance tests p-values, instead relying descriptive statistics described .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"recommendations-for-balance-reporting","dir":"Articles","previous_headings":"","what":"Recommendations for Balance Reporting","title":"Assessing Balance","text":"variety methods used assessing balance try find optimal matched set ideally yield low-error estimate desired effect. However, reporting every balance statistic plot research report publication can burdensome unnecessary. said, critical report balance demonstrate readers resulting estimate approximately unbiased relies little extrapolation correct outcome model specification. recommend following reporting balance matching analysis: Report SMDs matching covariate, prognostically important interactions covariates, prognostic score; can reported table Love plot. Report summaries balance statistics, e.g., largest mean maximum eCDF difference among covariates largest SMD among squares, cubes, interactions covariates. MatchIt provides tools calculating statistics can reported ease manuscript report.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"assessing-balance-with-matchit","dir":"Articles","previous_headings":"","what":"Assessing Balance with MatchIt","title":"Assessing Balance","text":"MatchIt contains several tools assess balance numerically graphically. primary balance assessment function summary.matchit(), called using summary() MatchIt object produces several tables balance statistics matching. plot.summary.matchit() generates Love plot using R’s base graphics system containing standardized mean differences resulting call summary.matchit() provides nice way display balance visually inclusion article report. plot.matchit() generates several plots display different elements covariate balance, including propensity score overlap distribution plots covariates. functions together form suite can used assess report balance variety ways. demonstrate MatchIt’s balance assessment capabilities, use Lalonde data included MatchIt used vignette(\"MatchIt\"). perform 1:1 nearest neighbor matching replacement propensity score, though functionality identical across matching methods except propensity score subclassification, illustrate end.","code":"library(\"MatchIt\") data(\"lalonde\", package = \"MatchIt\")  #1:1 NN matching w/ replacement on a logistic regression PS m.out <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75, data = lalonde,                  replace = TRUE) m.out ## A `matchit` object ##  - method: 1:1 nearest neighbor matching with replacement ##  - distance: Propensity score ##              - estimated with logistic regression ##  - number of obs.: 614 (original), 267 (matched) ##  - target estimand: ATT ##  - covariates: age, educ, race, married, nodegree, re74, re75"},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"summary-matchit","dir":"Articles","previous_headings":"Assessing Balance with MatchIt","what":"summary.matchit()","title":"Assessing Balance","text":"summary() called matchit object, several tables information displayed. include balance statistics covariate matching, balance statistics covariate matching, percent reduction imbalance matching, sample sizes matching. summary.matchit() four additional arguments control balance computed: interactions controls whether balance statistics squares pairwise interactions covariates displayed addition covariates. default FALSE, setting TRUE can make output massive many covariates present, important ensure important interactions remain imbalanced. addlvariables allows balance assessed variables inside matchit object. example, distance units relied subset covariates balance needed achieved covariates, addlvariables used supply additional covariates. addition adding variables, addlvariables can used request balance specific functions covariates already matchit object, polynomial terms interactions. input addlvariables can one-sided formula covariates desired transformations thereof right hand side, just like model formula (e.g., addlvariables = ~ X1 + X2 + (X1^2) request balance X1, X2, square X1). Additional variables supplied addlvariables present matchit object can supplied data frame using data argument. standardize controls whether standardized unstandardized statistics displayed. Standardized statistics include standardized mean difference eCDF statistics; unstandardized statistics include raw difference means eQQ plot statistics. (Regardless, variance ratio always displayed.). default TRUE standardized statistics, common report scale regardless scale covariates1. pair.dist controls whether within-pair distances computed displayed. reflect average distance units within pair, standardized unstandardized according argument standardize. default TRUE. full matching, exact matching, coarsened exact matching, propensity score subclassification, computing pair distances can take long time, may beneficial set FALSE cases. addition, arguments un (default: TRUE) improvement (default: FALSE) control whether balance prior matching displayed whether percent balance improvement matching displayed. can set FALSE reduce output. , call summary.matchit() addlvariables display balance covariates functions matched sample. particular, request balance square age, variables representing whether re74 re75 equal 0, interaction educ race. Let’s examine output detail. first table (Summary Balance Data) provides balance sample prior matching. included statistics mean covariates treated group (Means Treated), mean covariate control group (Means Control), SMDs (Std. Mean Diff.), variance ratio (Var. Ratio), average distance eCDFs covariate across groups (eCDF Mean), largest distance eCDFs (eCDF Max). Setting un = FALSE suppressed creation table. second table (Summary Balance Matched Data) contains statistics matched sample. implicitly request pair distance, additional column standardized pair distances (Std. Pair Dist.) displayed. final table (Sample Sizes) contains sizes samples () (Matched) matching, well number units left unmatched (Unmatched) number units dropped due common support restriction (Discarded). SMDs computed mean difference divided standardization factor computed unmatched sample. absolute SMD close 0 indicates good balance; although number recommendations acceptable values appeared literature, recommend absolute values less .1 less .05 potentially prognostically important variables. variance ratios computed ratio variance treated group control group covariate. Variance ratios computed binary covariates function prevalence group, captured mean difference eCDF statistics. variance ratio close 1 indicates good balance; commonly used recommendation variance ratios .5 2. eCDF statistics correspond difference overall distributions covariates treatment groups. values statistics range 0 1, values closer zero indicating better balance. specific recommendations values statistics take, though notably high values may indicate imbalance higher moments covariates. eQQ statistics produced standardize = FALSE interpreted similarly scale covariate. statistics considered together. Imbalance measured may indicate potential failure matching scheme achieve distributional balance.","code":"summary(m.out, addlvariables = ~ I(age^2) + I(re74==0) +            I(re75==0) + educ:race) ##  ## Call: ## matchit(formula = treat ~ age + educ + race + married + nodegree +  ##     re74 + re75, data = lalonde, replace = TRUE) ##  ## Summary of Balance for All Data: ##                  Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max ## distance                 0.577         0.182           1.794      0.921     0.377    0.644 ## age                     25.816        28.030          -0.309      0.440     0.081    0.158 ## educ                    10.346        10.235           0.055      0.496     0.035    0.111 ## raceblack                0.843         0.203           1.762          .     0.640    0.640 ## racehispan               0.059         0.142          -0.350          .     0.083    0.083 ## racewhite                0.097         0.655          -1.882          .     0.558    0.558 ## married                  0.189         0.513          -0.826          .     0.324    0.324 ## nodegree                 0.708         0.597           0.245          .     0.111    0.111 ## re74                  2095.574      5619.237          -0.721      0.518     0.225    0.447 ## re75                  1532.055      2466.484          -0.290      0.956     0.134    0.288 ## I(age^2)               717.395       901.779          -0.428      0.363     0.081    0.158 ## I(re74 == 0)TRUE         0.708         0.261           0.983          .     0.447    0.447 ## I(re75 == 0)TRUE         0.600         0.312           0.587          .     0.288    0.288 ## educ:raceblack           8.697         2.047           1.580      0.980     0.354    0.645 ## educ:racehispan          0.578         1.263          -0.294      0.487     0.046    0.078 ## educ:racewhite           1.070         6.925          -1.767      0.365     0.279    0.555 ##  ## Summary of Balance for Matched Data: ##                  Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max Std. Pair Dist. ## distance                 0.577         0.576           0.004      0.992     0.003    0.049           0.013 ## age                     25.816        24.103           0.239      0.557     0.077    0.341           1.262 ## educ                    10.346        10.378          -0.016      0.577     0.022    0.059           1.086 ## raceblack                0.843         0.838           0.015          .     0.005    0.005           0.045 ## racehispan               0.059         0.065          -0.023          .     0.005    0.005           0.297 ## racewhite                0.097         0.097           0.000          .     0.000    0.000           0.054 ## married                  0.189         0.130           0.152          .     0.059    0.059           0.511 ## nodegree                 0.708         0.703           0.012          .     0.005    0.005           0.868 ## re74                  2095.574      2336.463          -0.049      1.036     0.041    0.216           0.609 ## re75                  1532.055      1503.929           0.009      2.129     0.068    0.238           0.650 ## I(age^2)               717.395       670.946           0.108      0.510     0.077    0.341           1.196 ## I(re74 == 0)TRUE         0.708         0.492           0.476          .     0.216    0.216           0.975 ## I(re75 == 0)TRUE         0.600         0.362           0.485          .     0.238    0.238           1.037 ## educ:raceblack           8.697         8.589           0.026      0.869     0.024    0.054           0.468 ## educ:racehispan          0.578         0.638          -0.026      0.827     0.007    0.022           0.336 ## educ:racewhite           1.070         1.151          -0.024      0.846     0.005    0.022           0.220 ##  ## Sample Sizes: ##               Control Treated ## All            429.       185 ## Matched (ESS)   46.31     185 ## Matched         82.       185 ## Unmatched      347.         0 ## Discarded        0.         0"},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"plot-summary-matchit","dir":"Articles","previous_headings":"Assessing Balance with MatchIt","what":"plot.summary.matchit()","title":"Assessing Balance","text":"Love plot clean way visually summarize balance. Using plot output call summary() matchit object produces Love plot standardized mean differences. plot.summary.matchit() several additional arguments can used customize plot. abs controls whether standardized mean difference displayed absolute value . Default TRUE. var.order controls variables ordered y-axis. options \"data\" (default), orders variables appear summary.matchit() output; \"unmatched\", orders variables based standardized mean differences matching; \"matched\", orders variables based standardized mean differences matching; \"alphabetical\", orders variables alphabetically. Using \"unmatched\" tends result attractive plots ensures legend doesn’t overlap points default position. threshold controls vertical lines indicating chosen thresholds appear x-axis. numeric vector. default c(.1, .05), display vertical lines .1 .05 standardized mean difference units. position controls position legend. default \"bottomright\", puts legend bottom right corner plot, keyword value available supplied x legend() allowed. create Love plot covariates.  plot clear see balance quite poor prior matching, full matching improved balance covariates, within threshold .1. make variable names cleaner, original variables renamed prior matching. cobalt provides many additional options generate customize Love plots using love.plot() function used plot beyond available plot.summary.matchit() desired.","code":"m.sum <- summary(m.out, addlvariables = ~ I(age^2) + I(re74==0) +                     I(re75==0) + educ:race) plot(m.sum, var.order = \"unmatched\")"},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"plot-matchit","dir":"Articles","previous_headings":"Assessing Balance with MatchIt","what":"plot.matchit()","title":"Assessing Balance","text":"addition numeric summaries balance, MatchIt offers graphical summaries well using plot.matchit() (.e., using plot() matchit object). can create eQQ plots, eCDF plots, density plots covariates histograms jitter plots propensity score. covariate plots can provide summary balance full marginal distribution covariate beyond just mean variance. plot.matchit() arguments customize output: type corresponds type plot desired. Options include \"qq\" eQQ plots (default), \"ecdf\" eCDF plots, \"density\" density plots (bar plots categorical variables), \"jitter\" jitter plots, \"histogram\" histograms. interactive controls whether plot interactive . eQQ, eCDF, density plots, allows us control next page covariates displayed since three can appear time. jitter plots, can allow us select individual units extreme values inspection. default TRUE. .xs used specify covariates display balance eQQ, eCDF, density plots. default display balance , can request balance just specific subset. three fewer requested, interactive ignored. argument can supplied one-sided formula variables interest right character vector containing names desired variables. variables matchit object, data argument can supplied data set containing named variables. , demonstrate eQQ plot:  y-axis displays value covariate treated units, x-axis displays value covariate corresponding quantile control group. values fall 45 degree line, groups balanced. , can see age remains somewhat imbalanced, nodegree re74 much better balance matching . difference x y values point used compute eQQ difference statistics displayed summary.matchit() standardize = FALSE. , demonstrate eCDF plot:  x-axis displays covariate values y-axis displays proportion sample less covariate value. Perfectly overlapping lines indicate good balance. black line corresponds treated group gray line control group. Although educ re75 fairly well balanced matching, balance improved nonetheless. married appears far better balanced matching . vertical difference eCDFs lines treatment group used compute eCDF difference statistics displayed summary.matchit() standardize = TRUE. , demonstrate density plot:  x-axis displays covariate values y-axis displays density sample covariate value. categorical variables, y-axis displays proportion sample covariate value. black line corresponds treated group gray line control group. Perfectly overlapping lines indicate good balance. Density plots display similar information eCDF plots may intuitive users link histograms.","code":"#eQQ plot plot(m.out, type = \"qq\", which.xs = ~age + nodegree + re74) #eCDF plot plot(m.out, type = \"ecdf\", which.xs = ~educ + married + re75) #density plot plot(m.out, type = \"density\", which.xs = ~age + educ + race)"},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"assessing-balance-after-subclassification","dir":"Articles","previous_headings":"","what":"Assessing Balance After Subclassification","title":"Assessing Balance","text":"subclassification, balance can checked within subclass overall. summary.matchit(), can request view balance aggregate subclass. latter can help us decide can interpret effects estimated within subclass unbiased. plot.summary.matchit() plot.matchit() outputs can requested either aggregate subclass. demonstrate . First perform propensity score subclassification using 4 subclasses (typically beneficial). using summary(), default display balance aggregate using subclassification weights. balance output looks similar matching methods. additional option summary(), subclass, allows us request balance individual subclasses. subclass can set TRUE display balance subclasses indices individual subclasses balance displayed. call summary() request balance displayed subclasses (setting un = FALSE suppress balance original sample): can plot standardized mean differences Love plot also displays balance subclasses using plot.summary.matchit() summary.matchit() object subclass = TRUE.  Note variables, groups balanced aggregate (black dots), individual subclasses (gray numbers) may balanced, case unadjusted effect estimates within subclasses interpreted unbiased. plot distributional balance using plot.matchit(), can choose whether balance displayed aggregate within subclasses using subclass option, functions summary.matchit(). demonstrate checking balance within subclass.  set subclass = FALSE, plots displayed aggregate using subclassification weights. subclass unspecified, prompt ask us subclass want see balance.","code":"#Subclassification on a logistic regression PS s.out <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75, data = lalonde,                  method = \"subclass\", subclass = 4) s.out ## A `matchit` object ##  - method: Subclassification (4 subclasses) ##  - distance: Propensity score ##              - estimated with logistic regression ##  - number of obs.: 614 (original), 614 (matched) ##  - target estimand: ATT ##  - covariates: age, educ, race, married, nodegree, re74, re75 summary(s.out) ##  ## Call: ## matchit(formula = treat ~ age + educ + race + married + nodegree +  ##     re74 + re75, data = lalonde, method = \"subclass\", subclass = 4) ##  ## Summary of Balance for All Data: ##            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max ## distance           0.577         0.182           1.794      0.921     0.377    0.644 ## age               25.816        28.030          -0.309      0.440     0.081    0.158 ## educ              10.346        10.235           0.055      0.496     0.035    0.111 ## raceblack          0.843         0.203           1.762          .     0.640    0.640 ## racehispan         0.059         0.142          -0.350          .     0.083    0.083 ## racewhite          0.097         0.655          -1.882          .     0.558    0.558 ## married            0.189         0.513          -0.826          .     0.324    0.324 ## nodegree           0.708         0.597           0.245          .     0.111    0.111 ## re74            2095.574      5619.237          -0.721      0.518     0.225    0.447 ## re75            1532.055      2466.484          -0.290      0.956     0.134    0.288 ##  ## Summary of Balance Across Subclasses ##            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max ## distance           0.577         0.539           0.173      0.678     0.062    0.126 ## age               25.816        24.975           0.118      0.465     0.085    0.297 ## educ              10.346        10.433          -0.043      0.582     0.023    0.061 ## raceblack          0.843         0.767           0.210          .     0.076    0.076 ## racehispan         0.059         0.042           0.076          .     0.018    0.018 ## racewhite          0.097         0.191          -0.318          .     0.094    0.094 ## married            0.189         0.196          -0.017          .     0.007    0.007 ## nodegree           0.708         0.657           0.113          .     0.051    0.051 ## re74            2095.574      2557.709          -0.095      0.968     0.048    0.264 ## re75            1532.055      1490.040           0.013      1.505     0.035    0.146 ##  ## Sample Sizes: ##               Control Treated ## All             429.      185 ## Matched (ESS)   102.3     185 ## Matched         429.      185 ## Unmatched         0.        0 ## Discarded         0.        0 summary(s.out, subclass = TRUE, un = FALSE) ##  ## Call: ## matchit(formula = treat ~ age + educ + race + married + nodegree +  ##     re74 + re75, data = lalonde, method = \"subclass\", subclass = 4) ##  ## Summary of Balance by Subclass: ##  ## - Subclass 1 ##            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max ## distance           0.239         0.095           0.879      2.494     0.313    0.508 ## age               26.478        28.800          -0.345      0.394     0.090    0.160 ## educ              10.304        10.214           0.040      0.620     0.025    0.084 ## raceblack          0.370         0.063           0.635          .     0.307    0.307 ## racehispan         0.239         0.167           0.169          .     0.072    0.072 ## racewhite          0.391         0.770          -0.776          .     0.379    0.379 ## married            0.370         0.589          -0.455          .     0.219    0.219 ## nodegree           0.587         0.584           0.007          .     0.003    0.003 ## re74            5430.539      6363.913          -0.118      1.298     0.087    0.284 ## re75            2929.039      2699.399           0.054      1.587     0.047    0.144 ##  ## - Subclass 2 ##            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max ## distance           0.604         0.612          -0.214      0.905     0.083    0.195 ## age               25.556        24.409           0.152      0.461     0.114    0.370 ## educ               9.933         9.773           0.066      0.448     0.084    0.188 ## raceblack          1.000         1.000           0.000          .     0.000    0.000 ## racehispan         0.000         0.000           0.000          .     0.000    0.000 ## racewhite          0.000         0.000           0.000          .     0.000    0.000 ## married            0.378         0.091           0.592          .     0.287    0.287 ## nodegree           0.667         0.500           0.354          .     0.167    0.167 ## re74            1777.422      2516.589          -0.219      0.433     0.076    0.280 ## re75             972.344      1131.077          -0.100      0.666     0.034    0.086 ##  ## - Subclass 3 ##            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max ## distance           0.693         0.691           0.130      1.281     0.055    0.189 ## age               24.021        22.964           0.158      0.509     0.128    0.281 ## educ              10.170        10.286          -0.069      1.040     0.038    0.099 ## raceblack          1.000         1.000           0.000          .     0.000    0.000 ## racehispan         0.000         0.000           0.000          .     0.000    0.000 ## racewhite          0.000         0.000           0.000          .     0.000    0.000 ## married            0.021         0.107          -0.595          .     0.086    0.086 ## nodegree           0.681         0.750          -0.148          .     0.069    0.069 ## re74             939.969       888.947           0.020      2.038     0.059    0.216 ## re75            1217.455      1285.387          -0.018      1.535     0.038    0.188 ##  ## - Subclass 4 ##            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max ## distance           0.767         0.753           0.540      2.961     0.165    0.445 ## age               27.213        23.786           0.461      0.521     0.150    0.459 ## educ              10.957        11.429          -0.341      0.701     0.059    0.126 ## raceblack          1.000         1.000           0.000          .     0.000    0.000 ## racehispan         0.000         0.000           0.000          .     0.000    0.000 ## racewhite          0.000         0.000           0.000          .     0.000    0.000 ## married            0.000         0.000           0.000          .     0.000    0.000 ## nodegree           0.894         0.786           0.350          .     0.108    0.108 ## re74             291.783       540.618          -0.307      0.917     0.083    0.280 ## re75            1015.289       854.751           0.079      3.523     0.112    0.266 ##  ## Sample Sizes by Subclass: ##           1  2  3  4 All ## Control 365 22 28 14 429 ## Treated  46 45 47 47 185 ## Total   411 67 75 61 614 s <- summary(s.out, subclass = TRUE) plot(s, var.order = \"unmatched\", abs = FALSE) plot(s.out, type = \"density\", which.xs = ~educ + married + re75,      subclass = 1)"},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"assessing-balance-with-cobalt","dir":"Articles","previous_headings":"","what":"Assessing Balance with cobalt","title":"Assessing Balance","text":"cobalt package designed specifically checking balance matching (weighting). offers three main functions, bal.tab(), love.plot(), bal.plot(), perform similar actions summary.matchit(), plot.summary.matchit(), plot.matchit(), respectively. functions directly interface matchit objects, making cobalt straightforward use conjunction MatchIt. cobalt can used complement MatchIt, especially advanced uses accommodated MatchIt, comparing balance across different matching schemes even different packages, assessing balance clustered multiply imputed data, assessing balance multi-category, continuous, time-varying treatments. main cobalt vignette (vignette(\"cobalt\", package = \"cobalt\")) contains many examples use MatchIt objects, provide short demonstration capabilities .","code":"library(\"cobalt\")"},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"bal-tab","dir":"Articles","previous_headings":"Assessing Balance with cobalt","what":"bal.tab()","title":"Assessing Balance","text":"bal.tab() produces tables balance statistics similar summary.matchit(). columns displayed can customized limit much information displayed isolate desired information. call bal.tab() options specified : output similar summary.matchit(), except balance statistics computed matching (suffix .Un) computed matching (suffix .Adj) table. default, SMDs matching (Diff.Adj) displayed; setting un = TRUE, requested balance statistics matching also displayed, setting stats = c(\"m\", \"v\", \"ks\") requested mean differences, variance ratios, Kolmogorov-Smirnov statistics. balance statistics summary statistics can requested well. One important detail note default binary covariates print raw difference proportion rather standardized mean difference, apparent discrepancy variables bal.tab() summary.matchit() output, though behavior can changed setting binary = \"std\" call bal.tab(). Functionality producing balance statistics additional variables powers interactions covariates available using addl, poly, int options. bal.tab() cobalt functions can produce balance just single matchit object several time, facilitates comparing balance across several matching specifications. example, wanted compare full matching results results nearest neighbor matching without replacement, supply bal.tab(), demonstrate : time, supplied bal.tab() covariates dataset supplied matchit output objects weights argument (extracts matching weights objects). can see full matching yields better balance nearest neighbor matching overall, though balance slightly worse age maried effective sample size lower.","code":"bal.tab(m.out, un = TRUE, stats = c(\"m\", \"v\", \"ks\")) ## Balance Measures ##                 Type Diff.Un V.Ratio.Un KS.Un Diff.Adj V.Ratio.Adj KS.Adj ## distance    Distance   1.794      0.921 0.644    0.004       0.992  0.049 ## age          Contin.  -0.309      0.440 0.158    0.239       0.557  0.341 ## educ         Contin.   0.055      0.496 0.111   -0.016       0.577  0.059 ## race_black    Binary   0.640          . 0.640    0.005           .  0.005 ## race_hispan   Binary  -0.083          . 0.083   -0.005           .  0.005 ## race_white    Binary  -0.558          . 0.558    0.000           .  0.000 ## married       Binary  -0.324          . 0.324    0.059           .  0.059 ## nodegree      Binary   0.111          . 0.111    0.005           .  0.005 ## re74         Contin.  -0.721      0.518 0.447   -0.049       1.036  0.216 ## re75         Contin.  -0.290      0.956 0.288    0.009       2.129  0.238 ##  ## Sample sizes ##                      Control Treated ## All                   429.       185 ## Matched (ESS)          46.31     185 ## Matched (Unweighted)   82.       185 ## Unmatched             347.         0 #Nearest neighbor (NN) matching on the PS m.out2 <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75, data = lalonde)  #Balance on covariates after full and NN matching bal.tab(treat ~ age + educ + race + married +            nodegree + re74 + re75, data = lalonde,          un = TRUE, weights = list(full = m.out, nn = m.out2)) ## Balance Measures ##                Type Diff.Un Diff.full Diff.nn ## age         Contin.  -0.309     0.239   0.072 ## educ        Contin.   0.055    -0.016  -0.129 ## race_black   Binary   0.640     0.005   0.373 ## race_hispan  Binary  -0.083    -0.005  -0.157 ## race_white   Binary  -0.558     0.000  -0.216 ## married      Binary  -0.324     0.059  -0.022 ## nodegree     Binary   0.111     0.005   0.070 ## re74        Contin.  -0.721    -0.049  -0.050 ## re75        Contin.  -0.290     0.009  -0.026 ##  ## Effective sample sizes ##      Control Treated ## All   429.       185 ## full   46.31     185 ## nn    185.       185"},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"love-plot","dir":"Articles","previous_headings":"Assessing Balance with cobalt","what":"love.plot()","title":"Assessing Balance","text":"love.plot() creates Love plot chosen balance statistics. offers many options customization, including shape colors points, variable names displayed, statistics balance displayed. example basic use:  syntax straightforward similar bal.tab(). demonstrate advanced use customizes appearance plot displays balance mean differences also Kolmogorov-Smirnov statistics full matching nearest neighbor matching simultaneously.  love.plot() documentation explains arguments several ones available. See vignette(\"love.plot\", package = \"cobalt\") advanced customization love.plot().","code":"love.plot(m.out, binary = \"std\") love.plot(m.out, stats = c(\"m\", \"ks\"), poly = 2, abs = TRUE,           weights = list(nn = m.out2),           drop.distance = TRUE, thresholds = c(m = .1),           var.order = \"unadjusted\", binary = \"std\",           shapes = c(\"circle filled\", \"triangle\", \"square\"),            colors = c(\"red\", \"blue\", \"darkgreen\"),           sample.names = c(\"Original\", \"Full Matching\", \"NN Matching\"),           position = \"bottom\")"},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"bal-plot","dir":"Articles","previous_headings":"Assessing Balance with cobalt","what":"bal.plot()","title":"Assessing Balance","text":"bal.plot() displays distributional balance single covariate, similar plot.matchit(). default display kernel density plots continuous variables bar graphs categorical variables. can also display eCDF plots histograms. demonstrate uses:    plots help illuminate specific ways covariate distributions differ treatment groups, can aid interpreting balance statistics provided bal.tab() summary.matchit().","code":"#Density plot for continuous variables bal.plot(m.out, var.name = \"educ\", which = \"both\") #Bar graph for categorical variables bal.plot(m.out, var.name = \"race\", which = \"both\") #Mirrored histogram bal.plot(m.out, var.name = \"distance\", which = \"both\",          type = \"histogram\", mirror = TRUE)"},{"path":"https://kosukeimai.github.io/MatchIt/articles/assessing-balance.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Assessing Balance","text":"goal matching achieve covariate balance, similarity covariate distributions treated control groups. Balance assessed matching phase find matching specification works. Balance must also reported write-matching analysis demonstrate readers matching successful. MatchIt cobalt offer suite functions implement best practices balance assessment reporting.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Estimating Effects After Matching","text":"assessing balance deciding matching specification, comes time estimate effect treatment matched sample. effect estimated interpreted depends desired estimand type model used (). addition estimating effects, estimating uncertainty effects critical communicating assessing whether observed effect compatible effect population. guide explains estimate effects various forms matching various outcome types. may situations covered additional methodological research may required, recommended methods can used guide applications. guide structured follows: first, information concepts related effect standard error (SE) estimation presented . , instructions estimate effects SEs described standard case (matching ATT continuous outcome) common circumstances. Finally, recommendations reporting results tips avoid making common mistakes presented.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"identifying-the-estimand","dir":"Articles","previous_headings":"Introduction","what":"Identifying the estimand","title":"Estimating Effects After Matching","text":"effect estimated, estimand must specified clarified. Although aspects estimand depend effect estimated matching also matching method , aspects must considered time effect estimation interpretation. , consider three aspects estimand: population effect meant generalize (target population), effect measure, whether effect marginal conditional. target population. Different matching methods allow estimate effects can generalize different target populations. common estimand matching average treatment effect treated (ATT), average effect treatment receive treatment. estimand estimable matching methods change treated units (.e., weighting discarding units) requested matchit() setting estimand = \"ATT\" (default). average treatment effect population (ATE) average effect treatment population sample random sample. estimand estimable methods allow ATE either discard units sample explicit target full sample balance, MatchIt limited full matching, subclassification, profile matching setting estimand = \"ATE\". treated units discarded (e.g., use common support restrictions, calipers, cardinality matching, [coarsened] exact matching), estimand corresponds neither population ATT population ATE, rather average treatment effect remaining matched sample (ATM), may correspond specific target population. See Greifer Stuart (2021) discussion substantive considerations involved choosing target population estimand. Marginal conditional effects. marginal effect comparison expected potential outcome treatment expected potential outcome control. quantity estimated randomized trials without blocking covariate adjustment particularly useful quantifying overall effect policy population-wide intervention. conditional effect comparison expected potential outcomes treatment groups within strata. useful identifying effect treatment individual patient subset population. Effect measures. outcome types consider continuous, effect measured mean difference; binary, effect measured risk difference (RD), risk ratio (RR), odds ratio (); time--event (.e., survival), effect measured hazard ratio (HR). RR, , HR noncollapsible effect measures, means marginal effect scale (possibly) weighted average conditional effects within strata, even stratum-specific effects magnitude. effect measures, critical distinguish marginal conditional effects different statistical methods target different types effects. mean difference RD collapsible effect measures, methods can used estimate marginal conditional effects. primary focus marginal effects, appropriate effect measures, easily interpretable, require modeling assumptions. “Common Mistakes” section includes examples commonly used methods estimate conditional rather marginal effects used marginal effects desired.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"g-computation","dir":"Articles","previous_headings":"Introduction","what":"G-computation","title":"Estimating Effects After Matching","text":"estimate marginal effects, use method known g-computation (Snowden, Rose, Mortimer 2011) regression estimation (Schafer Kang 2008). involves first specifying model outcome function treatment covariates. , unit, compute predicted values outcome setting treatment status treated, control, leaving us two predicted outcome values unit, estimates potential outcomes treatment level. compute mean estimated potential outcomes across entire sample, leaves us two average estimated potential outcomes. Finally, contrast average estimated potential outcomes (e.g., difference ratio, depending effect measure desired) estimate treatment effect. g-computation matching, additional considerations required. First, take average estimated potential outcomes treatment level, must weighted average incorporates matching weights. Second, want target ATT ATC, estimate potential outcomes treated control group, respectively (though still generate predicted values treatment control). G-computation framework estimating effects matching number advantages approaches. works regardless form outcome model type outcome (e.g., whether linear model used continuous outcome logistic model used binary outcome); difference might average expected potential outcomes contrasted final step. simple cases, estimated effect numerically identical effects estimated using methods; example, covariates included outcome model, g-computation estimate equal difference means t-test coefficient treatment linear model outcome. analytic approximations SEs g-computation estimate, SEs can incorporate pair/subclass membership (described detail ). reasons, use g-computation possible effect estimates, even simpler methods yield estimates. Using single workflow (slight modifications depending context; see ) facilitates implementing best practices regardless choices user makes.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"modeling-the-outcome","dir":"Articles","previous_headings":"Introduction","what":"Modeling the Outcome","title":"Estimating Effects After Matching","text":"goal outcome model generate good predictions use g-computation procedure described . type form outcome model depend outcome type. continuous outcomes, one can use linear model regressing outcome treatment; binary outcomes, one can use generalized linear model , e.g., logistic link; time--event outcomes, one can use Cox proportional hazards model. additional decision make whether () include covariates outcome model. One may ask, use matching going model outcome covariates anyway? Matching reduces dependence effect estimate correct specification outcome model; central thesis Ho et al. (2007). Including covariates outcome model matching several functions: can increase precision effect estimate, reduce bias due residual imbalance, make effect estimate “doubly robust”, means consistent either matching reduces sufficient imbalance covariates outcome model correct. reasons, recommend covariate adjustment matching possible. evidence covariate adjustment helpful covariates standardized mean differences greater .1 (Nguyen et al. 2017), covariates covariates thought highly predictive outcome prioritized treatment effect models can included due sample size constraints. Although many possible ways include covariates (e.g., just main effects interactions, smoothing terms like splines, nonlinear transformations), important engage specification search (.e., trying many outcomes models search “best” one). can invalidate results yield conclusion fails replicate. reason, recommend including terms included propensity score model unless strong priori justifiable reason model outcome differently. important interpret coefficients tests covariates outcome model. causal effects estimates may severely confounded. treatment effect estimate can interpreted causal assuming relevant assumptions unconfoundedness met. Inappropriately interpreting coefficients covariates outcome model known Table 2 fallacy (Westreich Greenland 2013). avoid , display results g-computation procedure examine interpret outcome models .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"estimating-standard-errors-and-confidence-intervals","dir":"Articles","previous_headings":"Introduction","what":"Estimating Standard Errors and Confidence Intervals","title":"Estimating Effects After Matching","text":"Uncertainty estimation (.e., SEs, confidence intervals, p-values) may consider variety sources uncertainty present analysis, including (limited !) estimation propensity score (used), matching (.e., treated units might matched different control units others sampled), estimation treatment effect (.e., sampling error). general, analytic solutions issues, much research done uncertainty estimation matching relied simulation studies. two primary methods shown perform well matched samples using cluster-robust SEs bootstrap, described . compute SEs g-computation, method known delta method used; way compute SEs derived quantities (expected potential outcomes contrast) variance coefficients outcome models. nonlinear models (e.g., logistic regression), delta method approximation subject error (though many cases error small shrinks large samples). delta method relies variance coefficients outcome model, important correctly estimate variances, using either robust cluster-robust methods described .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"robust-and-cluster-robust-standard-errors","dir":"Articles","previous_headings":"Introduction > Estimating Standard Errors and Confidence Intervals","what":"Robust and Cluster-Robust Standard Errors","title":"Estimating Effects After Matching","text":"Robust standard errors. Also known sandwich SEs (due form formula computing ), heteroscedasticity-consistent SEs, Huber-White SEs, robust SEs adjustment usual maximum likelihood ordinary least squares SEs robust violations assumptions required usual SEs valid (MacKinnon White 1985). Although debate utility (King Roberts 2015), robust SEs rarely degrade inferences often improve . Generally, robust SEs must used non-uniform weights included estimation (e.g., matching replacement inverse probability weighting). Cluster-robust standard errors. version robust SEs known cluster-robust SEs (Liang Zeger 1986) can used account dependence observations within clusters (e.g., matched pairs). Abadie Spiess (2019) demonstrate analytically cluster-robust SEs generally valid matching, whereas regular robust SEs can - -estimate true sampling variability effect estimator depending specification outcome model () degree effect modification. plethora simulation studies confirmed validity cluster-robust SEs matching (e.g., Austin 2009, 2013a; Austin Small 2014; Gayat et al. 2012; Wan 2019). Given evidence favoring use cluster-robust SEs, recommend cases use judiciously guide1.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"bootstrapping","dir":"Articles","previous_headings":"Introduction > Estimating Standard Errors and Confidence Intervals","what":"Bootstrapping","title":"Estimating Effects After Matching","text":"One problem using robust cluster-robust SEs along delta method delta method approximation, previously mentioned. One solution problem bootstrapping, technique used simulate sampling distribution estimator repeatedly drawing samples replacement estimating effect bootstrap sample (Efron Tibshirani 1993). bootstrap distribution, SEs confidence intervals can computed several ways, including using standard deviation bootstrap estimates SE estimate using 2.5 97.5 percentiles 95% confidence interval bounds. Bootstrapping tends useful analytic estimator SE possible derived yet. Although Abadie Imbens (2008) found analytically bootstrap inappropriate matched samples, simulation evidence found adequate many cases (Hill Reiter 2006; Austin Small 2014; Austin Stuart 2017). Typically, bootstrapping involves performing entire estimation process bootstrap sample, including propensity score estimation, matching, effect estimation. tends straightforward route, though intervals method may conservative cases (.e., wider necessary achieve nominal coverage) (Austin Small 2014). Less conservative accurate intervals found using different forms bootstrap, including wild bootstrap develop Bodory et al. (2020) matched/cluster bootstrap described Austin Small (2014) Abadie Spiess (2019). cluster bootstrap involves sampling matched pairs/strata units matched sample performing analysis within sample composed sampled pairs. Abadie Spiess (2019) derived analytically cluster bootstrap valid estimating SEs confidence intervals circumstances cluster robust SEs ; indeed, cluster bootstrap SE known approximate cluster-robust SE (Cameron Miller 2015). bootstrapping, bootstrap replications always better can take time increase chances least one error occur within bootstrap analysis (e.g., bootstrap sample zero treated units zero units event). general, numbers replications upwards 999 recommended, values one less multiple 100 preferred avoid interpolation using percentiles confidence interval limits (MacKinnon 2006). several methods computing bootstrap confidence intervals, bias-corrected accelerated (BCa) bootstrap confidence interval often performs best (Austin Small 2014; Carpenter Bithell 2000) easy implement, simply setting type = \"bca\" call boot::boot.ci() running boot::boot()2. guide consider analytic (.e., non-bootstrapping) approaches estimating uncertainty; section “Using Bootstrapping Estimate Confidence Intervals” describes broadly use bootstrapping. Although analytic estimates faster compute, many cases bootstrap confidence intervals accurate.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"estimating-treatment-effects-and-standard-errors-after-matching","dir":"Articles","previous_headings":"","what":"Estimating Treatment Effects and Standard Errors After Matching","title":"Estimating Effects After Matching","text":", describe effect estimation matching. ’ll using simulated toy dataset d several outcome types. Code generate dataset end document. focus evaluating methods simply demonstrating . cases, correct propensity score model used. display first six rows d: treatment variable, X1 X9 covariates, Y_C continuous outcome, Y_B binary outcome, Y_S survival outcome. need following packages perform desired analyses: marginaleffects provides avg_comparisons() function performing g-computation estimating SEs confidence intervals average estimate potential outcomes treatment effects sandwich used internally marginaleffects compute robust cluster-robust SEs survival provides coxph() estimate coefficients Cox-proportional hazards model marginal hazard ratio, use survival outcomes. course, also need MatchIt perform matching. effect estimates computed using marginaleffects::avg_comparions(), even use may superfluous (e.g., performing t-test matched set). previously mentioned, useful single workflow works matter situation, perhaps slight modifications accommodate different contexts. Using avg_comparions() several advantages, even alternatives simple: provides effect estimate, coefficients; automatically incorporates robust cluster-robust SEs requested; always produces average marginal effects correct population requested. packages may use used . alternatives marginaleffects package computing average marginal effects, including margins stdReg. survey package can used estimate robust SEs incorporating weights provides functions survey-weighted generalized linear models Cox-proportional hazards models.","code":"head(d) ##   A      X1      X2      X3       X4 X5      X6      X7      X8       X9      Y_C Y_B     Y_S ## 1 0  0.1725 -1.4283 -0.4103 -2.36059  1 -1.1199  0.6398 -0.4840 -0.59385  0.07104   0  278.46 ## 2 0 -1.0959  0.8463  0.2456 -0.12333  1 -2.2687 -1.4491 -0.5514 -0.31439  0.15619   0  330.63 ## 3 0  0.1768  0.7905 -0.8436  0.82366  1 -0.2221  0.2971 -0.6966 -0.69516 -0.85180   1  369.94 ## 4 0 -0.4595  0.1726  1.9542 -0.62661  1 -0.4019 -0.8294 -0.5384  0.20729 -2.35184   0   91.06 ## 5 1  0.3563 -1.8121  0.8135 -0.67189  1 -0.8297  1.7297 -0.6439 -0.02648  0.68058   0  182.73 ## 6 0 -2.4313 -1.7984 -1.2940  0.04609  1 -1.2419 -1.1252 -1.8659 -0.56513 -5.62260   0 2563.73 library(\"MatchIt\") library(\"marginaleffects\")"},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"the-standard-case","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching","what":"The Standard Case","title":"Estimating Effects After Matching","text":"almost matching methods, whether caliper, common support restriction, exact matching specification, kk:1 matching specification used, estimating effect matched dataset straightforward involves fitting model outcome incorporates matching weights3, estimating treatment effect using g-computation (.e., using marginaleffects::avg_comparisons()) cluster-robust SE account pair membership. procedure continuous binary outcomes without covariates. adjustments need made certain scenarios, describe section “Adjustments Standard Case”. adjustments include following cases: matching ATE rather ATT, matching replacement, matching method doesn’t involve creating pairs (e.g., cardinality profile matching coarsened exact matching), subclassification, estimating effects binary outcomes, estimating effects survival outcomes. must read Standard Case understand basic procedure reading special scenarios. , demonstrate faster analytic approach estimating confidence intervals; bootstrap approach, see section “Using Bootstrapping Estimate Confidence Intervals” . First, perform variable-ratio nearest neighbor matching without replacement propensity score ATT. Remember, matching methods use exact procedure slight variation, section critical even using different matching method. Typically one assess balance ensure matching specification works, skip step focus effect estimation. See vignette(\"MatchIt\") vignette(\"assessing-balance\") information necessary step. use caliper, target estimand ATT. perform analyses using matched dataset, md, , matching methods involve dropping units, contains units retained sample. First, fit model outcome given treatment (optionally) covariates. ’s usually good idea include treatment-covariate interactions, , always necessary, especially excellent balance achieved. can also include propensity score (usually labeled distance match_data() output), can add robustness, especially modeled flexibly (e.g., polynomial terms splines) (Austin 2017); see example. Next, use marginaleffects::avg_comparisons() estimate ATT. Let’s break call avg_comparisons(): first argument, supply model fit, fit1; variables argument, name treatment (\"\"); vcov argument, formula subclass membership (~subclass) request cluster-robust SEs; newdata argument, version matched dataset containing treated units (subset(== 1)) request ATT. arguments differ depending specifics matching method outcome type; see sections information. , addition effect estimate, want average estimated potential outcomes, can use marginaleffects::avg_predictions(), demonstrate . Note interpretation resulting estimates expected potential outcomes valid covariates present outcome model () interacted treatment. can see difference potential outcome means equal average treatment effect computed previously4. arguments avg_predictions() avg_comparisons().","code":"#Variable-ratio NN matching on the PS for the ATT mV <- matchit(A ~ X1 + X2 + X3 + X4 + X5 +                  X6 + X7 + X8 + X9,               data = d,               ratio = 2,               max.controls = 4) mV ## A `matchit` object ##  - method: Variable ratio 2:1 nearest neighbor matching without replacement ##  - distance: Propensity score ##              - estimated with logistic regression ##  - number of obs.: 2000 (original), 1323 (matched) ##  - target estimand: ATT ##  - covariates: X1, X2, X3, X4, X5, X6, X7, X8, X9 #Extract matched data md <- match_data(mV)  head(md) ##    A      X1      X2      X3      X4 X5      X6      X7      X8       X9      Y_C Y_B    Y_S distance weights subclass ## 1  0  0.1725 -1.4283 -0.4103 -2.3606  1 -1.1199  0.6398 -0.4840 -0.59385  0.07104   0 278.46  0.08461     0.5      365 ## 3  0  0.1768  0.7905 -0.8436  0.8237  1 -0.2221  0.2971 -0.6966 -0.69516 -0.85180   1 369.94  0.22210     0.5       42 ## 5  1  0.3563 -1.8121  0.8135 -0.6719  1 -0.8297  1.7297 -0.6439 -0.02648  0.68058   0 182.73  0.43291     1.0        1 ## 7  0  1.8402  1.7601 -1.0746 -1.6428  1  1.4482  0.7131  0.6972 -0.94673  4.28651   1  97.49  0.09274     0.5        6 ## 9  0  0.7808  1.3137  0.6580  0.8540  1  0.9495 -0.5731 -0.2362 -0.14580 15.89771   1  67.53  0.15751     0.5      218 ## 10 1 -0.5651 -0.1053 -0.1369  1.6233  1 -0.5304 -0.3342  0.4184  0.46308  1.07888   1 113.70  0.16697     1.0        2 #Linear model with covariates fit1 <- lm(Y_C ~ A * (X1 + X2 + X3 + X4 + X5 +                          X6 + X7 + X8 + X9),            data = md,            weights = weights) avg_comparisons(fit1,                 variables = \"A\",                 vcov = ~subclass,                 newdata = subset(A == 1)) ##  ##  Estimate Std. Error    z Pr(>|z|)    S 2.5 % 97.5 % ##      2.02      0.303 6.67   <0.001 35.2  1.43   2.62 ##  ## Term: A ## Type:  response  ## Comparison: 1 - 0 ## Columns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted avg_predictions(fit1,                 variables = \"A\",                 vcov = ~subclass,                 newdata = subset(A == 1)) ##  ##  A Estimate Std. Error     z Pr(>|z|)     S 2.5 % 97.5 % ##  0     1.87      0.206  9.06   <0.001  62.8  1.47   2.27 ##  1     3.89      0.235 16.56   <0.001 202.1  3.43   4.35 ##  ## Type:  response  ## Columns: A, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high"},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"adjustments-to-the-standard-case","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching","what":"Adjustments to the Standard Case","title":"Estimating Effects After Matching","text":"section explains procedure might differ following special circumstances occur.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"matching-for-the-ate","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching > Adjustments to the Standard Case","what":"Matching for the ATE","title":"Estimating Effects After Matching","text":"matching ATE (including [coarsened] exact matching, full matching, subclassification, cardinality matching), everything identical Standard Case except calls avg_comparisons() avg_predictions(), newdata argument omitted. estimated potential outcomes computed full sample rather just treated units.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"matching-with-replacement","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching > Adjustments to the Standard Case","what":"Matching with replacement","title":"Estimating Effects After Matching","text":"matching replacement (.e., nearest neighbor genetic matching replace = TRUE), effect SE estimation need account control unit multiplicity (.e., repeated use) within-pair correlations (Hill Reiter 2006; Austin Cafri 2020). Although Abadie Imbens (2008) demonstrated analytically bootstrap SEs may invalid matching replacement, simulation work Hill Reiter (2006) Bodory et al. (2020) found bootstrap SEs adequate generally slightly conservative. See section “Using Bootstrapping Estimate Confidence Intervals” instructions using bootstrap example use matching replacement. control units belong unique pairs, pair membership match_data() output. One can simply change vcov = ~subclass vcov = \"HC3\" calls avg_comparisons() avg_predictions() use robust SEs instead cluster-robust SEs, recommended Hill Reiter (2006). evidence alternative approach incorporates pair membership adjusts reuse control units, though studied survival outcomes (Austin Cafri 2020). adjustment involves using two-way cluster-robust SEs pair membership unit ID clustering variables. continuous binary outcomes, involves following two changes: 1) replace match_data() get_matches(), produces dataset one row per unit per pair, meaning control units matched multiple treated units appear multiple times dataset; 2) set vcov = ~subclass + id calls avg_comparisons() avg_predictions(). survival outcomes, special procedure must used; see section survival outcomes .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"matching-without-pairing","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching > Adjustments to the Standard Case","what":"Matching without pairing","title":"Estimating Effects After Matching","text":"matching methods involve creating pairs; include cardinality profile matching mahvars = NULL (default), exact matching, coarsened exact matching k2k = FALSE (default). change needs made Standard Case one change vcov = ~subclass vcov = \"HC3\" calls avg_comparisons() avg_predictions() use robust SEs instead cluster-robust SEs. Remember matching done ATE (even units dropped), newdata argument dropped.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"propensity-score-subclassification","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching > Adjustments to the Standard Case","what":"Propensity score subclassification","title":"Estimating Effects After Matching","text":"two natural ways estimate marginal effects subclassification: first estimate subclass-specific treatment effects pool using average marginal effects procedure, second use stratum weights estimate single average marginal effect. latter approach also known marginal mean weighting stratification (MMWS), described detail Hong (2010)5. done properly, methods yield similar identical estimates treatment effect. methods described Standard Case also work MMWS formation weights ; difference appropriate use cluster-robust SEs MMWS clusters present, one change vcov = ~subclass vcov = \"HC3\" calls avg_comparisons() avg_predictions() use robust SEs instead cluster-robust SEs. subclasses can optionally included outcome model (optionally interacting treatment) alternative including propensity score. subclass-specific approach omits weights uses subclasses directly. appropriate small number subclasses relative sample size. outcome model, subclass interact predictors model (including treatment, covariates, interactions, ), weights argument omitted. MMWS, one change vcov = ~subclass vcov = \"HC3\" calls avg_comparisons() avg_predictions(). See example : model fewer terms may required subclasses small; removing covariates interactions treatment may required can increase precision smaller datasets. Remember subclassification done ATE (even units dropped), newdata argument dropped.","code":"#Subclassification on the PS for the ATT mS <- matchit(A ~ X1 + X2 + X3 + X4 + X5 +                  X6 + X7 + X8 + X9,               data = d,               method = \"subclass\",               estimand = \"ATT\")  #Extract matched data md <- match_data(mS)  fitS <- lm(Y_C ~ subclass * (A * (X1 + X2 + X3 + X4 + X5 +                                      X6 + X7 + X8 + X9)),            data = md)  avg_comparisons(fitS,                 variables = \"A\",                 vcov = \"HC3\",                 newdata = subset(A == 1)) ##  ##  Estimate Std. Error    z Pr(>|z|)    S 2.5 % 97.5 % ##      1.65      0.364 4.54   <0.001 17.4  0.94   2.37 ##  ## Term: A ## Type:  response  ## Comparison: 1 - 0 ## Columns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted"},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"binary-outcomes","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching > Adjustments to the Standard Case","what":"Binary outcomes","title":"Estimating Effects After Matching","text":"Estimating effects binary outcomes essentially continuous outcomes. main difference several measures effect one can consider, include odds ratio (), risk ratio/relative risk (RR), risk difference (RD), syntax avg_comparisons() depends one desired. outcome model one appropriate binary outcomes (e.g., logistic regression) unrelated desired effect measure can compute effect measures using avg_comparisons() logistic regression. fit logistic regression model, change lm() glm() set family = quasibinomial()6. compute marginal RD, can use exactly syntax Standard Case; nothing needs change7. compute marginal RR, need add comparison = \"lnratioavg\" avg_comparisons(); computes marginal log RR. get marginal RR, need add transform = \"exp\" avg_comparisons(), exponentiates marginal log RR confidence interval. code computes effects displays statistics interest: output displays marginal RR, Z-value, p-value Z-test log RR 0, confidence interval. (Note even though Contrast label still suggests log RR, RR actually displayed.) view log RR standard error, omit transform argument. marginal , thing needs change comparison set \"lnoravg\". marginal RD, comparison transform arguments can removed (yielding call standard case).","code":"#Logistic regression model with covariates fit2 <- glm(Y_B ~ A * (X1 + X2 + X3 + X4 + X5 +                           X6 + X7 + X8 + X9),             data = md,             weights = weights,             family = quasibinomial())  #Compute effects; RR and confidence interval avg_comparisons(fit2,                 variables = \"A\",                 vcov = ~subclass,                 newdata = subset(A == 1),                 comparison = \"lnratioavg\",                 transform = \"exp\") ##  ##  Estimate Pr(>|z|)    S 2.5 % 97.5 % ##      1.57   <0.001 52.0  1.41   1.75 ##  ## Term: A ## Type:  response  ## Comparison: ln(mean(1) / mean(0)) ## Columns: term, contrast, estimate, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted"},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"survival-outcomes","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching > Adjustments to the Standard Case","what":"Survival outcomes","title":"Estimating Effects After Matching","text":"several measures effect size survival outcomes. using Cox proportional hazards model, quantity interest hazard ratio (HR) treated control groups. , HR non-collapsible, means estimated HR valid estimate marginal HR covariates included model. effect measures, difference mean survival times probability survival given time, can treated just like continuous binary outcomes previously described. HR, compute average marginal effects must use coefficient treatment Cox model fit without covariates8. means use procedures Standard Case. describe estimating marginal HR using coxph() survival package. (See help(\"coxph\", package = \"survival\") information model.) request cluster-robust SEs recommended Austin (2013b), need supply pair membership (stored subclass column md) cluster argument set robust = TRUE. matching methods don’t involve pairing (e.g., cardinality profile matching [coarsened] exact matching), can omit cluster argument (keep robust = TRUE)9. coef column contains log HR, exp(coef) contains HR. Remember always use robust se SE log HR. displayed z-test p-value results using robust SE. matching replacement, special procedure described Austin Cafri (2020) can necessary valid inference. According results simulation studies, treatment prevalence low (<30%), SE involve pair membership (.e., match_data() approach, demonstrated ) sufficient. treatment prevalence higher, SE ignores pair membership may low, authors recommend using custom SE estimator uses information multiplicity pairing. must done manually survival models using get_matches() several calls coxph() demonstrated appendix Austin Cafri (2020). demonstrate : robust se column contains computed SE, reported Z-test uses SE. se(coef) column ignored.","code":"library(\"survival\")  #Cox Regression for marginal HR coxph(Surv(Y_S) ~ A,       data = md,       robust = TRUE,        weights = weights,       cluster = subclass) ## Call: ## coxph(formula = Surv(Y_S) ~ A, data = md, weights = weights,  ##     robust = TRUE, cluster = subclass) ##  ##   coef exp(coef) se(coef) robust se  z      p ## A 0.45      1.57     0.05      0.04 12 <2e-16 ##  ## Likelihood ratio test=63  on 1 df, p=2e-15 ## n= 2000, number of events= 2000 #get_matches() after matching with replacement gm <- get_matches(mR)  #Austin & Cafri's (2020) SE estimator fs <- coxph(Surv(Y_S) ~ A, data = gm, robust = TRUE,              weights = weights, cluster = subclass) Vs <- fs$var ks <- nlevels(gm$subclass)  fi <- coxph(Surv(Y_S) ~ A, data = gm, robust = TRUE,              weights = weights, cluster = id) Vi <- fi$var ki <- length(unique(gm$id))  fc <- coxph(Surv(Y_S) ~ A, data = gm, robust = TRUE,              weights = weights) Vc <- fc$var kc <- nrow(gm)  #Compute the variance and sneak it back into the fit object fc$var <- (ks/(ks-1))*Vs + (ki/(ki-1))*Vi - (kc/(kc-1))*Vc  fc"},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"using-bootstrapping-to-estimate-confidence-intervals","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching","what":"Using Bootstrapping to Estimate Confidence Intervals","title":"Estimating Effects After Matching","text":"bootstrap alternative delta method estimating confidence intervals estimated effects. See section Bootstrapping details. , ’ll demonstrate two forms bootstrap: 1) standard bootstrap, involve resampling units performing matching effect estimation within bootstrap sample, 2) cluster bootstrap, involves resampling pairs matching estimating effect bootstrap sample. , use functionality boot package. critical set seed using set.seed() prior performing bootstrap order results replicable.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"the-standard-bootstrap","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching > Using Bootstrapping to Estimate Confidence Intervals","what":"The standard bootstrap","title":"Estimating Effects After Matching","text":"standard bootstrap, need function takes original dataset vector sampled unit indices returns estimated quantity interest. function perform matching bootstrap sample, fit outcome model, estimate treatment effect using g-computation. example, ’ll use matching replacement, since standard bootstrap found work well (Bodory et al. 2020; Hill Reiter 2006), despite analytic results recommending otherwise (Abadie Imbens 2008). ’ll implement g-computation manually rather using avg_comparisons(), dramatically improves speed estimation since don’t require standard errors estimated sample (processing avg_comparisons() ). ’ll consider marginal RR ATT binary outcome Y_B. first step write estimation function, call boot_fun. function returns marginal RR. , perform matching, estimate effect, return estimate interest. Next, call boot::boot() function original dataset supplied perform bootstrapping. ’ll request 199 bootstrap replications , practice use many , upwards 999. always better. Using also allows use bias-corrected accelerated (BCa) bootstrap confidence intervals (can request setting type = \"bca\" call boot.ci()), known accurate. See ?boot.ci details. , ’ll just use percentile confidence interval. find RR 1.347 confidence interval (1.144, 1.891). wanted risk difference, changed final line boot_fun() Ep1 - Ep0.","code":"boot_fun <- function(data, i) {   boot_data <- data[i,]      #Do 1:1 PS matching with replacement   m <- matchit(A ~ X1 + X2 + X3 + X4 + X5 +                   X6 + X7 + X8 + X9,                data = boot_data,                replace = TRUE)      #Extract matched dataset   md <- match_data(m, data = boot_data)      #Fit outcome model   fit <- glm(Y_B ~ A * (X1 + X2 + X3 + X4 + X5 +                            X6 + X7 + X8 + X9),              data = md, weights = weights,              family = quasibinomial())      ## G-computation ##   #Subset to treated units for ATT; skip for ATE   md1 <- subset(md, A == 1)      #Estimated potential outcomes under treatment   p1 <- predict(fit, type = \"response\",                 newdata = transform(md1, A = 1))   Ep1 <- mean(p1)      #Estimated potential outcomes under control   p0 <- predict(fit, type = \"response\",                 newdata = transform(md1, A = 0))   Ep0 <- mean(p0)      #Risk ratio   Ep1 / Ep0 } library(\"boot\") set.seed(54321) boot_out <- boot(d, boot_fun, R = 199)  boot_out ##  ## ORDINARY NONPARAMETRIC BOOTSTRAP ##  ##  ## Call: ## boot(data = d, statistic = boot_fun, R = 199) ##  ##  ## Bootstrap Statistics : ##     original  bias    std. error ## t1*    1.347  0.1417      0.1937 boot.ci(boot_out, type = \"perc\") ## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS ## Based on 199 bootstrap replicates ##  ## CALL :  ## boot.ci(boot.out = boot_out, type = \"perc\") ##  ## Intervals :  ## Level     Percentile      ## 95%   ( 1.144,  1.891 )   ## Calculations and Intervals on Original Scale ## Some percentile intervals may be unstable"},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"the-cluster-bootstrap","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching > Using Bootstrapping to Estimate Confidence Intervals","what":"The cluster bootstrap","title":"Estimating Effects After Matching","text":"cluster bootstrap, need function takes vector subclass (e.g., pairs) vector sampled pair indices returns estimated quantity interest. function fit outcome model estimate treatment effect using g-computation, matching step occurs prior bootstrap. , ’ll use matching without replacement, since cluster bootstrap found work well (Austin Small 2014; Abadie Spiess 2019). used method returns pair membership, including pair matching methods without replacement full matching. , ’ll use g-computation estimate marginal RR ATT, ’ll manually rather using avg_comparisons() speed. Note cluster bootstrap already much faster standard bootstrap matching need occur within bootstrap sample. First, ’ll round matching. Next, ’ll write function takes cluster membership sampled indices returns estimate. Next, call boot::boot() function vector pair membership supplied perform bootstrapping. ’ll request 199 bootstrap replications, practice use many , upwards 999. always better. Using also allows use bias-corrected accelerated (BCa) boot strap confidence intervals, known accurate. See ?boot.ci details. , ’ll just use percentile confidence interval. find RR 1.588 confidence interval (1.356, 1.857). wanted risk difference, changed final line cluster_boot_fun() Ep1 - Ep0.","code":"mNN <- matchit(A ~ X1 + X2 + X3 + X4 + X5 +                   X6 + X7 + X8 + X9, data = d) mNN ## A `matchit` object ##  - method: 1:1 nearest neighbor matching without replacement ##  - distance: Propensity score ##              - estimated with logistic regression ##  - number of obs.: 2000 (original), 882 (matched) ##  - target estimand: ATT ##  - covariates: X1, X2, X3, X4, X5, X6, X7, X8, X9 md <- match_data(mNN) #Unique pair IDs pair_ids <- levels(md$subclass)  #Unit IDs, split by pair membership split_inds <- split(seq_len(nrow(md)), md$subclass)  cluster_boot_fun <- function(pairs, i) {      #Extract units corresponding to selected pairs   ids <- unlist(split_inds[pairs[i]])      #Subset md with block bootstrapped indices   boot_md <- md[ids,]      #Fit outcome model   fit <- glm(Y_B ~ A * (X1 + X2 + X3 + X4 + X5 +                            X6 + X7 + X8 + X9),              data = boot_md, weights = weights,              family = quasibinomial())      ## G-computation ##   #Subset to treated units for ATT; skip for ATE   md1 <- subset(boot_md, A == 1)      #Estimated potential outcomes under treatment   p1 <- predict(fit, type = \"response\",                 newdata = transform(md1, A = 1))   Ep1 <- mean(p1)      #Estimated potential outcomes under control   p0 <- predict(fit, type = \"response\",                 newdata = transform(md1, A = 0))   Ep0 <- mean(p0)      #Risk ratio   Ep1 / Ep0 } library(\"boot\") set.seed(54321) cluster_boot_out <- boot(pair_ids, cluster_boot_fun,                          R = 199)  cluster_boot_out ##  ## ORDINARY NONPARAMETRIC BOOTSTRAP ##  ##  ## Call: ## boot(data = pair_ids, statistic = cluster_boot_fun, R = 199) ##  ##  ## Bootstrap Statistics : ##     original   bias    std. error ## t1*    1.588 0.001319      0.1265 boot.ci(cluster_boot_out, type = \"perc\") ## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS ## Based on 199 bootstrap replicates ##  ## CALL :  ## boot.ci(boot.out = cluster_boot_out, type = \"perc\") ##  ## Intervals :  ## Level     Percentile      ## 95%   ( 1.356,  1.857 )   ## Calculations and Intervals on Original Scale ## Some percentile intervals may be unstable"},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"moderation-analysis","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching","what":"Moderation Analysis","title":"Estimating Effects After Matching","text":"Moderation analysis involves determining whether treatment effect differs across levels another variable. use matching moderation analysis described Green Stuart (2014). goal achieve balance within subgroup potential moderating variable, several ways . Broadly, one can either perform matching full dataset, requiring exact matching moderator, one can perform completely separate analyses subgroup. ’ll demonstrate first approach ; see blog post “Subgroup Analysis Propensity Score Matching Using R” Noah Greifer example approach. benefits using either approach, Green Stuart (2014) find either can successful balancing subgroups. first approach may effective small samples, separate propensity score models fit greater uncertainty increased possibility perfect prediction failure converge (Wang et al. 2018). second approach may effective larger samples matching methods target balance matched sample, genetic matching (Kreif et al. 2012). genetic matching, separate subgroup analyses ensure balance optimized within subgroup rather just overall. chosen approach achieves best balance, though don’t demonstrate assessing balance maintain focus effect estimation. full dataset approach involves pooling information across subgroups. involve estimating propensity scores using single model groups exact matching potential moderator. propensity score model include moderator--covariate interactions allow propensity score model vary across subgroups covariates. critical exact matching done moderator matched pairs split across subgroups. ’ll consider binary variable X5 potential moderator effect Y_C. , ’ll estimate propensity score using single propensity score model moderator--covariate interactions. ’ll perform nearest neighbor matching propensity score exact matching moderator, X5. Although straightforward assess balance overall using summary(), challenging assess balance within subgroups. easiest way check subgroup balance use cobalt::bal.tab(), cluster argument can used assess balance within subgroups, e.g., cobalt::bal.tab(mP, cluster = \"X5\"). See vignette “Appendix 2: Using cobalt Clustered, Multiply Imputed, Segmented Data” cobalt website details. satisfied balance, can model outcome interaction treatment moderator. estimate subgroup ATTs, can use avg_comparisons(), time specifying argument signify want treatment effects stratified moderator. can see subgroup mean differences quite similar . Finally, can test moderation using another call avg_comparisons(), time using hypothesis argument signify want compare effects subgroups: expected, difference subgroup treatment effects small nonsignificant, evidence moderation X5.","code":"mP <- matchit(A ~ X1 + X2 + X5*X3 + X4 +                  X5*X6 + X7 + X5*X8 + X9,               data = d,               exact = ~X5) mP ## A `matchit` object ##  - method: 1:1 nearest neighbor matching without replacement ##  - distance: Propensity score ##              - estimated with logistic regression ##  - number of obs.: 2000 (original), 882 (matched) ##  - target estimand: ATT ##  - covariates: X1, X2, X5, X3, X4, X6, X7, X8, X9 mdP <- match_data(mP)  fitP <- lm(Y_C ~ A * X5, data = mdP, weights = weights) avg_comparisons(fitP,                 variables = \"A\",                 vcov = ~subclass,                 newdata = subset(A == 1),                 by = \"X5\") ##  ##  Term X5 Estimate Std. Error    z Pr(>|z|)    S 2.5 % 97.5 % ##     A  0     2.21      0.670 3.29   <0.001 10.0 0.894   3.52 ##     A  1     2.18      0.569 3.83   <0.001 12.9 1.065   3.29 ##  ## Type:  response  ## Comparison: 1 - 0 ## Columns: term, contrast, X5, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high avg_comparisons(fitP,                 variables = \"A\",                 vcov = ~subclass,                 newdata = subset(A == 1),                 by = \"X5\",                 hypothesis = \"pairwise\") ##  ##   Term Estimate Std. Error      z Pr(>|z|)   S 2.5 % 97.5 % ##  0 - 1   0.0275      0.879 0.0313    0.975 0.0  -1.7   1.75 ##  ## Type:  response  ## Columns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high"},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"reporting-results","dir":"Articles","previous_headings":"Estimating Treatment Effects and Standard Errors After Matching","what":"Reporting Results","title":"Estimating Effects After Matching","text":"important thorough complete possible describing methods estimating treatment effect results analysis. improves transparency replicability analysis. Results least include following: description outcome model used (e.g., logistic regression, linear model treatment-covariate interactions covariates, Cox proportional hazards model matching weights applied) way effect estimated (e.g., using g-computation coefficient outcome model) way SEs confidence intervals estimated (e.g., using robust SEs, using cluster-robust SEs pair membership cluster, using BCa bootstrap 4999 bootstrap replications entire process matching effect estimation included replication) R packages functions used estimating effect SE (e.g., glm() base R, avg_comparisons() marginaleffects, boot() boot.ci() boot) effect SE confidence interval addition information matching method, propensity score estimation procedure (used), balance assessment, etc. mentioned vignettes.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"common-mistakes","dir":"Articles","previous_headings":"","what":"Common Mistakes","title":"Estimating Effects After Matching","text":"common mistakes avoided. important avoid mistakes one’s research also able spot mistakes others’ analyses.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"failing-to-include-weights","dir":"Articles","previous_headings":"Common Mistakes","what":"1. Failing to include weights","title":"Estimating Effects After Matching","text":"Several methods involve weights used estimating treatment effect. full matching stratification matching (analyzed using MMWS), weights entire work balancing covariates across treatment groups. Omitting weights essentially ignores entire purpose matching. cases less obvious. performing matching replacement estimating treatment effect using match_data() output, weights must included ensure control units matched multiple treated units weighted accordingly. Similarly, performing k:1 matching treated units receive k matches, weights required account differential weight matched control units. time weights can omitted pair matching performing 1:1 matching without replacement. Including weights even scenario affect analysis can good practice always include weights prevent error occurring. scenarios weights useful conditioning occurs means, using direct subclass strategy rather MMWS estimating marginal effects stratification.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"failing-to-use-robust-or-cluster-robust-standard-errors","dir":"Articles","previous_headings":"Common Mistakes","what":"2. Failing to use robust or cluster-robust standard errors","title":"Estimating Effects After Matching","text":"Robust SEs required using weights estimate treatment effect. model-based SEs resulting weighted least squares maximum likelihood inaccurate using matching weights assume weights frequency weights rather probability weights. Cluster-robust SEs account matching weights pair membership used appropriate. Sometimes, researchers use functions survey package estimate robust SEs, especially inverse probability weighting; valid way compute robust SEs give similar results sandwich::vcovHC().10","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"interpreting-conditional-effects-as-marginal-effects","dir":"Articles","previous_headings":"Common Mistakes","what":"3. Interpreting conditional effects as marginal effects","title":"Estimating Effects After Matching","text":"distinction marginal conditional effects always clear methodological applied papers. statistical methods valid estimating conditional effects used estimate marginal effects (without modification). Sometimes conditional effects desirable, methods may useful , marginal effects target inference, critical inappropriately interpret estimates resulting statistical methods aimed estimating conditional effects marginal effects. Although issue particularly salient binary survival outcomes due general noncollapsibility , RR, HR, can also occur linear models continuous outcomes RD. following methods estimate conditional effects binary survival outcomes (noncollapsible effect measures) used estimate marginal effects: Logistic regression Cox proportional hazards model covariates /propensity score included, using coefficient treatment effect estimate Conditional logistic regression matching (e.g., using survival::clogit()) Stratified Cox regression matching (e.g., using survival::coxph() strata() model formula) Averaging stratum-specific effect estimates stratification, including using Mantel-Haenszel pooling Including pair stratum fixed random effects logistic regression model, using coefficient treatment effect estimate addition, continuous outcomes, conditional effects can mistakenly interpreted marginal effect estimates treatment-covariate interactions present outcome model. covariates centered mean target population (e.g., treated group ATT, full sample ATE, remaining matched sample ATM), coefficient treatment correspond marginal effect target population; correspond effect treatment covariate values equal zero, may meaningful plausible. G-computation always safest way estimate effects including covariates outcome model, especially presence treatment-covariate interactions.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html","id":"code-to-generate-data-used-in-examples","dir":"Articles","previous_headings":"","what":"Code to Generate Data used in Examples","title":"Estimating Effects After Matching","text":"","code":"#Generating data similar to Austin (2009) for demonstrating treatment effect estimation gen_X <- function(n) {   X <- matrix(rnorm(9 * n), nrow = n, ncol = 9)   X[,5] <- as.numeric(X[,5] < .5)   X }  #~20% treated gen_A <- function(X) {   LP_A <- - 1.2 + log(2)*X[,1] - log(1.5)*X[,2] + log(2)*X[,4] - log(2.4)*X[,5] + log(2)*X[,7] - log(1.5)*X[,8]   P_A <- plogis(LP_A)   rbinom(nrow(X), 1, P_A) }  # Continuous outcome gen_Y_C <- function(A, X) {   2*A + 2*X[,1] + 2*X[,2] + 2*X[,3] + 1*X[,4] + 2*X[,5] + 1*X[,6] + rnorm(length(A), 0, 5) } #Conditional: #  MD: 2 #Marginal: #  MD: 2  # Binary outcome gen_Y_B <- function(A, X) {   LP_B <- -2 + log(2.4)*A + log(2)*X[,1] + log(2)*X[,2] + log(2)*X[,3] + log(1.5)*X[,4] + log(2.4)*X[,5] + log(1.5)*X[,6]   P_B <- plogis(LP_B)   rbinom(length(A), 1, P_B) } #Conditional: #  OR:   2.4 #  logOR: .875 #Marginal: #  RD:    .144 #  RR:   1.54 #  logRR: .433 #  OR:   1.92 #  logOR  .655  # Survival outcome gen_Y_S <- function(A, X) {   LP_S <- -2 + log(2.4)*A + log(2)*X[,1] + log(2)*X[,2] + log(2)*X[,3] + log(1.5)*X[,4] + log(2.4)*X[,5] + log(1.5)*X[,6]   sqrt(-log(runif(length(A)))*2e4*exp(-LP_S)) } #Conditional: #  HR:   2.4 #  logHR: .875 #Marginal: #  HR:   1.57 #  logHR: .452  set.seed(19599)  n <- 2000 X <- gen_X(n) A <- gen_A(X)  Y_C <- gen_Y_C(A, X) Y_B <- gen_Y_B(A, X) Y_S <- gen_Y_S(A, X)  d <- data.frame(A, X, Y_C, Y_B, Y_S)"},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Matching Methods","text":"MatchIt implements several matching methods variety options. Though help pages individual methods describes method can used, vignette provides broad overview available matching methods associated options. choice matching method depends goals analysis (e.g., estimand, whether low bias high precision important) unique qualities dataset analyzed, single optimal choice given analysis. benefit nonparametric preprocessing matching number matching methods can tried quality assessed without consulting outcome, reducing possibility capitalizing chance allowing benefits exploratory analysis design phase (Ho et al. 2007). vignette describes matching method available MatchIt various options allowed matching methods consequences use. brief introduction use MatchIt functions, see vignette(\"MatchIt\"). details assess report covariate balance, see vignette(\"assessing-balance\"). details estimate treatment effects standard errors matching, see vignette(\"estimating-effects\").","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"matching","dir":"Articles","previous_headings":"","what":"Matching","title":"Matching Methods","text":"Matching implemented MatchIt form subset selection, , pruning weighting units arrive (weighted) subset units original dataset. Ideally, done successfully, subset selection produces new sample treatment unassociated covariates comparison outcomes treatment control groups confounded measured balanced covariates. Although statistical estimation methods like regression can also used remove confounding due measured covariates, Ho et al. (2007) argue fitting regression models matched samples reduces dependence validity estimated treatment effect correct specification model. Matching nonparametric sense estimated weights pruning sample direct functions estimated model parameters rather depend organization discrete units sample; contrast propensity score weighting (also known inverse probability weighting), weights come directly estimated propensity score model therefore sensitive correct specification. advantages, well intuitive understanding matching public compared regression weighting, make robust effective way estimate treatment effects. important note implementation matching differs methods described Abadie Imbens (2006, 2016) implemented Matching R package teffects routine Stata. form matching matching imputation, missing potential outcomes unit imputed using observed outcomes paired units. critical distinction matching imputation specific estimation method effect standard error estimators, contrast subset selection, preprocessing method require specific estimators broadly compatible parametric nonparametric analyses. benefits matching imputation theoretical properties (.e., rate convergence asymptotic variance estimator) well understood, can used straightforward way estimate just average treatment effect treated (ATT) also average treatment effect population (ATE), additional effective matching methods can used imputation (e.g., kernel matching). benefits matching nonparametric preprocessing far flexible respect types effects can estimated involve specific estimator, empirical finite-sample performance examined depth generally well understood, aligns well design experiments, familiar non-technical audiences. addition subset selection, matching often (though always) involves form stratification, assignment units pairs strata containing multiple units. distinction subset selection stratification described Zubizarreta, Paredes, Rosenbaum (2014a), separate two separate steps. MatchIt, almost matching methods, subset selection performed stratification; example, treated units paired control units, unpaired units dropped matched sample. methods, subclasses used assign matching stratification weights individual units, increase decrease unit’s leverage subsequent analysis. debate importance stratification subset selection; authors argued , forms matching, pair membership incidental (Stuart 2008; Schafer Kang 2008), others argued correctly incorporating pair membership effect estimation can improve quality inferences (Austin Small 2014; Wan 2019). methods allow , MatchIt includes stratum membership additional output matching specification. strata can used detailed vignette(\"estimating-effects\"). heart MatchIt three classes methods: distance matching, stratum matching, pure subset selection. Distance matching involves considering focal group (usually treated group) selecting members non-focal group (.e., control group) pair member focal group based distance units, can computed one several ways. Members either group paired dropped sample. Nearest neighbor matching (method = \"nearest\"), optimal pair matching (method = \"optimal\"), optimal full matching (method = \"full\"), generalized full matching (method = \"quick\"), genetic matching (method = \"genetic\") methods distance matching implemented MatchIt. Typically, average treatment treated (ATT) average treatment control (ATC), control group focal group, can estimated distance matching MatchIt (full matching exception, described later). Stratum matching involves creating strata based unique values covariates assigning units covariate values strata. units strata lack either treated control units dropped sample. Strata can formed using raw covariates (method = \"exact\"), coarsened versions covariates (method = \"cem\"), coarsened versions propensity score (method = \"subclass\"). units discarded, either ATT, ATC, ATE can estimated stratum matching, though often units discarded, especially exact coarsened exact matching, making estimand less clear. use estimating marginal treatment effects exact matching, stratification weights computed matched units first computing new “stratum propensity score” unit, proportion treated units stratum. formulas computing inverse probability weights standard propensity scores applied new stratum propensity scores form new weights. Pure subset selection involves selecting subset units form original sample without considering distance individual units strata units might fall . Subsets selected optimize criterion subject constraint balance remaining sample size. Cardinality profile matching (method = \"cardinality\") methods pure subset selection implemented MatchIt. methods allow user specify largest imbalance allowed resulting matched sample, optimization routine attempts find largest matched sample satisfies balance constraints. cardinality matching target specific estimand, profile matching can used target ATT, ATC, ATE. , describe matching methods implemented MatchIt.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"nearest-neighbor-matching-method-nearest","dir":"Articles","previous_headings":"Matching Methods","what":"Nearest Neighbor Matching (method = \"nearest\")","title":"Matching Methods","text":"Nearest neighbor matching also known greedy matching. involves running list treated units selecting closest eligible control unit paired treated unit. greedy sense pairing occurs without reference units paired, therefore aim optimize criterion. Nearest neighbor matching common form matching used (Thoemmes Kim 2011; Zakrison, Austin, McCredie 2018) extensively studied simulations. See ?method_nearest documentation matchit() method = \"nearest\". Nearest neighbor matching requires specification distance measure define control unit closest treated unit. default common distance propensity score difference, difference propensity scores treated control unit (Stuart 2010). Another popular distance Mahalanobis distance, described section “Mahalanobis distance matching” . order treated units paired must also specified potential change quality matches (Austin 2013; Rubin 1973); specified m.order argument. propensity score matching, default go descending order highest propensity score; allows units hardest time finding close matches matched first (Rubin 1973). orderings possible, including random ordering, can tried multiple times adequate matched sample found. matching replacement (.e., control unit can reused matched number treated units), matching order doesn’t matter. using matching ratio greater 1 (.e., 1 control units requested matched treated unit), matching occurs cycle, treated unit first paired one control unit, treated unit paired second control unit, etc. Ties broken deterministically based order units dataset ensure multiple runs specification yield result (unless matching order requested random). Nearest neighbor matching implemented MatchIt using internal C++ code Rcpp. matching propensity score, makes matching extremely fast, even large datasets. Using caliper propensity score (described ) makes even faster. Run times may bit longer matching distance measures (e.g., Mahalanobis distance). contrast optimal pair matching (described ), nearest neighbor matching require computing full distance matrix units, makes applicable large datasets.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"optimal-pair-matching-method-optimal","dir":"Articles","previous_headings":"Matching Methods","what":"Optimal Pair Matching (method = \"optimal\")","title":"Matching Methods","text":"Optimal pair matching (often just called optimal matching) similar nearest neighbor matching attempts pair treated unit one control units. Unlike nearest neighbor matching, however, “optimal” rather greedy; optimal sense attempts choose matches collectively optimize overall criterion (Hansen Klopfer 2006; Gu Rosenbaum 1993). criterion used sum absolute pair distances matched sample. See ?method_optimal documentation matchit() method = \"optimal\". Optimal pair matching MatchIt depends fullmatch() function optmatch package (Hansen Klopfer 2006). Like nearest neighbor matching, optimal pair matching requires specification distance measure units. Optimal pair matching can thought simply alternative selecting order matching nearest neighbor matching. Optimal pair matching nearest neighbor matching often yield similar matched samples; indeed, research indicated optimal pair matching much better nearest neighbor matching yielding balanced matched samples (Austin 2013). tol argument fullmatch() can supplied matchit() method = \"optimal\"; controls numerical tolerance used determine whether optimal solution found. default fairly high , smaller problems, set much lower (e.g., setting tol = 1e-7).","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"optimal-full-matching-method-full","dir":"Articles","previous_headings":"Matching Methods","what":"Optimal Full Matching (method = \"full\")","title":"Matching Methods","text":"Optimal full matching (often just called full matching) assigns every treated control unit sample one subclass (Hansen 2004; Stuart Green 2008). subclass contains one treated unit one control units one control units one treated units. optimal sense chosen number subclasses assignment units subclasses minimize sum absolute within-subclass distances matched sample. Weights computed based subclass membership, weights function like propensity score weights can used estimate weighted treatment effect, ideally free confounding measured covariates. See ?method_full documentation matchit() method = \"full\". Optimal full matching MatchIt depends fullmatch() function optmatch package (Hansen Klopfer 2006). Like distance matching methods, optimal full matching requires specification distance measure units. can seen combination distance matching stratum matching: subclasses formed varying numbers treated control units, stratum matching, subclasses formed based minimizing within-pair distances involve forming strata based specific variable, similar distance matching. Unlike distance matching methods, full matching can used estimate ATE. Full matching can also seen form propensity score weighting less sensitive form propensity score model original propensity scores used just create subclasses, form weights directly (Austin Stuart 2015a). addition, full matching rely estimated propensity scores form subclasses weights; distance measures allowed well. Although full matching uses available units, loss precision due weights. Units may weighted way contribute less sample unweighted units, effective sample size (ESS) full matching weighted sample may lower even 1:1 pair matching. Balance often far better full matching 1:k matching, making full matching good option consider especially 1:k matching effective ATE target estimand. specification full matching optimization problem can customized supplying additional arguments passed optmatch::fullmatch(), min.controls, max.controls, mean.controls, omit.fraction. optimal pair matching, numerical tolerance value can set much lower default small problems setting, e.g., tol = 1e-7.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"generalized-full-matching-method-quick","dir":"Articles","previous_headings":"Matching Methods","what":"Generalized Full Matching (method = \"quick\")","title":"Matching Methods","text":"Generalized full matching variant full matching uses special fast clustering algorithm dramatically speed matching, even large datasets (Fredrik Sävje, Higgins, Sekhon 2021). Like optimal full matching, generalized full matching assigns every unit subclass. makes generalized full match “generalized” user can customize matching number ways, specifying arbitrary minimum number units treatment group total number units per subclass, allowing units treatment group matched. Generalized full matching minimizes largest within-subclass distances matched sample, way completely optimal (though solution often close optimal solution). Matching weights computed based subclass membership, weights function like propensity score weights can used estimate weighted treatment effect, ideally free confounding measured covariates. See ?method_quick documentation matchit() method = \"quick\". Generalized full matching MatchIt depends quickmatch() function quickmatch package (Fredrik Sävje, Sekhon, Higgins 2018). Generalized full matching includes different options customization optimal full matching. user supply distance matrix, propensity scores distance metrics computed supplied covariates (e.g., Mahalanobis distance) allowed. Calipers can placed propensity score, supplied. optimal full matching, generalized full matching can target ATE. Matching performance tends similar two methods, generalized full matching much quicker can accommodate larger datasets, making good substitute. Generalized full matching often faster even nearest neighbor matching, especially large datasets.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"genetic-matching-method-genetic","dir":"Articles","previous_headings":"Matching Methods","what":"Genetic Matching (method = \"genetic\")","title":"Matching Methods","text":"Genetic matching less specific form matching way specifying distance measure another form matching. practice, though, form matching used nearest neighbor pair matching. Genetic matching uses genetic algorithm, optimization routine used non-differentiable objective functions, find scaling factors variable generalized Mahalanobis distance formula (Diamond Sekhon 2013). criterion optimized algorithm one based covariate balance. scaling factors found, nearest neighbor matching performed scaled generalized Mahalanobis distance. See ?method_genetic documentation matchit() method = \"genetic\". Genetic matching MatchIt depends GenMatch() function Matching package (Sekhon 2011) perform genetic search uses Match() function perform nearest neighbor match using scaled generalized Mahalanobis distance. Genetic matching considers generalized Mahalanobis distance treated unit ii control unit jj δGMD(𝐱i,𝐱j,𝐖)=(𝐱i−𝐱j)′(𝐒−1/2)′𝐖(𝐒−1/2)(𝐱i−𝐱j)\\delta_{GMD}(\\mathbf{x}_i,\\mathbf{x}_j, \\mathbf{W})=\\sqrt{(\\mathbf{x}_i - \\mathbf{x}_j)'(\\mathbf{S}^{-1/2})'\\mathbf{W}(\\mathbf{S}^{-1/2})(\\mathbf{x}_i - \\mathbf{x}_j)} 𝐱\\mathbf{x} p×1p \\times 1 vector containing value pp included covariates unit, 𝐒−1/2\\mathbf{S}^{-1/2} Cholesky decomposition covariance matrix 𝐒\\mathbf{S} covariates, 𝐖\\mathbf{W} diagonal matrix scaling factors ww diagonal: 𝐖=[w1w2⋱wp] \\mathbf{W}=\\begin{bmatrix}     w_1 &  & & \\\\      & w_2 & & \\\\      &  & \\ddots &\\\\      & & & w_p \\\\     \\end{bmatrix} wk=1w_k=1 covariates kk, computed distance standard Mahalanobis distance units. Genetic matching estimates optimal values wkw_ks, user-specified criterion used define optimal. default maximize smallest p-value among balance tests covariates matched sample (Kolmogorov-Smirnov tests t-tests covariate). MatchIt, propensity score specified, default include propensity score covariates 𝐱\\mathbf{x} optimize balance covariates. distance = \"mahalanobis\" mahvars argument specified, propensity score left 𝐱\\mathbf{x}. respects, genetic matching functions just like nearest neighbor matching except matching carried Matching::Match() instead MatchIt. using method = \"genetic\" MatchIt, additional arguments passed Matching::GenMatch() control genetic search process specified; particular, pop.size argument increased default 100 much higher value. make algorithm take time finish generally improve quality resulting matches. Different functions can supplied used objective optimization using fit.func argument.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"exact-matching-method-exact","dir":"Articles","previous_headings":"Matching Methods","what":"Exact Matching (method = \"exact\")","title":"Matching Methods","text":"Exact matching form stratum matching involves creating subclasses based unique combinations covariate values assigning unit corresponding subclass units identical covariate values placed subclass. units subclasses lacking either treated control units dropped. Exact matching powerful matching method functional form assumptions required either treatment outcome model method remove confounding due measured covariates; covariate distributions exactly balanced. problem exact matching general, units remain matching, estimated effect generalize limited population can lack precision. Exact matching particularly ineffective continuous covariates, might two units value, many covariates, might case two units combination covariates; latter problem known “curse dimensionality”. See ?method_exact documentation matchit() method = \"exact\". possible use exact matching covariates another form matching rest. makes possible exact balance covariates (typically categorical) approximate balance others, thereby gaining benefits exact matching matching method used. , matching method specified method argument matchit() exact argument specified contain variables exact matching done.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"coarsened-exact-matching-method-cem","dir":"Articles","previous_headings":"Matching Methods","what":"Coarsened Exact Matching (method = \"cem\")","title":"Matching Methods","text":"Coarsened exact matching (CEM) form stratum matching involves first coarsening covariates creating bins performing exact matching new coarsened versions covariates (Iacus, King, Porro 2012). degree method coarsening can controlled user manage trade-exact approximate balancing. example, coarsening covariate two bins mean units differ greatly covariate might placed subclass, coarsening variable five bins may require units dropped due finding matches. Like exact matching, CEM susceptible curse dimensionality, making less viable solution many covariates, especially units. Dropping units can also change target population estimated effect. See ?method_cem documentation matchit() method = \"cem\". CEM MatchIt depend package perform coarsening matching, though used rely cem package.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"subclassification-method-subclass","dir":"Articles","previous_headings":"Matching Methods","what":"Subclassification (method = \"subclass\")","title":"Matching Methods","text":"Propensity score subclassification can thought form coarsened exact matching propensity score sole covariate coarsened matched . bins usually based specified quantiles propensity score distribution either treated group, control group, overall, depending desired estimand. Propensity score subclassification old well-studied method, though can perform poorly compared , modern propensity score methods full matching weighting (Austin 2010a). See ?method_subclass documentation matchit() method = \"subclass\". binning propensity scores typically based dividing distribution covariates approximately equally sized bins. user specifies number subclasses using subclass argument group used compute boundaries bins using estimand argument. Sometimes, subclasses can end units one treatment groups; default, matchit() moves unit adjacent subclass lacking one ensure subclass least one unit treatment group. minimum number units required subclass can chosen min.n argument matchit(). set 0, error thrown subclass lacks units one treatment groups. Moving units one subclass another generally worsens balance subclasses can increase precision. default number subclasses 6, arbitrary taken recommended value. Although early theory recommended use 5 subclasses, general optimal number subclasses typically much larger 5 varies among datasets (Orihara Hamada 2021). Rather trying figure oneself, one can use optimal full matching (.e., method = \"full\") generalized full matching (method = \"quick\") optimally create subclasses optimize within-subclass distance criterion. output propensity score subclassification includes assigned subclasses subclassification weights. Effects can estimated either within subclass averaged across , single marginal effect can estimated using subclassification weights. latter method called marginal mean weighting subclassification [MMWS; Hong (2010)] fine stratification weighting (Desai et al. 2017). also implemented WeightIt package.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"cardinality-and-profile-matching-method-cardinality","dir":"Articles","previous_headings":"Matching Methods","what":"Cardinality and Profile Matching (method = \"cardinality\")","title":"Matching Methods","text":"Cardinality profile matching pure subset selection methods involve selecting subset original sample without considering distance individual units assigning units pairs subclasses. can thought weighting method weights restricted zero one. Cardinality matching involves finding largest sample satisfies user-supplied balance constraints constraints ratio matched treated matched control units (Zubizarreta, Paredes, Rosenbaum 2014b). consider specific estimand can useful alternative matching caliper handling data little overlap (Visconti Zubizarreta 2018). Profile matching involves identifying target distribution (e.g., full sample ATE treated units ATT) finding largest subset treated control groups satisfy user-supplied balance constraints respect target (Cohn Zubizarreta 2021). See ?method_cardinality documentation using matchit() method = \"cardinality\", including inputs required request either cardinality matching profile matching. Subset selection performed solving mixed integer programming optimization problem linear constraints. problem involves maximizing size matched sample subject constraints balance sample size. cardinality matching, balance constraints refer mean difference covariate matched treated control groups, sample size constraints require matched treated control groups size (differ user-supplied factor). profile matching, balance constraints refer mean difference covariate treatment group target distribution; ATE, requires mean covariate treatment group within given tolerance mean covariate full sample, ATT, requires mean covariate control group within given tolerance mean covariate treated group, left intact. balance tolerances controlled tols std.tols arguments. One can also create pairs matched sample using mahvars argument, requests optimal Mahalanobis matching done subset selection; can add additional precision robustness (Zubizarreta, Paredes, Rosenbaum 2014b). optimization problem requires special solver solve. Currently, available options MatchIt HiGHS solver (highs package), GLPK solver (Rglpk package), SYMPHONY solver (Rsymphony package), Gurobi solver (gurobi package). differences among solvers performance; Gurobi far best (fastest, least likely fail find solution), proprietary (though free trial academic license) bit complicated install. HiGHS default due open source, easily installed, performance comparable Gurobi. designmatch package also provides implementation cardinality matching options MatchIt offers.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"customizing-the-matching-specification","dir":"Articles","previous_headings":"","what":"Customizing the Matching Specification","title":"Matching Methods","text":"addition specific matching method, options available many matching methods customize matching specification. include different specifications distance measure, methods perform alternate forms matching addition main method, prune units far units prior matching, restrict possible matches, etc. options compatible matching methods.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"specifying-the-propensity-score-or-other-distance-measure-distance","dir":"Articles","previous_headings":"Customizing the Matching Specification","what":"Specifying the propensity score or other distance measure (distance)","title":"Matching Methods","text":"distance measure used define close two units . nearest neighbor matching, used choose nearest control unit treated unit. optimal matching, used criterion optimized. default, distance measure propensity score difference, argument supplied distance corresponds method estimating propensity score. MatchIt, propensity scores often labeled “distance” values, even though propensity score distance measure. reflect propensity score used creating distance value, scores used, prognostic scores prognostic score matching (Hansen 2008). propensity score like “position” value, reflects position unit matching space, difference positions distance . argument distance one allowed methods estimating propensity scores (see ?distance values) numeric vector one value per unit, distance units computed pairwise difference propensity scores supplied values. Propensity scores also used propensity score subclassification can optionally used genetic matching component generalized Mahalanobis distance. exact, coarsened exact, cardinality matching, distance argument ignored. default distance argument \"glm\", estimates propensity scores using logistic regression another generalized linear model. link distance.options arguments can supplied specify options propensity score models, including whether use raw propensity score linearized version (e.g., logit logistic regression propensity score, commonly referred recommended propensity score literature (Austin 2011; Stuart 2010)). Allowable options propensity score model include parametric machine learning-based models, strengths limitations may perform differently depending unique qualities dataset. recommend multiple types models tried find one yields best balance, way make single recommendation work cases. distance argument can also specified method computing pairwise distances covariates directly (.e., without estimating propensity scores). options include \"mahalanobis\", \"robust_mahalanobis\", \"euclidean\", \"scaled_euclidean\". methods compute distance metric treated unit ii control unit jj δ(𝐱i,𝐱j)=(𝐱i−𝐱j)′S−1(𝐱i−𝐱j)\\delta(\\mathbf{x}_i,\\mathbf{x}_j)=\\sqrt{(\\mathbf{x}_i - \\mathbf{x}_j)'S^{-1}(\\mathbf{x}_i - \\mathbf{x}_j)} 𝐱\\mathbf{x} p×1p \\times 1 vector containing value pp included covariates unit, SS scaling matrix, S−1S^{-1} (generalized) inverse SS. Mahalanobis distance matching, SS pooled covariance matrix covariates (Rubin 1980); Euclidean distance matching, SS identity matrix (.e., scaling); scaled Euclidean distance matching, SS diagonal pooled covariance matrix (containing just variances). robust Mahalanobis distance computed covariates directly rather ranks uses correction ties (see Rosenbaum (2010), ch 8). creating close pairs, matching distance measures tends work better propensity score matching paired units close values covariates, whereas propensity score-paired units may close propensity score covariates . feature basis King Nielsen’s (2019) warning using propensity scores matching. said, always outperform propensity score matching (Ripollone et al. 2018). distance can also supplied matrix distance values units. makes possible use handcrafted distance matrices distances created outside MatchIt. nearest neighbor, optimal pair, optimal full matching allow specification. propensity score can uses basis matching. can used define region common support, outside units dropped prior matching; implemented discard option. can also used define caliper, maximum distance two units can prohibited paired ; implemented caliper argument. estimate supply propensity score one purposes use distance measure matching (.e., perform Mahalanobis distance matching instead), mahvars argument can specified. options described .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"implementing-common-support-restrictions-discard","dir":"Articles","previous_headings":"Customizing the Matching Specification","what":"Implementing common support restrictions (discard)","title":"Matching Methods","text":"region common support region overlap treatment groups. common support restriction discards units fall outside region common support, preventing matched units included matched sample. can reduce potential extrapolation help matching algorithms avoid overly distant matches occurring. MatchIt, discard option implements common support restriction based propensity score. argument can supplied \"treated\", \"control\", \"\", discards units corresponding group fall outside region common support propensity score. reestimate argument can supplied choose whether re-estimate propensity score remaining units. units treated group discarded based common support restriction, estimand longer corresponds ATT.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"caliper-matching-caliper","dir":"Articles","previous_headings":"Customizing the Matching Specification","what":"Caliper matching (caliper)","title":"Matching Methods","text":"caliper can though ring around unit limits units unit can paired. Calipers based propensity score covariates. Two units whose distance calipered covariate larger caliper width covariate allowed matched . units available matches within caliper dropped matched sample. Calipers ensure paired units close calipered covariates, can ensure good balance matched sample. Multiple variables can supplied caliper enforce calipers simultaneously. Using calipers can good alternative exact coarsened exact matching ensure similar units paired . std.caliper argument controls whether provided calipers raw units standard deviation units. negative calipers supplied, forces units whose distance calipered covariate smaller absolute caliper width covariate disallowed matched . units treated group left unmatched due caliper, estimand longer corresponds ATT.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"mahalanobis-distance-matching-mahvars","dir":"Articles","previous_headings":"Customizing the Matching Specification","what":"Mahalanobis distance matching (mahvars)","title":"Matching Methods","text":"perform Mahalanobis distance matching without need estimate use propensity score, distance argument can set \"mahalanobis\". propensity score estimated used different purpose, common support restriction caliper, still want perform Mahalanobis distance matching, variables supplied mahvars argument. propensity scores generated using distance specification, matching occur covariates supplied main formula matchit() rather covariates supplied mahvars. perform Mahalanobis distance matching within propensity score caliper, example, distance argument set method estimating propensity score (e.g., \"glm\" logistic regression), caliper argument specified desired caliper width, mahvars specified perform Mahalanobis distance matching desired covariates within caliper. mahvars special meaning genetic matching cardinality matching; see respective help pages details.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"exact-matching-exact","dir":"Articles","previous_headings":"Customizing the Matching Specification","what":"Exact matching (exact)","title":"Matching Methods","text":"perform exact matching supplied covariates, method argument can set \"exact\". perform exact matching covariates form matching within exact matching strata covariates, exact argument can used. Covariates supplied exact argument matched exactly, form matching specified method (e.g., \"nearest\" nearest neighbor matching) take place within exact matching stratum. can good way gain benefits exact matching without completely succumbing curse dimensionality. exact matching performed method = \"exact\", units strata lacking members one treatment groups left unmatched. Note although matching occurs within exact matching stratum, propensity score estimation computation Mahalanobis distance matrix occur full sample. units treated group unmatched due exact matching restriction, estimand longer corresponds ATT.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"anti-exact-matching-antiexact","dir":"Articles","previous_headings":"Customizing the Matching Specification","what":"Anti-exact matching (antiexact)","title":"Matching Methods","text":"Anti-exact matching adds restriction treated control unit values specified anti-exact matching variables paired. can useful finding comparison units outside unit’s group, matching units one group units another units within group might otherwise close matches. See examples . similar effect can implemented supplying negative caliper values.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"matching-with-replacement-replace","dir":"Articles","previous_headings":"Customizing the Matching Specification","what":"Matching with replacement (replace)","title":"Matching Methods","text":"Nearest neighbor matching genetic matching option matching without replacement, controlled replace argument. Matching without replacement means control unit matched one treated unit, matching replacement means control units can reused matched multiple treated units. Matching without replacement carries certain statistical benefits weights unit can omitted straightforward include dependence units depends pair membership. However, asymptotically consistent unless propensity scores treated units .5 many control units treated units (F. Sävje 2022). Special standard error estimators sometimes required estimating effects matching replacement (Austin Cafri 2020), methods accounting uncertainty well understood non-continuous outcomes. Matching replacement tend yield better balance though, problem “running ” close control units match treated units avoided, though reuse control units decrease effect sample size, thereby worsening precision (Austin 2013). (problem occurs Lalonde dataset used vignette(\"MatchIt\"), nearest neighbor matching without replacement effective .) matching replacement, control units assigned one subclass, get_matches() function used instead match_data() matching replacement subclasses used follow-analyses; see vignette(\"estimating-effects\") details. reuse.max argument can also used method = \"nearest\" control many times control unit can reused match. Setting reuse.max = 1 equivalent requiring matching without replacement (.e., control can used ). values allow control units matched , though specified number times. Higher values tend improve balance cost precision.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"k1-matching-ratio","dir":"Articles","previous_headings":"Customizing the Matching Specification","what":"kk:1 matching (ratio)","title":"Matching Methods","text":"common form matching, 1:1 matching, involves pairing one control unit treated unit. perform kk:1 matching (e.g., 2:1 3:1), pairs () kk control units treated unit, ratio argument can specified. Performing kk:1 matching can preserve precision preventing many control units unmatched dropped matched sample, though gain precision increasing kk diminishes rapidly 4 (Rosenbaum 2020). Importantly, k>1k>1, matches first match generally worse first match terms closeness treated unit, increasing kk can also worsen balance (Rassen et al. 2012). Austin (2010b) found 1:1 1:2 matching generally performed best terms mean squared error. general, makes sense use higher values kk ensuring balance satisfactory. nearest neighbor optimal pair matching, variable kk:1 matching, number controls matched treated unit varies, can also used; can improved performance “fixed” kk:1 matching (Ming Rosenbaum 2000; Rassen et al. 2012). See ?method_nearest ?method_optimal information implementing variable kk:1 matching.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"matching-order-m-order","dir":"Articles","previous_headings":"Customizing the Matching Specification","what":"Matching order (m.order)","title":"Matching Methods","text":"nearest neighbor matching (including genetic matching), units matched order, order can affect quality individual matches resulting matched sample. method = \"nearest\", allowable options m.order control matching order \"largest\", \"smallest\", \"closest\", \"farthest\", \"random\", \"data\". method = \"genetic\", \"closest\" \"farthest\" can used. Requesting \"largest\" means treated units largest propensity scores, .e., least like control units, matched first, prevents bad matches close control units used . \"smallest\" means treated units smallest propensity scores matched first. \"closest\" means potential pairs smallest distance units matched first, ensures best possible matches included matched sample can yield poor matches units whose best match far ; makes particularly useful matching caliper. \"farthest\" means closest pairs largest distance matched first, ensures hardest units match given best chance find matches. \"random\" matches random order, \"data\" matches order data. propensity score required \"largest\" \"smallest\" options. Rubin (1973) recommends using \"largest\" \"random\", though Austin (2013) recommends \"largest\" instead favors \"closest\" \"random\". \"closest\" \"smallest\" best prioritizing best possible matches, \"farthest\" \"largest\" best preventing extreme pairwise distances matched units.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"choosing-a-matching-method","dir":"Articles","previous_headings":"","what":"Choosing a Matching Method","title":"Matching Methods","text":"Choosing best matching method one’s data depends unique characteristics dataset well goals analysis. example, different matching methods can target different estimands, certain estimands desired, specific methods must used. hand, methods may effective others retaining target estimand less important. provide guidance choosing matching method. Remember multiple methods can () tried long treatment effect estimated method settled . criteria matching specification judged balance remaining (effective) sample size matching. Assessing balance described vignette(\"assessing-balance\"). typical workflow similar demonstrated vignette(\"MatchIt\"): try matching method, yields poor balance unacceptably low remaining sample size, try another, satisfactory specification found. important assess balance broadly (.e., beyond comparing means covariates treated control groups), search matching specification stop threshold reached, attempt come close possible perfect balance (Ho et al. 2007). Even first matching specification appears successful reducing imbalance, may another specification reduce even , thereby increasing robustness inference plausibility unbiased effect estimate. target inference ATE, optimal generalized full matching, subclassification, profile matching can used. target inference ATT ATC, matching method may used. retaining target estimand important, additional options become available involve discarding units way original estimand distorted. include matching caliper, matching within region common support, cardinality matching, exact coarsened exact matching, perhaps subset covariates. exact coarsened exact matching aim balance entire joint distribution covariates, powerful methods. possible perform exact matching, method used. continuous covariates present, coarsened exact matching can tried. Care taken retaining target population ensuring enough matched units remain; unless control pool much larger treated pool, likely (many) treated units discarded, thereby changing estimand possibly dramatically reducing precision. methods typically available optimistic circumstances, used first circumstances arise. may also useful combine exact coarsened exact matching covariates another form matching others (.e., using exact argument). estimating ATE, either subclassification, full matching, profile matching can used. Optimal generalized full matching can effective optimize balance criterion, often leading better balance. full matching, ’s also possible exact match variables match using Mahalanobis distance, eliminating need estimate propensity scores. Profile matching also ensures good balance, units given weights zero one, solution may feasible many units may discarded. large datasets, neither optimal full matching profile matching may possible, case generalized full matching subclassification faster solutions. using subclassification, number subclasses varied. large samples, higher numbers subclasses tend yield better performance; one immediately settle default (6) often-cited recommendation 5 without trying several numbers. documentation cobalt::bal.compute() contains example using balance select optimal number subclasses. estimating ATT, variety methods can tried. Genetic matching can perform well achieving good balance directly optimizes covariate balance. larger datasets, may take long time reach good solution (though solution tend good well). Profile matching also achieve good balance solution feasible balance controlled user. Optimal pair matching nearest neighbor matching without replacement tend perform similarly ; nearest neighbor matching may preferable large datasets handled optimal matching. Nearest neighbor, optimal, genetic matching allow customizations like including covariates exactly match, using Mahalanobis distance instead propensity score difference, performing kk:1 matching k>1k>1. Nearest neighbor matching replacement, full matching, subclassification involve weighting control units nonuniform weights, often allows improved balancing capabilities can accompanied loss effective sample size, even units retained. reason try many methods, varying parameters , search good balance high remaining sample size. previously mentioned, single method can recommended others optimal specification depends unique qualities dataset. target population less important, example, engaging treatment effect discovery sampled population particular interest (e.g., corresponds arbitrarily chosen hospital school; see Mao, Li, Greene (2018) reasons retaining target population may important), methods retain characteristics original sample become available. include matching caliper (propensity score covariates ), cardinality matching, restrictive forms matching like exact coarsened exact matching, either covariates just subset, prone discard units sample way target population changed. Austin (2013) Austin Stuart (2015b, 2015a) found caliper matching can particularly effective modification nearest neighbor matching eliminating imbalance reducing bias target population less relevant, inference specific target population desired, using calipers can induce bias due incomplete matching (Rosenbaum Rubin 1985a; Wang 2020). Cardinality matching can particularly effective data little overlap treatment groups (Visconti Zubizarreta 2018) can perform better caliper matching (de los Angeles Resa Zubizarreta 2020). important rely excessively theoretical simulation-based findings specific recommendations making choices best matching method use. example, although nearest neighbor matching without replacement balance covariates better subclassification five ten subclasses Austin’s (2009) simulation, imply superior datasets. Likewise, though Rosenbaum Rubin (1985b) Austin (2011) recommend using caliper .2 standard deviations logit propensity score, imply caliper optimal scenarios, widths tried, though noted tightening caliper propensity score can sometimes degrade performance (King Nielsen 2019). large datasets (.e., 10,000s millions), matching methods slow used scale. Instead, users consider generalized full matching, subclassification, coarsened exact matching, fast designed work large datasets. Nearest neighbor matching propensity score optimized run quickly large datasets well.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/articles/matching-methods.html","id":"reporting-the-matching-specification","dir":"Articles","previous_headings":"","what":"Reporting the Matching Specification","title":"Matching Methods","text":"reporting results matching analysis, important include relevant details final matching specification process arriving . Using print() matchit object synthesizes information arguments used provide description matching specification. best specific possible ensure analysis replicable allow audiences assess validity. Although citations recommending specific matching methods can used help justify choice, sufficient justification adequate balance remaining sample size, regardless published recommendations specific methods. See vignette(\"assessing-balance\") instructions assess report quality matching specification. matching estimating effect, details effect estimation must included well; see vignette(\"estimating-effects\") instructions perform report analysis matched dataset.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/articles/sampling-weights.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Matching with Sampling Weights","text":"Sampling weights (also known survey weights) frequently appear using large, representative datasets. required ensure estimated quantities generalize target population defined weights. Evidence suggests sampling weights need incorporated propensity score matching analysis obtain valid unbiased estimates treatment effect sampling weighted population (DuGoff, Schuler, Stuart 2014; Austin, Jembere, Chiu 2016; Lenis et al. 2019). guide, demonstrate use sampling weights MatchIt propensity score estimation, balance assessment, effect estimation. Fortunately, complicated, care must taken ensure sampling weights incorporated correctly. assumed one read vignettes explaining matching (vignette(\"matching-methods\")), balance assessment (vignette(\"assessing-balance\")), effect estimation (vignette(\"estimating-effects\"). use simulated toy dataset used vignette(\"estimating-effects\") except addition sampling weights variable, SW, used generalize sample specific target population distribution covariates different sample. Code generate covariates, treatment, outcome bottom vignette(\"estimating-effects\") code generate sampling weights end document. consider effect binary treatment continuous outcome Y_C, adjusting confounders X1-X9.","code":"head(d) ##   A      X1      X2      X3       X4 X5      X6      X7      X8       X9     Y_C     SW ## 1 0  0.1725 -1.4283 -0.4103 -2.36059  1 -1.1199  0.6398 -0.4840 -0.59385 -3.5907  1.675 ## 2 0 -1.0959  0.8463  0.2456 -0.12333  1 -2.2687 -1.4491 -0.5514 -0.31439 -1.5481  1.411 ## 3 0  0.1768  0.7905 -0.8436  0.82366  1 -0.2221  0.2971 -0.6966 -0.69516  6.0714  2.332 ## 4 0 -0.4595  0.1726  1.9542 -0.62661  1 -0.4019 -0.8294 -0.5384  0.20729  2.4906  1.644 ## 5 1  0.3563 -1.8121  0.8135 -0.67189  1 -0.8297  1.7297 -0.6439 -0.02648 -0.6687  2.722 ## 6 0 -2.4313 -1.7984 -1.2940  0.04609  1 -1.2419 -1.1252 -1.8659 -0.56513 -9.8504 14.773 library(\"MatchIt\")"},{"path":"https://kosukeimai.github.io/MatchIt/articles/sampling-weights.html","id":"matching","dir":"Articles","previous_headings":"","what":"Matching","title":"Matching with Sampling Weights","text":"using sampling weights propensity score matching, one option including sampling weights model used estimate propensity scores. Although evidence mixed whether required (Austin, Jembere, Chiu 2016; Lenis et al. 2019), can good idea. choice depend whether including sampling weights improves quality matches. Specifications including excluding sampling weights tried determine preferred. supply sampling weights propensity score-estimating function matchit(), sampling weights variable supplied s.weights argument. can supplied either numerical vector containing sampling weights, string one-sided formula name sampling weights variable supplied dataset. demonstrate including sampling weights propensity scores estimated using logistic regression optimal full matching average treatment effect population (ATE) (note methods steps apply way forms matching estimands). Note: optmatch, marginaleffects, sandwich packages available, subsequent lines run. Notice description matching specification matchit object printed includes lines indicating sampling weights included estimation propensity score present matchit object. stored s.weights component matchit object. Note stage, matching weights (stored weights component matchit object) incorporate sampling weights; calculated simply result matching. Now let’s perform full matching propensity score include sampling weights estimation. use specification used vignette(\"estimating-effects\"). Notice mention sampling weights description matching specification. However, properly assess balance estimate effects, need sampling weights included matchit object, even used matching. , use function add_s.weights(), adds sampling weights supplied matchit objects. Now print matchit object, can see lines added identifying sampling weights present used estimation propensity score used matching. Note methods can involve sampling weights estimation. methods use propensity score affected sampling weights; coarsened exact matching Mahalanobis distance optimal pair matching, example, ignore sampling weights, propensity score estimation methods, like randomForest bart (presently implemented), incorporate sampling weights. Sampling weights still supplied matchit() even using methods avoid use add_s.weights() remembering methods involve sampling weights.","code":"mF_s <- matchit(A ~ X1 + X2 + X3 + X4 + X5 +                    X6 + X7 + X8 + X9, data = d,                 method = \"full\", distance = \"glm\",                 estimand = \"ATE\", s.weights = ~SW) mF_s ## A `matchit` object ##  - method: Optimal full matching ##  - distance: Propensity score ##              - estimated with logistic regression ##              - sampling weights included in estimation ##  - number of obs.: 2000 (original), 2000 (matched) ##  - sampling weights: present ##  - target estimand: ATE ##  - covariates: X1, X2, X3, X4, X5, X6, X7, X8, X9 mF <- matchit(A ~ X1 + X2 + X3 + X4 + X5 +                  X6 + X7 + X8 + X9, data = d,               method = \"full\", distance = \"glm\",               estimand = \"ATE\") mF ## A `matchit` object ##  - method: Optimal full matching ##  - distance: Propensity score ##              - estimated with logistic regression ##  - number of obs.: 2000 (original), 2000 (matched) ##  - target estimand: ATE ##  - covariates: X1, X2, X3, X4, X5, X6, X7, X8, X9 mF <- add_s.weights(mF, ~SW)  mF ## A `matchit` object ##  - method: Optimal full matching ##  - distance: Propensity score ##              - estimated with logistic regression ##              - sampling weights not included in estimation ##  - number of obs.: 2000 (original), 2000 (matched) ##  - sampling weights: present ##  - target estimand: ATE ##  - covariates: X1, X2, X3, X4, X5, X6, X7, X8, X9"},{"path":"https://kosukeimai.github.io/MatchIt/articles/sampling-weights.html","id":"assessing-balance","dir":"Articles","previous_headings":"","what":"Assessing Balance","title":"Matching with Sampling Weights","text":"Now need decide matching specification best use effect estimation. selecting one yields best balance without sacrificing remaining effective sample size. sampling weights incorporated matchit object, balance assessment tools plot.matchit() summary.matchit() incorporate output. ’ll use summary() examine balance two matching specifications. sampling weights included, balance statistics unmatched data weighted sampling weights. balance statistics matched data weighted product sampling weights matching weights. product weights used estimating treatment effect. use summary() display balance two matching specifications. additional arguments summary() required use sampling weights; long matchit object (either due supplied s.weights argument call matchit() added afterward add_s.weights()), correctly incorporated balance statistics. results two matching specifications similar. Balance appears slightly better using sampling weight-estimated propensity scores using unweighted propensity scores. However, effective sample size control group larger using unweighted propensity scores. Neither propensity score specification achieves excellent balance, fiddling matching specification (e.g., changing method estimating propensity scores, type matching, options used matching) might yield better matched set. purposes analysis, move forward matching used sampling weight-estimated propensity scores (mF_s) superior balance. remaining imbalance may eliminated adjusting covariates outcome model. Note added sampling weights mF, matching specification include sampling weights, balance assessment inaccurate balance statistics include sampling weights. case, fact, assessing balance mF without incorporated sampling weights yielded radically different results different conclusion. critical incorporate sampling weights matchit object using add_s.weights() even included propensity score estimation.","code":"#Balance before matching and for the SW propensity score full matching summary(mF_s) ##  ## Call: ## matchit(formula = A ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 +  ##     X9, data = d, method = \"full\", distance = \"glm\", estimand = \"ATE\",  ##     s.weights = ~SW) ##  ## Summary of Balance for All Data: ##          Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max ## distance         0.470         0.225           1.200      1.533     0.281    0.467 ## X1               0.185        -0.120           0.287      1.309     0.105    0.171 ## X2              -0.565        -0.202          -0.368      0.854     0.108    0.194 ## X3              -0.059        -0.057          -0.003      0.739     0.041    0.083 ## X4               0.852         0.150           0.680      1.016     0.180    0.293 ## X5               0.567         0.713          -0.307          .     0.146    0.146 ## X6               0.169        -0.008           0.171      1.014     0.048    0.103 ## X7               0.378        -0.089           0.474      1.205     0.130    0.210 ## X8              -0.376        -0.142          -0.216      1.190     0.071    0.129 ## X9               0.088        -0.001           0.090      0.945     0.027    0.066 ##  ## Summary of Balance for Matched Data: ##          Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max Std. Pair Dist. ## distance         0.310         0.292           0.087      1.011     0.025    0.061           0.007 ## X1               0.091        -0.025           0.109      1.089     0.047    0.104           0.955 ## X2              -0.310        -0.282          -0.028      1.030     0.014    0.061           1.067 ## X3              -0.095        -0.016          -0.084      0.647     0.046    0.104           1.126 ## X4               0.297         0.334          -0.036      1.127     0.022    0.064           0.899 ## X5               0.660         0.669          -0.020          .     0.009    0.009           0.842 ## X6               0.028         0.061          -0.031      1.065     0.024    0.065           1.123 ## X7               0.147         0.028           0.120      1.130     0.027    0.062           1.050 ## X8              -0.225        -0.226           0.001      1.137     0.014    0.052           1.010 ## X9               0.015         0.034          -0.019      1.192     0.020    0.066           1.164 ##  ## Sample Sizes: ##               Control Treated ## All (ESS)       987.1   177.1 ## All            1559.    441.  ## Matched (ESS)   513.3   175.3 ## Matched        1559.    441.  ## Unmatched         0.      0.  ## Discarded         0.      0. #Balance for the non-SW propensity score full matching summary(mF, un = FALSE) ##  ## Call: ## matchit(formula = A ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 +  ##     X9, data = d, method = \"full\", distance = \"glm\", estimand = \"ATE\") ##  ## Summary of Balance for Matched Data: ##          Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max Std. Pair Dist. ## distance         0.282         0.276           0.033      0.970     0.021    0.070           0.009 ## X1              -0.182         0.020          -0.190      1.253     0.046    0.110           0.948 ## X2              -0.324        -0.255          -0.070      1.015     0.033    0.101           1.147 ## X3              -0.062        -0.073           0.012      0.661     0.048    0.081           1.112 ## X4               0.503         0.280           0.217      1.136     0.058    0.143           0.962 ## X5               0.663         0.672          -0.018          .     0.009    0.009           0.817 ## X6               0.062        -0.016           0.075      1.021     0.027    0.053           1.121 ## X7               0.026         0.038          -0.013      1.059     0.017    0.056           0.984 ## X8              -0.312        -0.221          -0.085      1.260     0.019    0.080           0.988 ## X9              -0.032         0.036          -0.070      0.881     0.032    0.107           1.101 ##  ## Sample Sizes: ##               Control Treated ## All (ESS)       987.1   177.1 ## All            1559.    441.  ## Matched (ESS)   582.5   108.6 ## Matched        1559.    441.  ## Unmatched         0.      0.  ## Discarded         0.      0."},{"path":"https://kosukeimai.github.io/MatchIt/articles/sampling-weights.html","id":"estimating-the-effect","dir":"Articles","previous_headings":"","what":"Estimating the Effect","title":"Matching with Sampling Weights","text":"Estimating treatment effect matching straightforward using sampling weights. Effects estimated way sampling weights excluded, except matching weights must multiplied sampling weights use outcome model yield accurate, generalizable estimates. match_data() get_matches() automatically, weights produced functions already product matching weights sampling weights. Note true sampling weights incorporated matchit object. avg_comparisons(), sampling weights included estimating treatment effect. estimate effect Y_C matched sampling weighted sample, adjusting covariates improve precision decrease bias. Note match_data() get_weights() option include.s.weights, , set FALSE, makes returned weights incorporate sampling weights simply matching weights. one might forget multiply two sets weights together, easier just use default include.s.weights = TRUE ignore sampling weights rest analysis (already included returned weights).","code":"md_F_s <- match_data(mF_s)  fit <- lm(Y_C ~ A * (X1 + X2 + X3 + X4 + X5 +               X6 + X7 + X8 + X9), data = md_F_s,           weights = weights)  library(\"marginaleffects\") avg_comparisons(fit,                 variables = \"A\",                 vcov = ~subclass,                 newdata = subset(A == 1),                 wts = \"SW\") ##  ##  Estimate Std. Error    z Pr(>|z|)    S 2.5 % 97.5 % ##      1.83       0.39 4.69   <0.001 18.5  1.06   2.59 ##  ## Term: A ## Type:  response  ## Comparison: 1 - 0 ## Columns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted"},{"path":"https://kosukeimai.github.io/MatchIt/articles/sampling-weights.html","id":"code-to-generate-data-used-in-examples","dir":"Articles","previous_headings":"","what":"Code to Generate Data used in Examples","title":"Matching with Sampling Weights","text":"","code":"#Generatng data similar to Austin (2009) for demonstrating  #treatment effect estimation with sampling weights gen_X <- function(n) {   X <- matrix(rnorm(9 * n), nrow = n, ncol = 9)   X[,5] <- as.numeric(X[,5] < .5)   X }  #~20% treated gen_A <- function(X) {   LP_A <- - 1.2 + log(2)*X[,1] - log(1.5)*X[,2] + log(2)*X[,4] - log(2.4)*X[,5] +      log(2)*X[,7] - log(1.5)*X[,8]   P_A <- plogis(LP_A)   rbinom(nrow(X), 1, P_A) }  # Continuous outcome gen_Y_C <- function(A, X) {   2*A + 2*X[,1] + 2*X[,2] + 2*X[,3] + 1*X[,4] + 2*X[,5] + 1*X[,6] + rnorm(length(A), 0, 5) } #Conditional: #  MD: 2 #Marginal: #  MD: 2  gen_SW <- function(X) {   e <- rbinom(nrow(X), 1, .3)   1/plogis(log(1.4)*X[,2] + log(.7)*X[,4] + log(.9)*X[,6] + log(1.5)*X[,8] + log(.9)*e +              -log(.5)*e*X[,2] + log(.6)*e*X[,4]) }  set.seed(19599)  n <- 2000 X <- gen_X(n) A <- gen_A(X) SW <- gen_SW(X)  Y_C <- gen_Y_C(A, X)  d <- data.frame(A, X, Y_C, SW)"},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel Ho. Author. Kosuke Imai. Author. Gary King. Author. Elizabeth Stuart. Author. Alex Whitworth. Contributor. Noah Greifer. Maintainer, author.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ho D, Imai K, King G, Stuart E (2011). “MatchIt: Nonparametric Preprocessing Parametric Causal Inference.” Journal Statistical Software, 42(8), 1–28. doi:10.18637/jss.v042.i08.","code":"@Article{,   title = {{MatchIt}: Nonparametric Preprocessing for Parametric Causal Inference},   author = {Daniel E. Ho and Kosuke Imai and Gary King and Elizabeth A. Stuart},   year = {2011},   journal = {Journal of Statistical Software},   volume = {42},   number = {8},   pages = {1--28},   doi = {10.18637/jss.v042.i08}, }"},{"path":[]},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Nonparametric Preprocessing for Parametric Causal Inference","text":"MatchIt provides simple straightforward interface various methods matching covariate balance observational studies. Matching one way reduce confounding model dependence estimating treatment effects. Several matching methods available, including nearest neighbor matching, optimal pair matching, optimal full matching, generalized full matching, genetic matching, exact matching, coarsened exact matching, cardinality matching, subclassification, rely functions R packages. variety methods estimate propensity scores propensity score matching included. example use MatchIt perform Mahalanobis distance matching replacement assess balance: Printing MatchIt object provides details kind matching performed. can check covariate balance original matched samples using summary(): top balance original sample. balance matched sample. Smaller values balance statistics indicate better balance. (case, fairly good balance achieved, matching methods tried). can plot standardized mean differences Love plot clean, visual display balance across sample:  Although much written matching theory, theory relied upon MatchIt described well Ho, Imai, King, Stuart (2007), Stuart (2010), Greifer Stuart (2021). Journal Statistical Software article MatchIt can accessed , though note options changed, MatchIt reference pages included vignettes used understanding functions methods available. references individual methods present respective help pages. MatchIt website provides access vignettes documentation files.","code":"library(\"MatchIt\") data(\"lalonde\", package = \"MatchIt\")  # 1:1 nearest neighbor matching with replacement on  # the Mahalanobis distance m.out <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75,                   data = lalonde, distance = \"mahalanobis\",                  replace = TRUE) m.out #> A `matchit` object #>  - method: 1:1 nearest neighbor matching with replacement #>  - distance: Mahalanobis - number of obs.: 614 (original), 264 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, married, nodegree, re74, re75 #Checking balance before and after matching: summary(m.out) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + married + nodegree +  #>     re74 + re75, data = lalonde, distance = \"mahalanobis\", replace = TRUE) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max #> age              25.8162       28.0303         -0.3094     0.4400    0.0813   0.1577 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347   0.1114 #> raceblack         0.8432        0.2028          1.7615          .    0.6404   0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827   0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577   0.5577 #> married           0.1892        0.5128         -0.8263          .    0.3236   0.3236 #> nodegree          0.7081        0.5967          0.2450          .    0.1114   0.1114 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248   0.4470 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342   0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max Std. Pair Dist. #> age              25.8162       25.5405          0.0385     0.6531    0.0466   0.1892          0.4827 #> educ             10.3459       10.4270         -0.0403     1.1649    0.0077   0.0378          0.1963 #> raceblack         0.8432        0.8432          0.0000          .    0.0000   0.0000          0.0000 #> racehispan        0.0595        0.0595          0.0000          .    0.0000   0.0000          0.0000 #> racewhite         0.0973        0.0973          0.0000          .    0.0000   0.0000          0.0000 #> married           0.1892        0.1784          0.0276          .    0.0108   0.0108          0.0276 #> nodegree          0.7081        0.7081          0.0000          .    0.0000   0.0000          0.0000 #> re74           2095.5737     1788.6941          0.0628     1.5707    0.0311   0.1730          0.2494 #> re75           1532.0553     1087.7420          0.1380     2.1244    0.0330   0.0865          0.2360 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   34.19     185 #> Matched         79.       185 #> Unmatched      350.         0 #> Discarded        0.         0 #Plot balance plot(summary(m.out))"},{"path":"https://kosukeimai.github.io/MatchIt/index.html","id":"citing-matchit","dir":"","previous_headings":"","what":"Citing MatchIt","title":"Nonparametric Preprocessing for Parametric Causal Inference","text":"Please cite MatchIt using analysis presented publications, can citing Journal Statistical Software article : Ho, D. E., Imai, K., King, G., & Stuart, E. . (2011). MatchIt: Nonparametric Preprocessing Parametric Causal Inference. Journal Statistical Software, 42(8). doi:10.18637/jss.v042.i08 citation can also accessed using citation(\"MatchIt\") R. reproducibility purposes, also important include version number version used.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Nonparametric Preprocessing for Parametric Causal Inference","text":"download install latest stable version MatchIt CRAN, run following: install development version, may bug fixed new feature, run following: require R compile C++ code, might require additional software installed computer. need development version can’t compile package, ask maintainer binary version package.","code":"install.packages(\"MatchIt\") install.packages(\"pak\") #If not yet installed  pak::pkg_install(\"ngreifer/MatchIt\")"},{"path":"https://kosukeimai.github.io/MatchIt/index.html","id":"questions-and-bug-reports","dir":"","previous_headings":"","what":"Questions and Bug Reports","title":"Nonparametric Preprocessing for Parametric Causal Inference","text":"questions MatchIt want submit bug report, please using GitHub issues page package. Suggestions new features kind words support encouraged well. Remember software free developed volunteers.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/MatchIt-package.html","id":null,"dir":"Reference","previous_headings":"","what":"MatchIt: Nonparametric Preprocessing for Parametric Causal Inference — MatchIt-package","title":"MatchIt: Nonparametric Preprocessing for Parametric Causal Inference — MatchIt-package","text":"Selects matched samples original treated control groups similar covariate distributions – can used match exactly covariates, match propensity scores, perform variety matching procedures. package also implements series recommendations offered Ho, Imai, King, Stuart (2007) doi:10.1093/pan/mpl013 . ('gurobi' package, CRAN, optional comes installation Gurobi Optimizer, available https://www.gurobi.com.)","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/MatchIt-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"MatchIt: Nonparametric Preprocessing for Parametric Causal Inference — MatchIt-package","text":"Maintainer: Noah Greifer noah.greifer@gmail.com (ORCID) Authors: Daniel Ho daniel.e.ho@gmail.com (ORCID) Kosuke Imai imai@harvard.edu (ORCID) Gary King king@harvard.edu (ORCID) Elizabeth Stuart estuart@jhu.edu (ORCID) contributors: Alex Whitworth whitworth.alex@gmail.com [contributor]","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/add_s.weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Add sampling weights to a matchit object — add_s.weights","title":"Add sampling weights to a matchit object — add_s.weights","text":"Adds sampling weights matchit object incorporated balance assessment creation weights. typically used argument s.weights supplied matchit() (.e., included estimation propensity score) sampling weights required generalizing effect correct population. Without adding sampling weights matchit object, balance assessment tools (.e., summary.matchit() plot.matchit()) calculate balance statistics correctly, weights produced match_data() get_matches() incorporate sampling weights.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/add_s.weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add sampling weights to a matchit object — add_s.weights","text":"","code":"add_s.weights(m, s.weights = NULL, data = NULL)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/add_s.weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add sampling weights to a matchit object — add_s.weights","text":"m matchit object; output call matchit(), typically s.weights argument unspecified. s.weights numeric vector sampling weights added matchit object. Can also specified string containing name variable data used one-sided formula variable right-hand side (e.g., ~ SW). data data frame containing sampling weights given string formula. unspecified, add_s.weights() attempt find dataset using environment matchit object.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/add_s.weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add sampling weights to a matchit object — add_s.weights","text":"matchit object s.weights component containing supplied sampling weights. s.weights = NULL, original matchit object returned.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/add_s.weights.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add sampling weights to a matchit object — add_s.weights","text":"Noah Greifer","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/add_s.weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add sampling weights to a matchit object — add_s.weights","text":"","code":"data(\"lalonde\")  # Generate random sampling weights, just # for this example sw <- rchisq(nrow(lalonde), 2)  # NN PS match using logistic regression PS that doesn't # include sampling weights m.out <- matchit(treat ~ age + educ + race + nodegree +                    married  + re74 + re75, data = lalonde)  m.out #> A `matchit` object #>  - method: 1:1 nearest neighbor matching without replacement #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 370 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75  # Add s.weights to the matchit object m.out <- add_s.weights(m.out, sw)  m.out #note additional output #> A `matchit` object #>  - method: 1:1 nearest neighbor matching without replacement #>  - distance: Propensity score #>              - estimated with logistic regression #>              - sampling weights not included in estimation #>  - number of obs.: 614 (original), 370 (matched) #>  - sampling weights: present #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75  # Check balance; note that sample sizes incorporate # s.weights summary(m.out, improvement = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5796        0.1821          1.7726     0.9548    0.3817 #> age              25.7457       27.6471         -0.2776     0.3916    0.0917 #> educ             10.2366       10.1874          0.0242     0.5375    0.0324 #> raceblack         0.8523        0.1965          1.8482          .    0.6558 #> racehispan        0.0520        0.1497         -0.4397          .    0.0977 #> racewhite         0.0957        0.6538         -1.8974          .    0.5581 #> nodegree          0.7233        0.5991          0.2777          .    0.1242 #> married           0.2114        0.5043         -0.7175          .    0.2929 #> re74           1901.2003     5724.2451         -0.7745     0.4560    0.2349 #> re75           1423.0173     2586.7575         -0.3786     0.6725    0.1432 #>            eCDF Max #> distance     0.6558 #> age          0.1616 #> educ         0.1242 #> raceblack    0.6558 #> racehispan   0.0977 #> racewhite    0.5581 #> nodegree     0.1242 #> married      0.2929 #> re74         0.4843 #> re75         0.3168 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5796        0.3554          0.9999     0.7895    0.1383 #> age              25.7457       24.6876          0.1545     0.4187    0.0942 #> educ             10.2366       10.5470         -0.1526     0.6304    0.0230 #> raceblack         0.8523        0.4415          1.1577          .    0.4108 #> racehispan        0.0520        0.2361         -0.8285          .    0.1840 #> racewhite         0.0957        0.3225         -0.7710          .    0.2268 #> nodegree          0.7233        0.6463          0.1722          .    0.0770 #> married           0.2114        0.1909          0.0501          .    0.0205 #> re74           1901.2003     2115.7108         -0.0435     1.6183    0.0576 #> re75           1423.0173     1831.8247         -0.1330     1.0301    0.0653 #>            eCDF Max Std. Pair Dist. #> distance     0.4342          0.9567 #> age          0.3460          1.4563 #> educ         0.0770          1.2332 #> raceblack    0.4108          1.0511 #> racehispan   0.1840          1.1438 #> racewhite    0.2268          0.8453 #> nodegree     0.0770          1.0271 #> married      0.0205          0.7944 #> re74         0.3418          0.7885 #> re75         0.2391          0.7731 #>  #> Sample Sizes: #>               Control Treated #> All (ESS)      214.55   93.95 #> All            429.    185.   #> Matched (ESS)   97.95   93.95 #> Matched        185.    185.   #> Unmatched      244.      0.   #> Discarded        0.      0.   #>"},{"path":"https://kosukeimai.github.io/MatchIt/reference/distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Propensity scores and other distance measures — distance","title":"Propensity scores and other distance measures — distance","text":"Several matching methods require can involve distance treated control units. Options include Mahalanobis distance, propensity score distance, distance user-supplied values. Propensity scores also used common support via discard options defining calipers. page documents options can supplied distance argument matchit().","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/distance.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Propensity scores and other distance measures — distance","text":"versions MatchIt prior 4.0.0, distance specified slightly different way. specifying arguments using old syntax, automatically converted corresponding method new syntax warning thrown. distance = \"logit\", old default, still work new syntax, though distance = \"glm\", link = \"logit\" preferred (note default settings need made explicit).","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/distance.html","id":"allowable-options","dir":"Reference","previous_headings":"","what":"Allowable options","title":"Propensity scores and other distance measures — distance","text":"four ways specify distance argument: 1) string containing name method estimating propensity scores, 2) string containing name method computing pairwise distances covariates, 3) vector values whose pairwise differences define distance units, 4) distance matrix containing pairwise distances. options detailed .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/distance.html","id":"propensity-score-estimation-methods","dir":"Reference","previous_headings":"","what":"Propensity score estimation methods","title":"Propensity scores and other distance measures — distance","text":"distance specified name method estimating propensity scores (described ), propensity score estimated using variables formula method corresponding given argument. propensity score can used compute distance units absolute difference propensity scores pairs units. Propensity scores can also used create calipers common support restrictions, whether used actual distance measure used matching, . addition distance argument, two arguments can specified relate estimation manipulation propensity scores. link argument allows different links used models require generalized linear models, logit probit links allowed, among others. addition specifying link, link argument can used specify whether propensity score linearized version propensity score used; specifying link = \"linear.{link}\", linearized version used. distance.options argument can also specified, list values passed propensity score-estimating function, example, choose specific options tuning parameters estimation method. formula, data, verbose supplied distance.options, corresponding arguments matchit() automatically supplied. See Examples demonstrations uses link distance.options. s.weights supplied call matchit(), automatically passed propensity score-estimating function weights argument unless otherwise described . following methods estimating propensity scores allowed: \"glm\" propensity scores estimated using generalized linear model (e.g., logistic regression). formula supplied matchit() passed directly glm(), predict.glm() used compute propensity scores. link argument can specified link function supplied binomial(), e.g., \"logit\", default. link prepended \"linear.\", linear predictor used instead predicted probabilities. distance = \"glm\" link = \"logit\" (logistic regression) default matchit(). (used able requested distance = \"ps\", still works.) \"gam\" propensity scores estimated using generalized additive model. formula supplied matchit() passed directly mgcvgam, mgcvpredict.gam used compute propensity scores. link argument can specified link function supplied binomial(), e.g., \"logit\", default. link prepended \"linear.\", linear predictor used instead predicted probabilities. Note unless smoothing functions mgcvs, mgcvte, mgcvti, mgcvt2 used formula, generalized additive model identical generalized linear model estimate propensity scores glm(). See documentation mgcvgam, mgcvformula.gam, mgcvgam.models information specify models. Also note formula returned matchit() output object simplified version supplied formula smoothing terms removed (named variables present). \"gbm\" propensity scores estimated using generalized boosted model. formula supplied matchit() passed directly gbmgbm, gbmpredict.gbm used compute propensity scores. optimal tree chosen using 5-fold cross-validation default, can changed supplying argument method distance.options; see gbmgbm.perf details. link argument can specified \"linear\" use linear predictor instead predicted probabilities. links allowed. tuning parameter defaults differ gbm::gbm(); follows: n.trees = 1e4, interaction.depth = 3, shrinkage = .01, bag.fraction = 1, cv.folds = 5, keep.data = FALSE. defaults used WeightIt twang, except cv.folds keep.data. Note use generalized boosted modeling twang; , number trees chosen based cross-validation --bag error, rather based optimizing balance. twang cited using method estimate propensity scores. Note random component choosing tuning parameter, results vary across runs unless seed set. \"lasso\", \"ridge\", \"elasticnet\" propensity scores estimated using lasso, ridge, elastic net model, respectively. formula supplied matchit() processed model.matrix() passed glmnetcv.glmnet, glmnetpredict.cv.glmnet used compute propensity scores. link argument can specified link function supplied binomial(), e.g., \"logit\", default. link prepended \"linear.\", linear predictor used instead predicted probabilities. link = \"log\", Poisson model used. distance = \"elasticnet\", alpha argument, controls prioritize lasso ridge penalties elastic net, set .5 default can changed supplying argument alpha distance.options. \"lasso\" \"ridge\", alpha set 1 0, respectively, changed. cv.glmnet() defaults used select tuning parameters generate predictions can modified using distance.options. s argument passed distance.options, passed predict.cv.glmnet(). Note random component choosing tuning parameter, results vary across runs unless seed set. \"rpart\" propensity scores estimated using classification tree. formula supplied matchit() passed directly rpartrpart, rpartpredict.rpart used compute propensity scores. link argument ignored, predicted probabilities always returned distance measure. \"randomforest\" propensity scores estimated using random forest. formula supplied matchit() passed directly randomForestrandomForest, randomForestpredict.randomForest used compute propensity scores. link argument ignored, predicted probabilities always returned distance measure. Note random component, results vary across runs unless seed set. \"nnet\" propensity scores estimated using single-hidden-layer neural network. formula supplied matchit() passed directly nnetnnet, fitted() used compute propensity scores. link argument ignored, predicted probabilities always returned distance measure. argument size must supplied distance.options using method = \"nnet\". \"cbps\" propensity scores estimated using covariate balancing propensity score (CBPS) algorithm, form logistic regression balance constraints incorporated generalized method moments estimation model coefficients. formula supplied matchit() passed directly CBPSCBPS, fitted() used compute propensity scores. link argument can specified \"linear\" use linear predictor instead predicted probabilities. links allowed. estimand argument supplied matchit() used select appropriate estimand use defining balance constraints, argument needs supplied ATT CBPS. \"bart\" propensity scores estimated using Bayesian additive regression trees (BART). formula supplied matchit() passed directly dbartsbart2, dbartsfitted.bart used compute propensity scores. link argument can specified \"linear\" use linear predictor instead predicted probabilities. s.weights supplied matchit(), passed bart2 weights argument bart2 correspond sampling weights. Note random component choosing tuning parameter, results vary across runs unless seed argument supplied distance.options. Note setting seed using set.seed() sufficient guarantee reproducibility unless single-threading used. See dbartsbart2 details.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/distance.html","id":"methods-for-computing-distances-from-covariates","dir":"Reference","previous_headings":"","what":"Methods for computing distances from covariates","title":"Propensity scores and other distance measures — distance","text":"following methods involve computing distance matrix covariates without estimating propensity score. Calipers distance measure common support restrictions used, distance component output object empty propensity scores estimated. link distance.options arguments ignored methods. See individual matching methods pages whether distances allowed used. distance measures can also calculated outside matchit() using corresponding function. \"euclidean\" Euclidean distance raw distance units, computed $$d_{ij} = \\sqrt{(x_i - x_j)(x_i - x_j)'}$$ sensitive scale covariates, covariates larger scales take higher priority. \"scaled_euclidean\" scaled Euclidean distance Euclidean distance computed scaled (.e., standardized) covariates. ensures covariates scale. covariates standardized using pooled within-group standard deviations, computed treatment group-mean centering covariate computing standard deviation full sample. \"mahalanobis\" Mahalanobis distance computed $$d_{ij} = \\sqrt{(x_i - x_j)\\Sigma^{-1}(x_i - x_j)'}$$ \\(\\Sigma\\) pooled within-group covariance matrix covariates, computed treatment group-mean centering covariate computing covariance full sample. ensures variables scale accounts correlation covariates. \"robust_mahalanobis\" robust rank-based Mahalanobis distance Mahalanobis distance computed ranks covariates adjustment ties. described Rosenbaum (2010, ch. 8) alternative Mahalanobis distance handles outliers rare categories better standard Mahalanobis distance affinely invariant. perform Mahalanobis distance matching estimate propensity scores used purpose matching, mahvars argument used along different specification distance. See individual matching method pages details use mahvars.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/distance.html","id":"distances-supplied-as-a-numeric-vector-or-matrix","dir":"Reference","previous_headings":"","what":"Distances supplied as a numeric vector or matrix","title":"Propensity scores and other distance measures — distance","text":"distance can also supplied numeric vector whose values taken function like propensity scores; pairwise difference define distance units. might useful supplying propensity scores computed outside matchit() resupplying matchit() propensity scores estimated previously without recompute . distance can also supplied matrix whose values represent pairwise distances units. matrix either square, row column unit (e.g., output call .matrix(dist(.))), many rows treated units many columns control units (e.g., output call mahalanobis_dist() optmatchmatch_on). Distance values Inf disallow corresponding units matched. distance supplied numeric vector matrix, link distance.options ignored.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Propensity scores and other distance measures — distance","text":"","code":"data(\"lalonde\")  # Linearized probit regression PS: m.out1 <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75, data = lalonde,                   distance = \"glm\", link = \"linear.probit\") # GAM logistic PS with smoothing splines (s()): m.out2 <- matchit(treat ~ s(age) + s(educ) + race + married +                     nodegree + re74 + re75, data = lalonde,                   distance = \"gam\") summary(m.out2$model) #>  #> Family: quasibinomial  #> Link function: logit  #>  #> Formula: #> treat ~ s(age) + s(educ) + race + married + nodegree + re74 +  #>     re75 #>  #> Parametric coefficients: #>               Estimate Std. Error t value Pr(>|t|)     #> (Intercept)  5.436e-01  3.950e-01   1.376  0.16928     #> racehispan  -2.447e+00  4.323e-01  -5.661 2.34e-08 *** #> racewhite   -2.995e+00  3.136e-01  -9.552  < 2e-16 *** #> married     -1.644e+00  3.438e-01  -4.781 2.20e-06 *** #> nodegree     7.894e-01  4.800e-01   1.645  0.10058     #> re74        -9.838e-05  3.245e-05  -3.031  0.00254 **  #> re75         5.113e-05  5.001e-05   1.022  0.30702     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Approximate significance of smooth terms: #>           edf Ref.df     F p-value     #> s(age)  7.489  8.144 6.781  <2e-16 *** #> s(educ) 2.647  3.359 2.311  0.0628 .   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> R-sq.(adj) =    0.5   Deviance explained = 46.1% #> GCV = 0.69813  Scale est. = 1.0287    n = 614 # CBPS for ATC matching w/replacement, using the just- # identified version of CBPS (setting method = \"exact\"): m.out3 <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75, data = lalonde,                   distance = \"cbps\", estimand = \"ATC\",                   distance.options = list(method = \"exact\"),                   replace = TRUE) # Mahalanobis distance matching - no PS estimated m.out4 <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75, data = lalonde,                   distance = \"mahalanobis\")  m.out4$distance #NULL #> NULL  # Mahalanobis distance matching with PS estimated # for use in a caliper; matching done on mahvars m.out5 <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75, data = lalonde,                   distance = \"glm\", caliper = .1,                   mahvars = ~ age + educ + race + married +                                 nodegree + re74 + re75)  summary(m.out5) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + married + nodegree +  #>     re74 + re75, data = lalonde, distance = \"glm\", mahvars = ~age +  #>     educ + race + married + nodegree + re74 + re75, caliper = 0.1) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> married      0.3236 #> nodegree     0.1114 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5096        0.4916          0.0817     1.0782    0.0225 #> age              25.9459       25.3874          0.0781     0.4201    0.0869 #> educ             10.4865       10.2883          0.0986     0.6448    0.0199 #> raceblack         0.7387        0.7207          0.0496          .    0.0180 #> racehispan        0.0991        0.1171         -0.0762          .    0.0180 #> racewhite         0.1622        0.1622          0.0000          .    0.0000 #> married           0.2072        0.2162         -0.0230          .    0.0090 #> nodegree          0.6486        0.6306          0.0396          .    0.0180 #> re74           2667.1135     2357.0686          0.0634     1.7471    0.0387 #> re75           1811.2988     1506.3709          0.0947     1.9333    0.0253 #>            eCDF Max Std. Pair Dist. #> distance     0.1441          0.0922 #> age          0.3063          0.9922 #> educ         0.0811          0.7707 #> raceblack    0.0180          0.0496 #> racehispan   0.0180          0.0762 #> racewhite    0.0000          0.0000 #> married      0.0090          0.4370 #> nodegree     0.0180          0.4756 #> re74         0.2432          0.5712 #> re75         0.0901          0.5442 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       111     111 #> Unmatched     318      74 #> Discarded       0       0 #>   # User-supplied propensity scores p.score <- fitted(glm(treat ~ age + educ + race + married +                         nodegree + re74 + re75, data = lalonde,                       family = binomial))  m.out6 <- matchit(treat ~ age + educ + race + married +                     nodegree + re74 + re75, data = lalonde,                   distance = p.score)  # User-supplied distance matrix using optmatch::match_on() dist_mat <- optmatch::match_on(               treat ~ age + educ + race + nodegree +                 married + re74 + re75, data = lalonde,               method = \"rank_mahalanobis\")  m.out7 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   distance = dist_mat)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/lalonde.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from National Supported Work Demonstration and PSID, as analyzed by Dehejia and Wahba (1999). — lalonde","title":"Data from National Supported Work Demonstration and PSID, as analyzed by Dehejia and Wahba (1999). — lalonde","text":"subsample data treated group National Supported Work Demonstration (NSW) comparison sample Population Survey Income Dynamics (PSID). data previously analyzed extensively Lalonde (1986) Dehejia Wahba (1999).","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/lalonde.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from National Supported Work Demonstration and PSID, as analyzed by Dehejia and Wahba (1999). — lalonde","text":"data frame 614 observations (185 treated, 429 control). 9 variables measured individual. \"treat\" treatment assignment (1=treated, 0=control). \"age\" age years. \"educ\" education number years schooling. \"race\" individual's race/ethnicity, (Black, Hispanic, White). Note previous versions dataset used indicator variables black hispan instead single race variable. \"married\" indicator married (1=married, 0=married). \"nodegree\" indicator whether individual high school degree (1=degree, 0=degree). \"re74\" income 1974, U.S. dollars. \"re75\" income 1975, U.S. dollars. \"re78\" income 1978, U.S. dollars. \"treat\" treatment variable, \"re78\" outcome, others pre-treatment covariates.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/lalonde.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data from National Supported Work Demonstration and PSID, as analyzed by Dehejia and Wahba (1999). — lalonde","text":"Lalonde, R. (1986). Evaluating econometric evaluations training programs experimental data. American Economic Review 76: 604-620. Dehejia, R.H. Wahba, S. (1999).  Causal Effects Nonexperimental Studies: Re-Evaluating Evaluation Training Programs.  Journal American Statistical Association 94: 1053-1062.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/mahalanobis_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a Distance Matrix — mahalanobis_dist","title":"Compute a Distance Matrix — mahalanobis_dist","text":"functions compute distance matrix, either single dataset (.e., distances pairs units) two groups defined splitting variable (.e., distances units one group units ). distance matrices include Mahalanobis distance, Euclidean distance, scaled Euclidean distance, robust (rank-based) Mahalanobis distance. functions can used inputs distance argument matchit() used compute corresponding distance matrices within matchit() named.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/mahalanobis_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a Distance Matrix — mahalanobis_dist","text":"","code":"mahalanobis_dist(   formula = NULL,   data = NULL,   s.weights = NULL,   var = NULL,   discarded = NULL,   ... )  scaled_euclidean_dist(   formula = NULL,   data = NULL,   s.weights = NULL,   var = NULL,   discarded = NULL,   ... )  robust_mahalanobis_dist(   formula = NULL,   data = NULL,   s.weights = NULL,   discarded = NULL,   ... )  euclidean_dist(formula = NULL, data = NULL, ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/mahalanobis_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a Distance Matrix — mahalanobis_dist","text":"formula formula treatment (.e., splitting variable) left side covariates used compute distance matrix right side. left-hand-side variable, distances computed pairs units. NULL, variables data used covariates. data data frame containing variables named formula. formula NULL, variables data used covariates. s.weights var = NULL, optional vector sampling weights used compute variances used Mahalanobis, scaled Euclidean, robust Mahalanobis distances. var mahalanobis_dist(), covariance matrix used scale covariates. scaled_euclidean_dist(), either covariance matrix (diagonal elements used) vector variances used scale covariates. NULL, values calculated using formulas described Details. discarded logical vector denoting units discarded . used var = NULL. scaling factors computed using non-discarded units, distance matrix computed units (discarded non-discarded). ... ignored. Included make cycling functions easier without change arguments supplied.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/mahalanobis_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a Distance Matrix — mahalanobis_dist","text":"numeric distance matrix. formula left-hand-side (treatment) variable, matrix one row treated unit one column control unit. Otherwise, matrix one row one column unit.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/mahalanobis_dist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute a Distance Matrix — mahalanobis_dist","text":"Euclidean distance (computed using euclidean_dist()) raw distance units, computed $$d_{ij} = \\sqrt{(x_i - x_j)(x_i - x_j)'}$$ \\(x_i\\) \\(x_j\\) vectors covariates units \\(\\) \\(j\\), respectively. Euclidean distance sensitive scales variables redundancy (.e., correlation). probably used matching unless variables previously scaled appropriately already scale. forms basis distance measures. scaled Euclidean distance (computed using scaled_euclidean_dist()) Euclidean distance computed scaled covariates. Typically covariates scaled dividing standard deviations, scaling factor can supplied using var argument. leads distance measure computed $$d_{ij} = \\sqrt{(x_i - x_j)S_d^{-1}(x_i - x_j)'}$$ \\(S_d\\) diagonal matrix squared scaling factors diagonal. Although measure sensitive scales variables (placed scale), still sensitive redundancy among variables. example, 5 variables measure approximately construct (.e., highly correlated) 1 variable measures another construct, first construct 5 times much influence distance units second construct. Mahalanobis distance attempts address issue. Mahalanobis distance (computed using mahalanobis_dist()) computed $$d_{ij} = \\sqrt{(x_i - x_j)S^{-1}(x_i - x_j)'}$$ \\(S\\) scaling matrix, typically covariance matrix covariates. essentially equivalent Euclidean distance computed scaled principal components covariates. popular distance matrix matching sensitive scale covariates accounts redundancy . scaling matrix can also supplied using var argument. Mahalanobis distance can sensitive outliers long-tailed otherwise non-normally distributed covariates may perform well categorical variables due prioritizing rare categories common ones. One solution rank-based robust Mahalanobis distance (computed using robust_mahalanobis_dist()), computed first replacing covariates ranks (using average ranks ties) rescaling ranked covariate constant scaling factor computing usual Mahalanobis distance rescaled ranks. Mahalanobis distance robust variant computed internally transforming covariates way Euclidean distance computed scaled covariates equal requested distance. Mahalanobis distance, involves replacing covariates vector \\(x_i\\) \\(x_iS^{-.5}\\), \\(S^{-.5}\\) Cholesky decomposition (generalized) inverse covariance matrix \\(S\\). left-hand-side splitting variable present formula var = NULL (.e., scaling matrix computed internally), covariance matrix used \"pooled\" covariance matrix, essentially weighted average covariance matrices computed separately within level splitting variable capture within-group variation reduce sensitivity covariate imbalance. also true scaling factors used scaled Euclidean distance.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/mahalanobis_dist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute a Distance Matrix — mahalanobis_dist","text":"Rosenbaum, P. R. (2010). Design observational studies. Springer. Rosenbaum, P. R., & Rubin, D. B. (1985). Constructing Control Group Using Multivariate Matched Sampling Methods Incorporate Propensity Score. American Statistician, 39(1), 33–38. doi:10.2307/2683903 Rubin, D. B. (1980). Bias Reduction Using Mahalanobis-Metric Matching. Biometrics, 36(2), 293–298. doi:10.2307/2529981","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/mahalanobis_dist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute a Distance Matrix — mahalanobis_dist","text":"Noah Greifer","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/mahalanobis_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a Distance Matrix — mahalanobis_dist","text":"","code":"data(\"lalonde\")  # Computing the scaled Euclidean distance between all units: d <- scaled_euclidean_dist(~ age + educ + race + married,                            data = lalonde)  # Another interface using the data argument: dat <- subset(lalonde, select = c(age, educ, race, married)) d <- scaled_euclidean_dist(data = dat)  # Computing the Mahalanobis distance between treated and # control units: d <- mahalanobis_dist(treat ~ age + educ + race + married,                       data = lalonde)  # Supplying a covariance matrix or vector of variances (note: # a bit more complicated with factor variables) dat <- subset(lalonde, select = c(age, educ, married, re74)) vars <- sapply(dat, var)  d <- scaled_euclidean_dist(data = dat, var = vars)  # Same result: d <- scaled_euclidean_dist(data = dat, var = diag(vars))  # Discard units: discard <- sample(c(TRUE, FALSE), nrow(lalonde),                   replace = TRUE, prob = c(.2, .8))  d <- mahalanobis_dist(treat ~ age + educ + race + married,                       data = lalonde, discarded = discard) dim(d) #all units present in distance matrix #> [1] 185 429 table(lalonde$treat) #>  #>   0   1  #> 429 185"},{"path":"https://kosukeimai.github.io/MatchIt/reference/match_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a matched dataset from a matchit object — match_data","title":"Construct a matched dataset from a matchit object — match_data","text":"match_data() get_matches() create data frame additional variables distance measure, matching weights, subclasses matching. dataset can used estimate treatment effects matching subclassification. get_matches() useful matching replacement; otherwise, match_data() flexible. See Details difference .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/match_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a matched dataset from a matchit object — match_data","text":"","code":"match_data(   object,   group = \"all\",   distance = \"distance\",   weights = \"weights\",   subclass = \"subclass\",   data = NULL,   include.s.weights = TRUE,   drop.unmatched = TRUE )  match.data(...)  get_matches(   object,   distance = \"distance\",   weights = \"weights\",   subclass = \"subclass\",   id = \"id\",   data = NULL,   include.s.weights = TRUE )"},{"path":"https://kosukeimai.github.io/MatchIt/reference/match_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a matched dataset from a matchit object — match_data","text":"object matchit object; output call matchit(). group group comprise matched dataset: \"\" units, \"treated\" just treated units, \"control\" just control units. Default \"\". distance string containing name given variable containing distance measure data frame output. Default \"distance\", \"prop.score\" similar might good alternative propensity scores used matching. Ignored distance measure supplied estimated call matchit(). weights string containing name given variable containing matching weights data frame output. Default \"weights\". subclass string containing name given variable containing subclasses matched pair membership data frame output. Default \"subclass\". data data frame containing original dataset computed output variables (distance, weights, /subclass) appended. empty, match_data() get_matches() attempt find dataset using environment matchit object, can unreliable; see Notes. include.s.weights logical; whether multiply estimated weights sampling weights supplied matchit(), . Default TRUE. FALSE, weights match_data() get_matches() output multiplied sampling weights supplied function estimating treatment effect matched data. drop.unmatched logical; whether returned data frame contain units (FALSE) units matched (.e., matching weight greater zero) (TRUE). Default TRUE drop unmatched units. ... arguments passed match_data(). id string containing name given variable containing unit IDs data frame output. Default \"id\". used get_matches(); match_data(), units IDs stored row names returned data frame.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/match_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a matched dataset from a matchit object — match_data","text":"data frame containing data supplied data argument original call matchit() computed output variables appended additional columns, named according arguments . match_data(), group drop.unmatched arguments control whether subsets data returned. See Details match_data() get_matches() differ. Note get_matches sorts data subclass treatment status, unlike match_data(), uses order data. returned data frame contain variables original data set dataset supplied data following columns: distance propensity score, estimated supplied distance argument matchit() vector. weights computed matching weights. must used effect estimation correctly incorporate matching. subclass Matching strata membership. Units value stratum. id ID unit, corresponding row names original data dataset supplied data. included get_matches output. column can used identify rows belong unit since unit may appear multiple times reused matching replacement. columns take name supplied corresponding arguments call match_data() get_matches(). See Examples example rename distance column \"prop.score\". data original dataset supplied matchit() data.table tbl, match_data() output class, get_matches() output always base R data.frame. addition base class (e.g., data.frame tbl), returned objects class matchdata getmatches. class important using rbind() append matched datasets.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/match_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a matched dataset from a matchit object — match_data","text":"match_data() creates dataset one row per unit. identical dataset supplied except several new columns added containing information related matching. drop.unmatched = TRUE, default, units weights zero, units discarded common support caliper simply matched, dropped dataset, leaving subset matched units. idea output match_data() used dataset input calls glm() similar estimate treatment effects matched sample. important include weights estimation effect standard error. subclass column, created, contains pair subclass membership used estimate effect standard error. Subclasses included subclass component matchit object, occur matching replacement, case get_matches() used. See vignette(\"estimating-effects\") information use match_data() output estimate effects. match.data() alias match_data(). get_matches() similar match_data(); primary difference occurs matching performed replacement, .e., units belong single matched pair. case, output get_matches() dataset contains one row per unit pair part . example, matching performed replacement control unit matched two treated units, control unit two rows output dataset, one pair part . Weights computed row, , control units, equal inverse number control units control unit's subclass; treated units get weight 1. Unmatched units dropped. additional column unit IDs created (named using id argument) identify unit present multiple rows. dataset structure allows inclusion subclass membership repeated use units, unlike output match_data(), lacks subclass membership matching done replacement. match.matrix component matchit object must present use get_matches(); forms matching, absent, case match_data() used instead. See vignette(\"estimating-effects\") information use get_matches() output estimate effects matching replacement.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/match_data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Construct a matched dataset from a matchit object — match_data","text":"common way use match_data() get_matches() supplying just matchit object, e.g., match_data(m.). data set first searched environment matchit formula, calling environment match_data() get_matches(), finally model component matchit object propensity score estimated. called environment different one matchit() originally called propensity score estimated (discard \"none\" reestimate = TRUE), syntax may work original dataset used construct matched dataset found. can occur matchit() run within lapply() purrr::map() call. solution, recommended cases, simply supply original dataset data argument match_data(), e.g., match_data(m., data = original_data), demonstrated Examples.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/match_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a matched dataset from a matchit object — match_data","text":"","code":"data(\"lalonde\")  # 4:1 matching w/replacement m.out1 <- matchit(treat ~ age + educ + married +                     race + nodegree + re74 + re75,                   data = lalonde, replace = TRUE,                   caliper = .05, ratio = 4)  m.data1 <- match_data(m.out1, data = lalonde,                       distance = \"prop.score\") dim(m.data1) #one row per matched unit #> [1] 347  11 head(m.data1, 10) #>       treat age educ   race married nodegree re74 re75       re78 prop.score #> NSW1      1  37   11  black       1        1    0    0  9930.0460 0.63876993 #> NSW2      1  22    9 hispan       0        1    0    0  3595.8940 0.22463424 #> NSW3      1  30   12  black       0        0    0    0 24909.4500 0.67824388 #> NSW4      1  27   11  black       0        1    0    0  7506.1460 0.77632408 #> NSW5      1  33    8  black       0        1    0    0   289.7899 0.70163874 #> NSW6      1  22    9  black       0        1    0    0  4056.4940 0.69906990 #> NSW7      1  23   12  black       0        0    0    0     0.0000 0.65368426 #> NSW8      1  32   11  black       0        1    0    0  8472.1580 0.78972311 #> NSW9      1  22   16  black       0        0    0    0  2164.0220 0.77983825 #> NSW10     1  33   12  white       1        0    0    0 12418.0700 0.04292461 #>       weights #> NSW1        1 #> NSW2        1 #> NSW3        1 #> NSW4        1 #> NSW5        1 #> NSW6        1 #> NSW7        1 #> NSW8        1 #> NSW9        1 #> NSW10       1  g.matches1 <- get_matches(m.out1, data = lalonde,                           distance = \"prop.score\") dim(g.matches1) #multiple rows per matched unit #> [1] 820  13 head(g.matches1, 10) #>         id subclass weights treat age educ   race married nodegree        re74 #> 1     NSW1        1    1.00     1  37   11  black       1        1     0.00000 #> 2   PSID69        1    0.25     0  30   17  black       0        0 17827.37000 #> 3  PSID387        1    0.25     0  55    4  black       0        1     0.00000 #> 4  PSID373        1    0.25     0  20   12  black       0        0     0.00000 #> 5  PSID386        1    0.25     0  20   12  black       0        0     0.00000 #> 6     NSW2        2    1.00     1  22    9 hispan       0        1     0.00000 #> 7  PSID111        2    0.25     0  51   11  white       0        1    48.98167 #> 8   PSID66        2    0.25     0  26    8 hispan       0        1  3168.13400 #> 9  PSID339        2    0.25     0  26    9 hispan       0        1  1563.49500 #> 10 PSID150        2    0.25     0  22   11 hispan       0        1  7341.37300 #>        re75      re78 prop.score #> 1     0.000  9930.046  0.6387699 #> 2  5546.419 14421.130  0.6385542 #> 3     0.000     0.000  0.6357539 #> 4     0.000     0.000  0.6428929 #> 5     0.000 11594.240  0.6428929 #> 6     0.000  3595.894  0.2246342 #> 7  3813.387  1525.014  0.2240794 #> 8  5872.258 11136.150  0.2225951 #> 9     0.000  2862.356  0.2161957 #> 10 2535.097 14187.650  0.2128728"},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching for Causal Inference — matchit","title":"Matching for Causal Inference — matchit","text":"matchit() main function MatchIt performs pairing, subset selection, subclassification aim creating treatment control groups balanced included covariates. MatchIt implements suggestions Ho, Imai, King, Stuart (2007) improving parametric statistical models preprocessing data nonparametric matching methods. page documents overall use matchit(), specifics matchit() works individual matching methods, see individual pages linked Details section .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching for Causal Inference — matchit","text":"","code":"matchit(   formula,   data = NULL,   method = \"nearest\",   distance = \"glm\",   link = \"logit\",   distance.options = list(),   estimand = \"ATT\",   exact = NULL,   mahvars = NULL,   antiexact = NULL,   discard = \"none\",   reestimate = FALSE,   s.weights = NULL,   replace = FALSE,   m.order = NULL,   caliper = NULL,   std.caliper = TRUE,   ratio = 1,   verbose = FALSE,   include.obj = FALSE,   normalize = TRUE,   ... )"},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching for Causal Inference — matchit","text":"formula two-sided formula object containing treatment covariates used creating distance measure used matching. formula supplied functions estimate distance measure. formula specified ~ X1 + X2 + ... represents treatment variable X1 X2 covariates. data data frame containing variables named formula possible arguments. found data, variables sought environment. method matching method used. allowed methods \"nearest\" nearest neighbor matching (propensity score default), \"optimal\" optimal pair matching, \"full\" optimal full matching, \"quick\" generalized (quick) full matching, \"genetic\" genetic matching, \"cem\" coarsened exact matching, \"exact\" exact matching, \"cardinality\" cardinality profile matching, \"subclass\" subclassification. set NULL, matching occur, propensity score estimation common support restrictions still occur requested. See linked pages method details methods , arguments used , additional arguments allowed. distance distance measure used. Can either name method estimating propensity scores (e.g., \"glm\"), name method computing distance matrix covariates (e.g., \"mahalanobis\"), vector already-computed distance measures, matrix pairwise distances. See distance allowable options. default \"glm\" propensity scores estimated logistic regression using glm(). Ignored methods; see individual methods pages information whether distance measure used. link distance specified string, additional argument controlling link function used estimating distance measure. Allowable options depend specific distance value specified. See distance allowable options option. default \"logit\", , along distance = \"glm\", identifies default measure logistic regression propensity scores. distance.options named list containing additional arguments supplied function estimates distance measure determined argument distance. See distance example use. estimand string containing name target estimand desired. Can one \"ATT\", \"ATC\", \"ATE\". Default \"ATT\". See Details individual methods pages information argument used. exact methods allow , variables exact matching take place. Can specified string containing names variables data used one-sided formula desired variables right-hand side (e.g., ~ X3 + X4). See individual methods pages information whether argument used. mahvars methods allow , variables Mahalanobis distance matching take place distance corresponds propensity scores. Usually used perform Mahalanobis distance matching within propensity score calipers, propensity scores computed using formula distance. Can specified string containing names variables data used one-sided formula desired variables right-hand side (e.g., ~ X3 + X4). See individual methods pages information whether argument used. antiexact methods allow , variables anti-exact matching take place. Anti-exact matching ensures paired individuals value anti-exact matching variable(s). Can specified string containing names variables data used one-sided formula desired variables right-hand side (e.g., ~ X3 + X4). See individual methods pages information whether argument used. discard string containing method discarding units outside region common support. propensity score estimated supplied distance vector, options \"none\", \"treated\", \"control\", \"\". \"none\", units discarded common support. Otherwise, units whose propensity scores fall outside corresponding region discarded. Can also logical vector TRUE indicates unit discarded. Default \"none\" common support restriction. See Details. reestimate discard \"none\" propensity scores estimated, whether re-estimate propensity scores remaining sample. Default FALSE use propensity scores estimated original sample. s.weights optional numeric vector sampling weights incorporated propensity score models balance statistics. Can also specified string containing name variable data used one-sided formula variable right-hand side (e.g., ~ SW). propensity score models accept sampling weights; see distance information , see vignette(\"sampling-weights\") details use sampling weights matching analysis. replace methods allow , whether matching done replacement (TRUE), control units allowed matched several treated units, without replacement (FALSE), control units can matched one treated unit . See individual methods pages information whether argument used. Default FALSE matching without replacement. m.order methods allow , order matching takes place. Allowable options depend matching method. default NULL corresponds \"largest\" propensity score estimated supplied vector \"data\" otherwise. caliper methods allow , width(s) caliper(s) use matching. numeric vector value named according variable caliper applies. apply distance measure, value unnamed. See individual methods pages information whether argument used. Positive values require distance paired units larger supplied caliper; negative values require distance paired units larger absolute value value supplied caliper. default NULL caliper. std.caliper logical; caliper specified, whether caliper standard deviation units (TRUE) raw units (FALSE). Can either length 1, applying calipers, length equal length caliper. Default TRUE. ratio methods allow , many control units matched treated unit k:1 matching. single integer value. See individual methods pages information whether argument used. default 1 1:1 matching. verbose logical; whether information matching process printed console. printed depends matching method. Default FALSE printing warnings. include.obj logical; whether include objects created matching process output, .e., functions packages matchit() calls. included depends matching method. Default FALSE. normalize logical; whether rescale nonzero weights treatment group average 1. Default TRUE. See \"Matching Weights Computed\" details. ... additional arguments passed functions used matching process. See individual methods pages information additional arguments allowed method.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching for Causal Inference — matchit","text":"method something \"subclass\", matchit object following components: match.matrix matrix containing matches. row names correspond treated units values row names (indices) control units matched treated unit. treated units matched different numbers control units (e.g., variable ratio matching matching caliper), empty spaces filled NA. included method \"full\", \"cem\" (unless k2k = TRUE), \"exact\", \"quick\", \"cardinality\" (unless mahvars supplied ratio integer). subclass factor containing matching pair/stratum membership unit. Unmatched units value NA. included replace = TRUE method = \"cardinality\" unless mahvars supplied ratio integer. weights numeric vector estimated matching weights. Unmatched discarded units weight zero. model fit object model used estimate propensity scores distance specified method estimating propensity scores. reestimate = TRUE, model estimated discarding units. X data frame covariates mentioned formula, exact, mahvars, caliper, antiexact. call matchit() call. info information matching method distance measures used. estimand argument supplied estimand. formula formula supplied. treat vector treatment status converted zeros (0) ones (1) already format. distance vector distance values (.e., propensity scores) distance supplied method estimating propensity scores numeric vector. discarded logical vector denoting whether observation discarded (TRUE) (FALSE) argument discard. s.weights vector sampling weights supplied s.weights argument, . exact one-sided formula containing variables, , supplied exact. mahvars one-sided formula containing variables, , supplied mahvars. obj include.obj = TRUE, object containing intermediate results matching procedure. See individual methods pages component contain. method = \"subclass\", matchit.subclass object components except match.matrix excluded one additional component, q.cut, included, containing vector distance measure cutpoints used define subclasses. See method_subclass details.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matching for Causal Inference — matchit","text":"Details various matching methods can found following help pages: method_nearest nearest neighbor matching method_optimal optimal pair matching method_full optimal full matching method_quick generalized (quick) full matching method_genetic genetic matching method_cem coarsened exact matching method_exact exact matching method_cardinality cardinality profile matching method_subclass subclassification pages contain information method , arguments allowed interpreted, additional arguments can supplied tune method. Note default method arguments supplied formula data 1:1 nearest neighbor matching without replacement propensity score estimated using logistic regression treatment covariates. default offered matching programs, Matching, teffects Stata, PROC PSMATCH SAS, care taken trying replicate results programs. method = NULL, matching occur, propensity score estimation common support restriction . can simple way estimate propensity score use future matching specifications without re-estimate time. matchit() output matching can supplied summary() examine balance prior matching included covariates propensity score specified. arguments distance, discard, reestimate ignored. See distance details several ways specify distance, link, distance.options arguments estimate propensity scores create distance measures. treatment variable 0/1 variable, coerced one returned matchit() output (see section Value, ). following rules used: 1) 0 one values, considered control value treated; 2) otherwise, variable factor, levels(treat)[1] considered control value treated; 3) otherwise, sort(unique(treat))[1] considered control value treated. safest ensure treatment variable 0/1 variable. discard option implements common support restriction. can used distance measure estimated propensity score supplied vector ignored matching methods. specified \"treated\", treated units whose distance measure outside range distance measures control units discarded. specified \"control\", control units whose distance measure outside range distance measures treated units discarded. specified \"\", treated control units whose distance measure outside intersection range distance measures treated units range distance measures control units discarded. reestimate = TRUE distance corresponds propensity score-estimating function, propensity scores re-estimated remaining units prior used matching calipers. Caution used interpreting effects estimated various values estimand. Setting estimand = \"ATT\" necessarily mean average treatment effect treated estimated; just means matching methods, treated units untouched given weights 1 control units matched (opposite estimand = \"ATC\"). caliper supplied treated units removed common support reason (e.g., lacking matches using exact matching), actual estimand targeted ATT treatment effect matched sample. argument estimand simply triggers units matched , stratification-based methods (exact matching, CEM, full matching, subclassification), determines formula used compute stratification weights.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"how-matching-weights-are-computed","dir":"Reference","previous_headings":"","what":"How Matching Weights Are Computed","title":"Matching for Causal Inference — matchit","text":"Matching weights computed one two ways depending whether matching done replacement .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"matching-without-replacement-and-subclassification","dir":"Reference","previous_headings":"","what":"Matching without replacement and subclassification","title":"Matching for Causal Inference — matchit","text":"matching without replacement (except cardinality matching), including subclassification, unit assigned subclass, represents pair part (case k:1 matching) stratum belong (case exact matching, coarsened exact matching, full matching, subclassification). formula computing weights depends argument supplied estimand. new \"stratum propensity score\" (\\(p^s_i\\)) computed unit \\(\\) \\(p^s_i = \\frac{1}{n_s}\\sum_{j: s_j =s_i}{(A_j=1)}\\) \\(n_s\\) size subclass \\(s\\) \\((A_j=1)\\) 1 unit \\(j\\) treated 0 otherwise. , stratum propensity score stratum \\(s\\) proportion units stratum \\(s\\) treated group, units stratum \\(s\\) assigned stratum propensity score. distinct propensity score used matching, . Weights computed using standard formulas inverse probability weights stratum propensity score inserted: ATT, weights 1 treated units \\(\\frac{p^s}{1-p^s}\\) control units ATC, weights \\(\\frac{1-p^s}{p^s}\\) treated units 1 control units ATE, weights \\(\\frac{1}{p^s}\\) treated units \\(\\frac{1}{1-p^s}\\) control units. cardinality matching, matched units receive weight 1.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"matching-with-replacement","dir":"Reference","previous_headings":"","what":"Matching with replacement","title":"Matching for Causal Inference — matchit","text":"matching replacement, units assigned unique strata. ATT, treated unit gets weight 1. control unit weighted sum inverse number control units matched treated unit across matches. example, control unit matched treated unit two control units matched , control matched treated unit one control unit matched , control unit question get weight \\(1/3 + 1/2 = 5/6\\). ATC, true treated control labels switched. weights computed using match.matrix component matchit() output object.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"normalized-weights","dir":"Reference","previous_headings":"","what":"Normalized weights","title":"Matching for Causal Inference — matchit","text":"normalize = TRUE (default), treatment group, weights divided mean nonzero weights treatment group make weights sum number units treatment group (.e., average 1).","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"sampling-weights","dir":"Reference","previous_headings":"","what":"Sampling weights","title":"Matching for Causal Inference — matchit","text":"sampling weights included s.weights argument, included matchit() output object incorporated matching weights. match_data(), extracts matched set matchit object, combines matching weights sampling weights.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Matching for Causal Inference — matchit","text":"Ho, D. E., Imai, K., King, G., & Stuart, E. . (2007). Matching Nonparametric Preprocessing Reducing Model Dependence Parametric Causal Inference. Political Analysis, 15(3), 199–236. doi:10.1093/pan/mpl013 Ho, D. E., Imai, K., King, G., & Stuart, E. . (2011). MatchIt: Nonparametric Preprocessing Parametric Causal Inference. Journal Statistical Software, 42(8). doi:10.18637/jss.v042.i08","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matching for Causal Inference — matchit","text":"Daniel Ho, Kosuke Imai, Gary King, Elizabeth Stuart wrote original package. Starting version 4.0.0, Noah Greifer primary maintainer developer.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/matchit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matching for Causal Inference — matchit","text":"","code":"data(\"lalonde\")  # Default: 1:1 NN PS matching w/o replacement  m.out1 <- matchit(treat ~ age + educ + race + nodegree +                    married + re74 + re75, data = lalonde) m.out1 #> A `matchit` object #>  - method: 1:1 nearest neighbor matching without replacement #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 370 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out1) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.3629          0.9739     0.7566    0.1321 #> age              25.8162       25.3027          0.0718     0.4568    0.0847 #> educ             10.3459       10.6054         -0.1290     0.5721    0.0239 #> raceblack         0.8432        0.4703          1.0259          .    0.3730 #> racehispan        0.0595        0.2162         -0.6629          .    0.1568 #> racewhite         0.0973        0.3135         -0.7296          .    0.2162 #> nodegree          0.7081        0.6378          0.1546          .    0.0703 #> married           0.1892        0.2108         -0.0552          .    0.0216 #> re74           2095.5737     2342.1076         -0.0505     1.3289    0.0469 #> re75           1532.0553     1614.7451         -0.0257     1.4956    0.0452 #>            eCDF Max Std. Pair Dist. #> distance     0.4216          0.9740 #> age          0.2541          1.3938 #> educ         0.0757          1.2474 #> raceblack    0.3730          1.0259 #> racehispan   0.1568          1.0743 #> racewhite    0.2162          0.8390 #> nodegree     0.0703          1.0106 #> married      0.0216          0.8281 #> re74         0.2757          0.7965 #> re75         0.2054          0.7381 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       185     185 #> Unmatched     244       0 #> Discarded       0       0 #>   # 1:1 NN Mahalanobis distance matching w/ replacement and # exact matching on married and race  m.out2 <- matchit(treat ~ age + educ + race + nodegree +                    married + re74 + re75, data = lalonde,                    distance = \"mahalanobis\", replace = TRUE,                    exact = ~ married + race) m.out2 #> A `matchit` object #>  - method: 1:1 nearest neighbor matching with replacement #>  - distance: Mahalanobis - number of obs.: 614 (original), 265 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out2, un = TRUE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, distance = \"mahalanobis\", exact = ~married +  #>     race, replace = TRUE) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              25.8162       25.6162          0.0280     0.6513    0.0466 #> educ             10.3459       10.3946         -0.0242     1.1564    0.0065 #> raceblack         0.8432        0.8432          0.0000          .    0.0000 #> racehispan        0.0595        0.0595          0.0000          .    0.0000 #> racewhite         0.0973        0.0973          0.0000          .    0.0000 #> nodegree          0.7081        0.7135         -0.0119          .    0.0054 #> married           0.1892        0.1892          0.0000          .    0.0000 #> re74           2095.5737     1861.6424          0.0479     1.4978    0.0286 #> re75           1532.0553     1091.6516          0.1368     2.0335    0.0347 #>            eCDF Max Std. Pair Dist. #> age          0.1784          0.4918 #> educ         0.0324          0.2070 #> raceblack    0.0000          0.0000 #> racehispan   0.0000          0.0000 #> racewhite    0.0000          0.0000 #> nodegree     0.0054          0.0119 #> married      0.0000          0.0000 #> re74         0.1784          0.2606 #> re75         0.0811          0.2445 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   34.89     185 #> Matched         80.       185 #> Unmatched      349.         0 #> Discarded        0.         0 #>   # 2:1 NN Mahalanobis distance matching within caliper defined # by a probit pregression PS  m.out3 <- matchit(treat ~ age + educ + race + nodegree +                    married + re74 + re75, data = lalonde,                    distance = \"glm\", link = \"probit\",                    mahvars = ~ age + educ + re74 + re75,                    caliper = .1, ratio = 2) m.out3 #> A `matchit` object #>  - method: 2:1 nearest neighbor matching without replacement #>  - distance: Mahalanobis [matching] #>              Propensity score [caliper] #>  #>              - estimated with probit regression #>  - caliper: <distance> (0.029) #>  - number of obs.: 614 (original), 257 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out3, un = TRUE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, distance = \"glm\", link = \"probit\",  #>     mahvars = ~age + educ + re74 + re75, caliper = 0.1, ratio = 2) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5773        0.1817          1.8276     0.8777    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6413 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5113        0.4932          0.0835     1.0778    0.0253 #> age              26.0721       24.9459          0.1574     0.4310    0.0928 #> educ             10.4144       10.3514          0.0314     0.6279    0.0171 #> raceblack         0.7387        0.7252          0.0372          .    0.0135 #> racehispan        0.0991        0.0946          0.0190          .    0.0045 #> racewhite         0.1622        0.1802         -0.0608          .    0.0180 #> nodegree          0.6667        0.6396          0.0594          .    0.0270 #> married           0.1892        0.2297         -0.1035          .    0.0405 #> re74           3016.7936     2280.7013          0.1506     1.8738    0.0569 #> re75           2023.1731     1525.9838          0.1544     2.0215    0.0434 #>            eCDF Max Std. Pair Dist. #> distance     0.1441          0.0860 #> age          0.3198          0.9487 #> educ         0.0586          0.7324 #> raceblack    0.0135          0.0565 #> racehispan   0.0045          0.4924 #> racewhite    0.0180          0.3236 #> nodegree     0.0270          0.5725 #> married      0.0405          0.4722 #> re74         0.2117          0.5502 #> re75         0.1081          0.5885 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)  131.78     111 #> Matched        146.       111 #> Unmatched      283.        74 #> Discarded        0.         0 #>   # Optimal full PS matching for the ATE within calipers on # PS, age, and educ m.out4 <- matchit(treat ~ age + educ + race + nodegree +                    married + re74 + re75, data = lalonde,                    method = \"full\", estimand = \"ATE\",                    caliper = c(.1, age = 2, educ = 1),                    std.caliper = c(TRUE, FALSE, FALSE)) m.out4 #> A `matchit` object #>  - method: Optimal full matching #>  - distance: Propensity score [caliper] #>  #>              - estimated with logistic regression #>  - caliper: <distance> (0.029), age (2), educ (1) #>  - number of obs.: 614 (original), 314 (matched) #>  - target estimand: ATE #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out4, un = TRUE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"full\", estimand = \"ATE\",  #>     caliper = c(0.1, age = 2, educ = 1), std.caliper = c(TRUE,  #>         FALSE, FALSE)) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7569     0.9211    0.3774 #> age              25.8162       28.0303         -0.2419     0.4400    0.0813 #> educ             10.3459       10.2354          0.0448     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.6708          .    0.6404 #> racehispan        0.0595        0.1422         -0.2774          .    0.0827 #> racewhite         0.0973        0.6550         -1.4080          .    0.5577 #> nodegree          0.7081        0.5967          0.2355          .    0.1114 #> married           0.1892        0.5128         -0.7208          .    0.3236 #> re74           2095.5737     5619.2365         -0.5958     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2870     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.3515        0.3473          0.0185     1.0175    0.0146 #> age              22.4064       22.0133          0.0430     0.8438    0.0156 #> educ             10.7009       10.6440          0.0230     1.0814    0.0107 #> raceblack         0.4618        0.4586          0.0083          .    0.0032 #> racehispan        0.1497        0.1083          0.1387          .    0.0414 #> racewhite         0.3885        0.4331         -0.1125          .    0.0446 #> nodegree          0.5792        0.5824         -0.0068          .    0.0032 #> married           0.2894        0.2677          0.0482          .    0.0217 #> re74           2679.9337     2952.3545         -0.0461     1.0852    0.0401 #> re75           1430.9478     1745.5573         -0.0966     1.2043    0.0535 #>            eCDF Max Std. Pair Dist. #> distance     0.0625          0.0449 #> age          0.1078          0.1260 #> educ         0.0594          0.2067 #> raceblack    0.0032          0.0325 #> racehispan   0.0414          0.5148 #> racewhite    0.0446          0.3771 #> nodegree     0.0032          0.2018 #> married      0.0217          0.5360 #> re74         0.1923          0.5470 #> re75         0.1493          0.6744 #>  #> Sample Sizes: #>               Control Treated #> All             429.   185.   #> Matched (ESS)   133.1   39.37 #> Matched         203.   111.   #> Unmatched       226.    74.   #> Discarded         0.     0.   #>  # Subclassification on a logistic PS with 10 subclasses after # discarding controls outside common support of PS  s.out1 <- matchit(treat ~ age + educ + race + nodegree +                    married + re74 + re75, data = lalonde,                    method = \"subclass\", distance = \"glm\",                    discard = \"control\", subclass = 10) s.out1 #> A `matchit` object #>  - method: Subclassification (10 subclasses) #>  - distance: Propensity score [common support] #>  #>              - estimated with logistic regression #>  - common support: control units dropped #>  - number of obs.: 614 (original), 557 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(s.out1, un = TRUE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"subclass\", distance = \"glm\",  #>     discard = \"control\", subclass = 10) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance Across Subclasses #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.5710          0.0293     0.9338    0.0158 #> age              25.8162       25.3714          0.0622     0.4577    0.0866 #> educ             10.3459       10.4094         -0.0316     0.6894    0.0150 #> raceblack         0.8432        0.8262          0.0469          .    0.0170 #> racehispan        0.0595        0.0676         -0.0343          .    0.0081 #> racewhite         0.0973        0.1062         -0.0302          .    0.0089 #> nodegree          0.7081        0.6782          0.0658          .    0.0299 #> married           0.1892        0.1785          0.0274          .    0.0107 #> re74           2095.5737     2232.5096         -0.0280     1.3102    0.0449 #> re75           1532.0553     1643.4179         -0.0346     1.4216    0.0472 #>            eCDF Max #> distance     0.0541 #> age          0.3043 #> educ         0.0425 #> raceblack    0.0170 #> racehispan   0.0081 #> racewhite    0.0089 #> nodegree     0.0299 #> married      0.0107 #> re74         0.2731 #> re75         0.1841 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   72.59     185 #> Matched        372.       185 #> Unmatched        0.         0 #> Discarded       57.         0 #>"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cardinality.html","id":null,"dir":"Reference","previous_headings":"","what":"Cardinality Matching — method_cardinality","title":"Cardinality Matching — method_cardinality","text":"matchit(), setting method = \"cardinality\" performs cardinality matching forms matching use mixed integer programming. Rather forming pairs, cardinality matching selects largest subset units satisfies user-supplied balance constraints mean differences. One several available optimization programs can used solve mixed integer program. default HiGHS library implemented highs package, free, performance can improved using Gurobi gurobi package, free academic license. page details allowable arguments method = \"cardinality\". See matchit() explanation argument means general context can specified. matchit() used cardinality matching:","code":"matchit(formula,         data = NULL,         method = \"cardinality\",         estimand = \"ATT\",         exact = NULL,         mahvars = NULL,         s.weights = NULL,         ratio = 1,         verbose = FALSE,         tols = .05,         std.tols = TRUE,         solver = \"highs\",         ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cardinality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cardinality Matching — method_cardinality","text":"formula two-sided formula object containing treatment covariates balanced. data data frame containing variables named formula. found data, variables sought environment. method set \"cardinality\". estimand string containing desired estimand. Allowable options include \"ATT\", \"ATC\", \"ATE\". See Details. exact variables exact matching take place. Separate optimization occur within subgroup exact matching variables. mahvars variables used pairing subset selection. Can set ratio whole number. See Details. s.weights variable containing sampling weights incorporated optimization. balance constraints refer product sampling weights matching weights, sum product sampling matching weights maximized. ratio desired ratio control treated units. Can set NA maximize sample size without concern ratio. See Details. verbose logical; whether information matching process printed console. ... additional arguments control matching specification: tols numeric; vector imbalance tolerances mean differences, one covariate formula. one value supplied, applied . See std.tols . Default .05 standardized mean differences .05 covariates treatment groups matched sample. std.tols logical; whether entry tols corresponds raw standardized mean difference. one value supplied, applied . Default TRUE standardized mean differences. standardization factor pooled standard deviation estimand = \"ATE\", standard deviation treated group estimand = \"ATT\", standard deviation control group estimand = \"ATC\" (used summary.matchit()). solver name solver use solve optimization problem. Available options include \"highs\", \"glpk\", \"symphony\", \"gurobi\" HiGHS (implemented highs package), GLPK (implemented Rglpk package), SYMPHONY (implemented Rsymphony package), Gurobi (implemented gurobi package), respectively. differences speed solving ability. HiGHS (default) GLPK easiest install, Gurobi recommended consistently outperforms solvers can find solutions even others , less time. Gurobi proprietary can used free trial academic license. SYMPHONY may produce reproducible results, even seed set. time maximum amount time optimization routine aborts, seconds. Default 120 (2 minutes). large problems, set much higher. arguments distance (related arguments), replace, m.order, caliper (related arguments) ignored warning.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cardinality.html","id":"cardinality-and-profile-matching","dir":"Reference","previous_headings":"","what":"Cardinality and Profile Matching","title":"Cardinality Matching — method_cardinality","text":"Two types matching available method = \"cardinality\": cardinality matching profile matching. Cardinality matching finds largest matched set satisfies balance constraints treatment groups, additional constraint ratio number matched control matched treated units equal ratio (1 default), mimicking k:1 matching. treated units included matched set, estimand longer corresponds ATT, cardinality matching avoided retaining ATT desired. request cardinality matching, estimand set \"ATT\" \"ATC\" ratio set positive integer. 1:1 cardinality matching default method arguments specified. Profile matching finds largest matched set satisfies balance constraints treatment group specified target sample. estimand = \"ATT\", find largest subset control units satisfies balance constraints respect treated group, left intact. estimand = \"ATE\", find largest subsets treated group control group balanced overall sample. request profile matching ATT, estimand set \"ATT\" ratio NA. request profile matching ATE, estimand set \"ATE\" ratio can set either NA maximize size sample independently positive integer ensure ratio matched control units matched treated treats fixed, mimicking k:1 matching. Unlike cardinality matching, profile matching retains requested estimand solution found. Neither method involves creating pairs matched set, possible perform additional round pairing within matched sample cardinality matching profile matching ATE fixed whole number sample size ratio supplying desired pairing variables mahvars. trigger optimal matching using optmatch::pairmatch() Mahalanobis distance computed using variables supplied mahvars. balance composition matched sample change, additional precision robustness can gained forming pairs. weights scaled sum weights group equal number matched units smaller group cardinality matching profile matching ATE, scaled sum weights control group equal number treated units profile matching ATT. sample sizes matched groups (.e., ratio = 1), scaling done. Robust standard errors used effect estimation cardinality profile matching (cluster-robust standard errors additional pairing done matched sample). See vignette(\"estimating-effects\") information.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cardinality.html","id":"specifying-balance-constraints","dir":"Reference","previous_headings":"","what":"Specifying Balance Constraints","title":"Cardinality Matching — method_cardinality","text":"balance constraints (standardized) mean differences matched treatment groups covariate. Balance constraints set supplying arguments tols std.tols. example, setting tols = .1 std.tols = TRUE requests mean differences matched sample within .1 standard deviations covariate. Different tolerances can set different variables; might beneficial constrain mean differences highly prognostic covariates tightly variables. example, one specify tols = c(.001, .05), std.tols = c(TRUE, FALSE) request standardized mean difference first covariate less .001 raw mean difference second covariate less .05. values specified order appear formula, except interactions present. One can run following code: output vector numbers variable number corresponds; first entry tols corresponds variable labeled 1, second variable labeled 2, etc.","code":"MatchIt:::get_assign(model.matrix(~X1*X2 + X3, data = data))[-1]"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cardinality.html","id":"dealing-with-errors-and-warnings","dir":"Reference","previous_headings":"","what":"Dealing with Errors and Warnings","title":"Cardinality Matching — method_cardinality","text":"optimization solved , least within time frame specified argument time, error warning appear. Unfortunately, hard know exactly cause failure measures taken rectify . warning says \"optimizer failed find optimal solution time alotted. returned solution may optimal.\" usually means optimal solution may possible find time, case time increased faster solver used. Even warning, potentially usable solution returned, automatically take mean optimization failed. Sometimes, multiple solutions resulting sample size, optimizers stall one , thinking found optimum. result checked see can used solution. error says \"optimization problem may infeasible.\" usually means issue optimization problem, .e., possible way satisfy constraints. rectify , one can try relaxing constraints increasing value tols use another solver. Sometimes Gurobi can solve problems solvers .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cardinality.html","id":"outputs","dir":"Reference","previous_headings":"","what":"Outputs","title":"Cardinality Matching — method_cardinality","text":"outputs described matchit() returned method = \"cardinality\". Unless mahvars specified, match.matrix subclass components omitted pairing subclassification done. include.obj = TRUE call matchit(), output optimization function included output. exact specified, list objects, one stratum exact variables.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cardinality.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cardinality Matching — method_cardinality","text":"manuscript, reference solver used optimization. example, sentence might read: Cardinality matching performed using MatchIt package (Ho, Imai, King, & Stuart, 2011) R optimization performed HiGHS (Huangfu & Hall, 2018). See vignette(\"matching-methods\") literature cardinality matching.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cardinality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cardinality Matching — method_cardinality","text":"","code":"data(\"lalonde\")  #Choose your solver; \"gurobi\" is best, \"highs\" is free and #easy to install solver <- \"highs\"  # 1:1 cardinality matching m.out1 <- matchit(treat ~ age + educ + re74,                   data = lalonde, method = \"cardinality\",                   estimand = \"ATT\", ratio = 1,                   tols = .2, solver = solver) m.out1 #> A `matchit` object #>  - method: Cardinality matching #>  - number of obs.: 614 (original), 370 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, re74 summary(m.out1) #>  #> Call: #> matchit(formula = treat ~ age + educ + re74, data = lalonde,  #>     method = \"cardinality\", estimand = \"ATT\", ratio = 1, tols = 0.2,  #>     solver = solver) #>  #> Summary of Balance for All Data: #>      Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max #> age        25.8162       28.0303         -0.3094     0.4400    0.0813   0.1577 #> educ       10.3459       10.2354          0.0550     0.4959    0.0347   0.1114 #> re74     2095.5737     5619.2365         -0.7211     0.5181    0.2248   0.4470 #>  #> Summary of Balance for Matched Data: #>      Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max #> age        25.8162       27.2108         -0.1949     0.4858    0.0722   0.1459 #> educ       10.3459       10.3459          0.0000     0.5470    0.0284   0.0919 #> re74     2095.5737     3051.6162         -0.1956     1.2100    0.1026   0.3243 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       185     185 #> Unmatched     244       0 #> Discarded       0       0 #>   # Profile matching for the ATT m.out2 <- matchit(treat ~ age + educ + re74,                   data = lalonde, method = \"cardinality\",                   estimand = \"ATT\", ratio = NA,                   tols = .2, solver = solver) m.out2 #> A `matchit` object #>  - method: Cardinality matching #>  - number of obs.: 614 (original), 540 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, re74 summary(m.out2, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + re74, data = lalonde,  #>     method = \"cardinality\", estimand = \"ATT\", ratio = NA, tols = 0.2,  #>     solver = solver) #>  #> Summary of Balance for Matched Data: #>      Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max #> age        25.8162       26.3662         -0.0769     0.4781    0.0695   0.1593 #> educ       10.3459       10.0761          0.1342     0.4756    0.0375   0.1106 #> re74     2095.5737     3069.7682         -0.1994     1.7132    0.1305   0.3926 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       355     185 #> Unmatched      74       0 #> Discarded       0       0 #>   # Profile matching for the ATE m.out3 <- matchit(treat ~ age + educ + re74,                   data = lalonde, method = \"cardinality\",                   estimand = \"ATE\", ratio = NA,                   tols = .2, solver = solver) m.out3 #> A `matchit` object #>  - method: Cardinality matching #>  - number of obs.: 614 (original), 516 (matched) #>  - target estimand: ATE #>  - covariates: age, educ, re74 summary(m.out3, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + re74, data = lalonde,  #>     method = \"cardinality\", estimand = \"ATE\", ratio = NA, tols = 0.2,  #>     solver = solver) #>  #> Summary of Balance for Matched Data: #>      Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max #> age        27.2680       27.7852         -0.0565     0.5837    0.0597   0.1258 #> educ       10.1753       10.1718          0.0014     0.6952    0.0215   0.1051 #> re74     3972.5915     5146.7881         -0.1985     1.0184    0.0829   0.2069 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       419      97 #> Unmatched      10      88 #> Discarded       0       0 #>  # Pairing after 1:1 cardinality matching: m.out1b <- matchit(treat ~ age + educ + re74,                    data = lalonde, method = \"cardinality\",                    estimand = \"ATT\", ratio = 1,                    tols = .15, solver = solver,                    mahvars = ~ age + educ + re74)  # Note that balance doesn't change but pair distances # are lower for the paired-upon variables summary(m.out1b, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + re74, data = lalonde,  #>     method = \"cardinality\", estimand = \"ATT\", mahvars = ~age +  #>         educ + re74, ratio = 1, tols = 0.15, solver = solver) #>  #> Summary of Balance for Matched Data: #>      Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max #> age        25.8162       26.8432         -0.1435     0.5018    0.0673   0.1351 #> educ       10.3459       10.3514         -0.0027     0.5453    0.0287   0.0919 #> re74     2095.5737     2827.7621         -0.1498     1.3037    0.0890   0.3189 #>      Std. Pair Dist. #> age           0.4487 #> educ          0.3576 #> re74          0.2796 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       185     185 #> Unmatched     244       0 #> Discarded       0       0 #>  summary(m.out1, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + re74, data = lalonde,  #>     method = \"cardinality\", estimand = \"ATT\", ratio = 1, tols = 0.2,  #>     solver = solver) #>  #> Summary of Balance for Matched Data: #>      Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max #> age        25.8162       27.2108         -0.1949     0.4858    0.0722   0.1459 #> educ       10.3459       10.3459          0.0000     0.5470    0.0284   0.0919 #> re74     2095.5737     3051.6162         -0.1956     1.2100    0.1026   0.3243 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       185     185 #> Unmatched     244       0 #> Discarded       0       0 #>   # In these examples, a high tol was used and # few covariate matched on in order to not take too long; # with real data, tols should be much lower and more # covariates included if possible."},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":null,"dir":"Reference","previous_headings":"","what":"Coarsened Exact Matching — method_cem","title":"Coarsened Exact Matching — method_cem","text":"matchit(), setting method = \"cem\" performs coarsened exact matching. coarsened exact matching, covariates coarsened bins, complete cross coarsened covariates used form subclasses defined combination coarsened covariate levels. subclass contain treated control units discarded, leaving subclasses containing treatment control units exactly equal coarsened covariates. coarsening process can controlled algorithm manually specifying cutpoints groupings. benefits coarsened exact matching tradeoff exact matching approximate balancing can managed prevent discarding many units, can otherwise occur exact matching. page details allowable arguments method = \"cem\". See matchit() explanation argument means general context can specified. matchit() used coarsened exact matching:","code":"matchit(formula,         data = NULL,         method = \"cem\",         estimand = \"ATT\",         s.weights = NULL,         verbose = FALSE,         ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coarsened Exact Matching — method_cem","text":"formula two-sided formula object containing treatment covariates used creating subclasses defined full cross coarsened covariate levels. data data frame containing variables named formula. found data, variables sought environment. method set \"cem\". estimand string containing desired estimand. Allowable options include \"ATT\", \"ATC\", \"ATE\". estimand controls weights computed; see Computing Weights section matchit() details. k2k = TRUE (see ), estimand also controls matching done. s.weights variable containing sampling weights incorporated balance statistics scaling factors k2k = TRUE certain methods used. verbose logical; whether information matching process printed console. ... additional arguments control matching process. grouping named list (optional) entry categorical variable matched . element list, entry sublist vector containing levels variable combined form single level. categorical variables included grouping remain data, means exact matching, coarsening, take place variables. See Details. cutpoints named list (optional) entry numeric variable matched . element describes way coarsening corresponding variable. can vector cutpoints demarcate bins, single number giving number bins, string corresponding method computing number bins. Allowable strings include \"sturges\", \"scott\", \"fd\", use functions grDevices::nclass.Sturges(), grDevices::nclass.scott(), grDevices::nclass.FD(), respectively. default \"sturges\" variables listed argument supplied. Can also single value applied numeric variables. See Details. k2k logical; whether 1:1 matching occur within matched strata. TRUE nearest neighbor matching without replacement take place within stratum, unmatched units dropped (e.g., treated control units stratum, treated units without match dropped). k2k.method argument controls distance units calculated. k2k.method character; distance units calculated k2k = TRUE. Allowable arguments include NULL (random matching), argument distance() computing distance matrix covariates (e.g., \"mahalanobis\"), allowable argument method dist(). Matching take place original (non-coarsened) variables. default \"mahalanobis\". mpower k2k.method = \"minkowski\", power used creating distance. passed p argument dist(). m.order character; order matching takes place k2k = TRUE. Allowable options include \"closest\", matching takes place ascending order smallest distance units; \"farthest\", matching takes place descending order smallest distance units; \"random\", matching takes place random order; \"data\" matching takes place based order units data. m.order = \"random\", results may differ across different runs code unless seed set specified set.seed(). default NULL corresponds \"data\". See method_nearest information. arguments distance (related arguments), exact, mahvars, discard (related arguments), replace, caliper (related arguments), ratio ignored warning.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coarsened Exact Matching — method_cem","text":"coarsening exact matches coarsened variables, grouping cutpoints arguments can used modify matching specification. Reducing number cutpoints grouping variable values together can make easier find matches. See Examples . Removing variables can also help (likely balanced unless highly correlated included variables). take advantage coarsened exact matching without failing find matches, covariates can manually coarsened outside matchit() supplied exact argument call matchit() another matching method. Setting k2k = TRUE equivalent first coarsened exact matching k2k = FALSE supplying stratum membership exact matching variable (.e., exact) another call matchit() method = \"nearest\". also equivalent performing nearest neighbor matching supplying coarsened versions variables exact, except method = \"cem\" automatically coarsens continuous variables. estimand argument supplied method = \"cem\" functions way alternate matching calls, .e., determining \"focal\" group controls order matching.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":"grouping-and-cutpoints","dir":"Reference","previous_headings":"","what":"Grouping and Cutpoints","title":"Coarsened Exact Matching — method_cem","text":"grouping cutpoints arguments allow one fine-tune coarsening covariates. grouping used combining categories categorical covariates cutpoints used binning numeric covariates. values supplied arguments iteratively changed matching solution balances covariate balance remaining sample size obtained. arguments described .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":"grouping","dir":"Reference","previous_headings":"","what":"grouping","title":"Coarsened Exact Matching — method_cem","text":"argument grouping must list, component name categorical variable, levels combined. component must list; list contains one vectors levels, vector corresponds levels combined single category. example, variable amount levels \"none\", \"\", \"lot\", one enter grouping = list(amount = list(c(\"none\"), c(\"\", \"lot\"))), group \"\" \"lot\" single category leave \"none\" category. levels left list variable left alone (c(\"none\") omitted previous code). Note categorical variable appear grouping, coarsened, exact matching take place . grouping used numeric variables values; use cutpoints, described , instead.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":"cutpoints","dir":"Reference","previous_headings":"","what":"cutpoints","title":"Coarsened Exact Matching — method_cem","text":"argument cutpoints must also list, component name numeric variables binned. (shortcut, can also single value applied numeric variables). component can take one three forms: vector cutpoints separate bins, single number giving number bins, string corresponding algorithm used compute number bins. values boundary placed higher bin; e.g., cutpoints c(0, 5, 10), values 5 placed bin values 6, 7, 8, 9, values 10 placed different bin. Internally, values -Inf Inf appended beginning end range. given single number defining number bins, bin boundaries maximum minimum values variable bin boundaries evenly spaced , .e., quantiles. value 0 perform binning (equivalent exact matching variable), value 1 remove variable exact matching variables still used pair matching k2k = TRUE. allowable strings include \"sturges\", \"scott\", \"fd\", use corresponding binning method, \"q#\" # number, splits variable # equally-sized bins (.e., quantiles). example way supply argument cutpoints following: split X1 4 bins, X2 bins based provided boundaries, X3 number bins determined grDevices::nclass.scott(), X4 quintiles. numeric variables split number bins determined grDevices::nclass.Sturges(), default.","code":"cutpoints = list(X1 = 4,                  X2 = c(1.7, 5.5, 10.2),                  X3 = \"scott\",                  X4 = \"q5\")"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Coarsened Exact Matching — method_cem","text":"method rely cem package, instead using code written MatchIt, design based original cem functions. Versions MatchIt prior 4.1.0 rely cem, results may differ versions. differences ways MatchIt cem (older versions MatchIt) differ executing coarsened exact matching, described . MatchIt, single number supplied cutpoints, describes number bins; cem, describes number cutpoints separating bins. MatchIt method closer hist() processes breaks points create bins. MatchIt, values cutpoint boundaries placed higher bin; cem, placed lower bin. avoid consequences choice, ensure bin boundaries coincide observed values variables. cutpoints used, \"ss\" (Shimazaki-Shinomoto's rule) can used cem MatchIt. k2k = TRUE, MatchIt matches original variables (scaled), whereas cem matches coarsened variables. variables already exactly matched coarsened variables, matching cem equivalent random matching within strata. k2k = TRUE, MatchIt matched units identified pair membership, original stratum membership prior 1:1 matching discarded. cem, pairs identified beyond stratum members part . k2k = TRUE, k2k.method = \"mahalanobis\" can requested MatchIt cem.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":"outputs","dir":"Reference","previous_headings":"","what":"Outputs","title":"Coarsened Exact Matching — method_cem","text":"outputs described matchit() returned method = \"cem\" except match.matrix. k2k = TRUE, match.matrix component matched pairs also included. include.obj ignored.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Coarsened Exact Matching — method_cem","text":"manuscript, need cite another package using method = \"cem\" matching performed completely within MatchIt. example, sentence might read: Coarsened exact matching performed using MatchIt package (Ho, Imai, King, & Stuart, 2011) R. good idea cite following article, develops theory behind coarsened exact matching: Iacus, S. M., King, G., & Porro, G. (2012). Causal Inference without Balance Checking: Coarsened Exact Matching. Political Analysis, 20(1), 1–24. doi:10.1093/pan/mpr013","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_cem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coarsened Exact Matching — method_cem","text":"","code":"data(\"lalonde\")  # Coarsened exact matching on age, race, married, and educ with educ # coarsened into 5 bins and race coarsened into 2 categories, # grouping \"white\" and \"hispan\" together m.out1 <- matchit(treat ~ age + race + married + educ, data = lalonde,                   method = \"cem\", cutpoints = list(educ = 5),                   grouping = list(race = list(c(\"white\", \"hispan\"),                                               c(\"black\")))) m.out1 #> A `matchit` object #>  - method: Coarsened exact matching #>  - number of obs.: 614 (original), 393 (matched) #>  - target estimand: ATT #>  - covariates: age, race, married, educ summary(m.out1) #>  #> Call: #> matchit(formula = treat ~ age + race + married + educ, data = lalonde,  #>     method = \"cem\", cutpoints = list(educ = 5), grouping = list(race = list(c(\"white\",  #>         \"hispan\"), c(\"black\")))) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #>            eCDF Max #> age          0.1577 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> married      0.3236 #> educ         0.1114 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              24.1007       23.7091          0.0547     0.8882    0.0140 #> raceblack         0.8188        0.8188          0.0000          .    0.0000 #> racehispan        0.0671        0.0360          0.1317          .    0.0312 #> racewhite         0.1141        0.1452         -0.1051          .    0.0312 #> married           0.1745        0.1745         -0.0000          .    0.0000 #> educ             10.5369       10.8649         -0.1631     0.7974    0.0177 #>            eCDF Max Std. Pair Dist. #> age          0.0897          0.1555 #> raceblack    0.0000          0.0000 #> racehispan   0.0312          0.4829 #> racewhite    0.0312          0.3853 #> married      0.0000          0.0000 #> educ         0.1865          0.3962 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   52.84     149 #> Matched        244.       149 #> Unmatched      185.        36 #> Discarded        0.         0 #>   # The same but requesting 1:1 Mahalanobis distance matching with # the k2k and k2k.method argument. Note the remaining number of units # is smaller than when retaining the full matched sample. m.out2 <- matchit(treat ~ age + race + married + educ, data = lalonde,                   method = \"cem\", cutpoints = list(educ = 5),                   grouping = list(race = list(c(\"white\", \"hispan\"),                                               \"black\")),                   k2k = TRUE, k2k.method = \"mahalanobis\") m.out2 #> A `matchit` object #>  - method: Coarsened exact matching #>  - number of obs.: 614 (original), 170 (matched) #>  - target estimand: ATT #>  - covariates: age, race, married, educ summary(m.out2, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + race + married + educ, data = lalonde,  #>     method = \"cem\", cutpoints = list(educ = 5), grouping = list(race = list(c(\"white\",  #>         \"hispan\"), \"black\")), k2k = TRUE, k2k.method = \"mahalanobis\") #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              23.6353       23.4118          0.0312     0.9022    0.0126 #> raceblack         0.6824        0.6824          0.0000          .    0.0000 #> racehispan        0.1176        0.0706          0.1990          .    0.0471 #> racewhite         0.2000        0.2471         -0.1588          .    0.0471 #> married           0.2118        0.2118          0.0000          .    0.0000 #> educ             10.2588       10.5176         -0.1287     0.8036    0.0149 #>            eCDF Max Std. Pair Dist. #> age          0.0824          0.1036 #> raceblack    0.0000          0.0000 #> racehispan   0.0471          0.1990 #> racewhite    0.0471          0.1588 #> married      0.0000          0.0000 #> educ         0.1294          0.2106 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched        85      85 #> Unmatched     344     100 #> Discarded       0       0 #>"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_exact.html","id":null,"dir":"Reference","previous_headings":"","what":"Exact Matching — method_exact","title":"Exact Matching — method_exact","text":"matchit(), setting method = \"exact\" performs exact matching. exact matching, complete cross covariates used form subclasses defined combination covariate levels. subclass contain treated control units discarded, leaving subclasses containing treatment control units exactly equal included covariates. benefits exact matching confounding due covariates included completely eliminated, regardless functional form treatment outcome models. problem typically many units discarded, sometimes dramatically reducing precision changing target population inference. use exact matching combination another matching method (.e., exact match covariates form matching others), use exact argument method. page details allowable arguments method = \"exact\". See matchit() explanation argument means general context can specified. matchit() used exact matching:","code":"matchit(formula,         data = NULL,         method = \"exact\",         estimand = \"ATT\",         s.weights = NULL,         verbose = FALSE,         ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_exact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exact Matching — method_exact","text":"formula two-sided formula object containing treatment covariates used creating subclasses defined full cross covariate levels. data data frame containing variables named formula. found data, variables sought environment. method set \"exact\". estimand string containing desired estimand. Allowable options include \"ATT\", \"ATC\", \"ATE\". estimand controls weights computed; see Computing Weights section matchit() details. s.weights variable containing sampling weights incorporated balance statistics. weights affect matching process. verbose logical; whether information matching process printed console. ... ignored. arguments distance (related arguments), exact, mahvars, discard (related arguments), replace, m.order, caliper (related arguments), ratio ignored warning.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_exact.html","id":"outputs","dir":"Reference","previous_headings":"","what":"Outputs","title":"Exact Matching — method_exact","text":"outputs described matchit() returned method = \"exact\" except match.matrix. matching strata indexed treated units forms matching. include.obj ignored.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_exact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Exact Matching — method_exact","text":"manuscript, need cite another package using method = \"exact\" matching performed completely within MatchIt. example, sentence might read: Exact matching performed using MatchIt package (Ho, Imai, King, & Stuart, 2011) R.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_exact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exact Matching — method_exact","text":"","code":"data(\"lalonde\")  # Exact matching on age, race, married, and educ m.out1 <- matchit(treat ~ age + race + married + educ, data = lalonde,                   method = \"exact\") m.out1 #> A `matchit` object #>  - method: Exact matching #>  - number of obs.: 614 (original), 113 (matched) #>  - target estimand: ATT #>  - covariates: age, race, married, educ summary(m.out1) #>  #> Call: #> matchit(formula = treat ~ age + race + married + educ, data = lalonde,  #>     method = \"exact\") #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #>            eCDF Max #> age          0.1577 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> married      0.3236 #> educ         0.1114 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              19.9815       19.9815               0     0.9936         0 #> raceblack         0.7778        0.7778               0          .         0 #> racehispan        0.0370        0.0370               0          .         0 #> racewhite         0.1852        0.1852               0          .         0 #> married           0.0370        0.0370               0          .         0 #> educ             10.3333       10.3333               0     0.9936         0 #>            eCDF Max Std. Pair Dist. #> age               0               0 #> raceblack         0               0 #> racehispan        0               0 #> racewhite         0               0 #> married           0               0 #> educ              0               0 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   40.36      54 #> Matched         59.        54 #> Unmatched      370.       131 #> Discarded        0.         0 #>"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_full.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal Full Matching — method_full","title":"Optimal Full Matching — method_full","text":"matchit(), setting method = \"full\" performs optimal full matching, form subclassification wherein units, treatment control (.e., \"full\" sample), assigned subclass receive least one match. matching optimal sense sum absolute distances treated control units subclass small possible. method relies wrapper optmatchfullmatch. Advantages optimal full matching include matching order required specified, units need discarded, less likely extreme within-subclass distances large, unlike standard subclassification. primary output full matching set matching weights can applied matched sample; way, full matching can seen robust alternative propensity score weighting, robust sense propensity score model need correct estimate treatment effect without bias. Note: large samples, optimization may fail run slowly; one can try using method = \"quick\" instead, also performs full matching can much faster. page details allowable arguments method = \"full\". See matchit() explanation argument means general context can specified. matchit() used optimal full matching:","code":"matchit(formula,         data = NULL,         method = \"full\",         distance = \"glm\",         link = \"logit\",         distance.options = list(),         estimand = \"ATT\",         exact = NULL,         mahvars = NULL,         anitexact = NULL,         discard = \"none\",         reestimate = FALSE,         s.weights = NULL,         caliper = NULL,         std.caliper = TRUE,         verbose = FALSE,         ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_full.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal Full Matching — method_full","text":"formula two-sided formula object containing treatment covariates used creating distance measure used matching. formula supplied functions estimate distance measure. data data frame containing variables named formula. found data, variables sought environment. method set \"full\". distance distance measure used. See distance allowable options. Can supplied distance matrix. link distance specified method estimating propensity scores, additional argument controlling link function used estimating distance measure. See distance allowable options option. distance.options named list containing additional arguments supplied function estimates distance measure determined argument distance. estimand string containing desired estimand. Allowable options include \"ATT\", \"ATC\", \"ATE\". estimand controls weights computed; see Computing Weights section matchit() details. exact variables exact matching take place. mahvars variables Mahalanobis distance matching take place distance corresponds propensity score (e.g., caliper matching discard units common support). specified, distance measure used matching. antiexact variables anti-exact matching take place. Anti-exact matching processed using optmatchantiExactMatch. discard string containing method discarding units outside region common support. allowed distance corresponds propensity score. reestimate discard \"none\", whether re-estimate propensity score remaining sample prior matching. s.weights variable containing sampling weights incorporated propensity score models balance statistics. caliper width(s) caliper(s) used caliper matching. Calipers processed optmatchcaliper. Positive negative calipers allowed. See Notes Examples. std.caliper logical; calipers specified, whether standard deviation units (TRUE) raw units (FALSE). verbose logical; whether information matching process printed console. ... additional arguments passed optmatchfullmatch. Allowed arguments include min.controls, max.controls, omit.fraction, mean.controls, tol, solver. See optmatchfullmatch documentation details. general, tol set low number (e.g., 1e-7) get precise solution. arguments replace, m.order, ratio ignored warning.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_full.html","id":"mahalanobis-distance-matching","dir":"Reference","previous_headings":"","what":"Mahalanobis Distance Matching","title":"Optimal Full Matching — method_full","text":"Mahalanobis distance matching can done one two ways: propensity score needs estimated, distance set \"mahalanobis\", Mahalanobis distance matching occur using variables formula. Arguments discard mahvars ignored, caliper can placed named variables. example, perform simple Mahalanobis distance matching, following run: propensity score needs estimated reason, e.g., common support discard creating caliper, distance whatever method used estimate propensity score vector distance measures, .e., \"mahalanobis\". Use mahvars specify variables used create Mahalanobis distance. example, perform Mahalanobis within propensity score caliper, following run:","code":"matchit(treat ~ X1 + X2, method = \"nearest\",         distance = \"mahalanobis\") matchit(treat ~ X1 + X2 + X3, method = \"nearest\",         distance =  \"glm\", caliper = .25,         mahvars = ~ X1 + X2)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_full.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Optimal Full Matching — method_full","text":"Calipers can used min.controls left default. option \"optmatch_max_problem_size\" automatically set Inf matching process, different default optmatch. enables matching problems size run, may also let huge, infeasible problems get potentially take long time crash R. See optmatchsetMaxProblemSize details.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_full.html","id":"outputs","dir":"Reference","previous_headings":"","what":"Outputs","title":"Optimal Full Matching — method_full","text":"outputs described matchit() returned method = \"full\" except match.matrix. matching strata indexed treated units forms matching. include.obj = TRUE call matchit(), output call optmatchfullmatch included output. exact specified, list objects, one stratum exact variables.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_full.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal Full Matching — method_full","text":"manuscript, sure cite following paper using matchit() method = \"full\": Hansen, B. B., & Klopfer, S. O. (2006). Optimal Full Matching Related Designs via Network Flows. Journal Computational Graphical Statistics, 15(3), 609–627. doi:10.1198/106186006X137047 example, sentence might read: Optimal full matching performed using MatchIt package (Ho, Imai, King, & Stuart, 2011) R, calls functions optmatch package (Hansen & Klopfer, 2006). Theory also developed following article: Hansen, B. B. (2004). Full Matching Observational Study Coaching SAT. Journal American Statistical Association, 99(467), 609–618. doi:10.1198/016214504000000647","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_full.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal Full Matching — method_full","text":"","code":"data(\"lalonde\")  # Optimal full PS matching m.out1 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"full\") m.out1 #> A `matchit` object #>  - method: Optimal full matching #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 614 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out1) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"full\") #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.5762          0.0054     0.9930    0.0041 #> age              25.8162       24.8095          0.1407     0.4976    0.0795 #> educ             10.3459       10.3452          0.0004     0.5830    0.0206 #> raceblack         0.8432        0.8347          0.0236          .    0.0086 #> racehispan        0.0595        0.0657         -0.0266          .    0.0063 #> racewhite         0.0973        0.0996         -0.0078          .    0.0023 #> nodegree          0.7081        0.7056          0.0056          .    0.0025 #> married           0.1892        0.1368          0.1338          .    0.0524 #> re74           2095.5737     2363.4473         -0.0548     1.1080    0.0424 #> re75           1532.0553     1632.4020         -0.0312     1.8588    0.0704 #>            eCDF Max Std. Pair Dist. #> distance     0.0486          0.0192 #> age          0.3131          1.3111 #> educ         0.0548          1.2390 #> raceblack    0.0086          0.0324 #> racehispan   0.0063          0.5400 #> racewhite    0.0023          0.3911 #> nodegree     0.0025          0.9593 #> married      0.0524          0.4715 #> re74         0.2492          0.8654 #> re75         0.2366          0.8099 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   52.11     185 #> Matched        429.       185 #> Unmatched        0.         0 #> Discarded        0.         0 #>   # Optimal full Mahalanobis distance matching within a PS caliper m.out2 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"full\", caliper = .01,                   mahvars = ~ age + educ + re74 + re75) m.out2 #> A `matchit` object #>  - method: Optimal full matching #>  - distance: Mahalanobis [matching] #>              Propensity score [caliper] #>  #>              - estimated with logistic regression #>  - caliper: <distance> (0.003) #>  - number of obs.: 614 (original), 349 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out2, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"full\", mahvars = ~age +  #>     educ + re74 + re75, caliper = 0.01) #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5564        0.5566         -0.0012     0.9885    0.0028 #> age              25.1940       24.4645          0.1020     0.5323    0.0681 #> educ             10.3060       10.5529         -0.1228     0.6813    0.0193 #> raceblack         0.7985        0.8022         -0.0103          .    0.0037 #> racehispan        0.0672        0.0596          0.0321          .    0.0076 #> racewhite         0.1343        0.1382         -0.0131          .    0.0039 #> nodegree          0.6716        0.6742         -0.0057          .    0.0026 #> married           0.1642        0.1189          0.1157          .    0.0453 #> re74           1504.8003     2669.4440         -0.2383     0.4985    0.0889 #> re75           1242.9898     1479.5812         -0.0735     1.8382    0.0762 #>            eCDF Max Std. Pair Dist. #> distance     0.0373          0.0063 #> age          0.2709          1.1149 #> educ         0.0812          1.1082 #> raceblack    0.0037          0.0105 #> racehispan   0.0076          0.5788 #> racewhite    0.0039          0.4490 #> nodegree     0.0026          0.8782 #> married      0.0453          0.4951 #> re74         0.3362          0.6849 #> re75         0.2368          0.6460 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   61.97     134 #> Matched        215.       134 #> Unmatched      214.        51 #> Discarded        0.         0 #>   # Optimal full Mahalanobis distance matching within calipers # of 500 on re74 and re75 m.out3 <- matchit(treat ~ age + educ + re74 + re75,                   data = lalonde, distance = \"mahalanobis\",                   method = \"full\",                   caliper = c(re74 = 500, re75 = 500),                   std.caliper = FALSE) m.out3 #> A `matchit` object #>  - method: Optimal full matching #>  - distance: Mahalanobis - caliper: re74 (500), re75 (500) #>  - number of obs.: 614 (original), 391 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, re74, re75 summary(m.out3, addlvariables = ~race + nodegree + married,         data = lalonde, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + re74 + re75, data = lalonde,  #>     method = \"full\", distance = \"mahalanobis\", caliper = c(re74 = 500,  #>         re75 = 500), std.caliper = FALSE) #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              25.8438       26.6668         -0.1150     0.6314    0.0391 #> educ             10.2562       10.2998         -0.0217     0.5406    0.0266 #> re74            902.3844      927.5659         -0.0052     0.9952    0.0089 #> re75            661.1024      674.8033         -0.0043     1.0111    0.0090 #> raceblack         0.8500        0.3065          1.4948          .    0.5435 #> racehispan        0.0437        0.1258         -0.3469          .    0.0820 #> racewhite         0.1062        0.5677         -1.5570          .    0.4614 #> nodegree          0.7312        0.6768          0.1197          .    0.0544 #> married           0.1625        0.4717         -0.7895          .    0.3092 #>            eCDF Max Std. Pair Dist. #> age          0.0868          0.5037 #> educ         0.0623          0.5850 #> re74         0.1957          0.0249 #> re75         0.0871          0.0421 #> raceblack    0.5435          1.7611 #> racehispan   0.0820          0.7605 #> racewhite    0.4614          1.8935 #> nodegree     0.0544          0.3086 #> married      0.3092          1.1113 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   54.18     160 #> Matched        231.       160 #> Unmatched      198.        25 #> Discarded        0.         0 #>"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_genetic.html","id":null,"dir":"Reference","previous_headings":"","what":"Genetic Matching — method_genetic","title":"Genetic Matching — method_genetic","text":"matchit(), setting method = \"genetic\" performs genetic matching. Genetic matching form nearest neighbor matching distances computed generalized Mahalanobis distance, generalization Mahalanobis distance scaling factor covariate represents importance covariate distance. genetic algorithm used select scaling factors. scaling factors chosen maximize criterion related covariate balance, can chosen, default smallest p-value covariate balance tests among covariates. method relies wrapper MatchingGenMatch MatchingMatch, use rgenoudgenoud perform optimization using genetic algorithm. page details allowable arguments method = \"genetic\". See matchit() explanation argument means general context can specified. matchit() used genetic matching:","code":"matchit(formula,         data = NULL,         method = \"genetic\",         distance = \"glm\",         link = \"logit\",         distance.options = list(),         estimand = \"ATT\",         exact = NULL,         mahvars = NULL,         antiexact = NULL,         discard = \"none\",         reestimate = FALSE,         s.weights = NULL,         replace = FALSE,         m.order = NULL,         caliper = NULL,         ratio = 1,         verbose = FALSE,         ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_genetic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Genetic Matching — method_genetic","text":"formula two-sided formula object containing treatment covariates used creating distance measure used matching. formula supplied functions estimate distance measure used determine covariates whose balance optimized. data data frame containing variables named formula. found data, variables sought environment. method set \"genetic\". distance distance measure used. See distance allowable options. set method estimating propensity scores numeric vector distance values, distance measure included covariates formula supplied generalized Mahalanobis distance matrix unless mahvars specified. Otherwise, covariates formula supplied generalized Mahalanobis distance matrix scaling factors chosen. distance supplied distance matrix. Supplying method computing distance matrix (e.g., \"mahalanobis\") effect omitting propensity score affect distance units computed otherwise. link distance specified method estimating propensity scores, additional argument controlling link function used estimating distance measure. See distance allowable options option. distance.options named list containing additional arguments supplied function estimates distance measure determined argument distance. estimand string containing desired estimand. Allowable options include \"ATT\" \"ATC\". See Details. exact variables exact matching take place. mahvars distance corresponds propensity score (e.g., caliper matching discard units common support), covariates supplied generalized Mahalanobis distance matrix matching. unspecified, variables formula supplied distance matrix. Use mahvars supply subset. Even mahvars specified, balance optimized covariates formula. See Details. antiexact variables anti-exact matching take place. Anti-exact matching processed using restrict argument Matching::GenMatch() Matching::Match(). discard string containing method discarding units outside region common support. allowed distance corresponds propensity score. reestimate discard \"none\", whether re-estimate propensity score remaining sample prior matching. s.weights variable containing sampling weights incorporated propensity score models balance statistics. also supplied GenMatch() use computing balance t-test p-values process matching. replace whether matching done replacement. m.order order matching takes place. Allowable options include \"largest\", matching takes place descending order distance measures; \"smallest\", matching takes place ascending order distance measures; \"random\", matching takes place random order; \"data\" matching takes place based order units data. m.order = \"random\", results may differ across different runs code unless seed set specified set.seed(). default NULL corresponds \"largest\" propensity score estimated supplied vector \"data\" otherwise. caliper width(s) caliper(s) used caliper matching. See Details Examples. std.caliper logical; calipers specified, whether standard deviation units (TRUE) raw units (FALSE). ratio many control units matched treated unit k:1 matching. single integer value. verbose logical; whether information matching process printed console. TRUE, output GenMatch() print.level = 2 displayed. Default FALSE printing warnings. ... additional arguments passed MatchingGenMatch. Potentially useful options include pop.size, max.generations, fit.func. pop.size specified, warning Matching thrown reminding change . Note ties CommonSupport arguments set FALSE changed. distance.tolerance specified, set 0, whereas default Matching 1e-5.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_genetic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Genetic Matching — method_genetic","text":"genetic matching, covariates play three roles: 1) variables balance optimized, 2) variables generalized Mahalanobis distance units, 3) estimating propensity score. Variables supplied formula always used role (1), variables balance optimized. distance corresponds propensity score, covariates also used estimate propensity score (unless supplied). mahvars specified, named variables form covariates go distance matrix. Otherwise, variables formula along propensity score go distance matrix. leads three ways use distance mahvars perform matching: distance corresponds propensity score mahvars specified, covariates formula along propensity score used form generalized Mahalanobis distance matrix. default typical use method = \"genetic\" matchit(). distance corresponds propensity score mahvars specified, covariates mahvars used form generalized Mahalanobis distance matrix. covariates formula used estimate propensity score balance optimized genetic algorithm. propensity score included generalized Mahalanobis distance matrix. distance method computing distance matrix (e.g.,\"mahalanobis\"), propensity score estimated, covariates formula used form generalized Mahalanobis distance matrix. specific method supplied bearing distance matrix computed; simply serves signal omit estimation propensity score. caliper specified, variables mentioned caliper, possibly including propensity score, added matching variables used form generalized Mahalanobis distance matrix. Matching allow separation caliper variables matching variables genetic matching.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_genetic.html","id":"estimand","dir":"Reference","previous_headings":"","what":"Estimand","title":"Genetic Matching — method_genetic","text":"estimand argument controls whether control units selected matched treated units (estimand = \"ATT\") treated units selected matched control units (estimand = \"ATC\"). \"focal\" group (e.g., treated units ATT) typically made smaller treatment group, warning thrown set way unless replace = TRUE. Setting estimand = \"ATC\" equivalent swapping treated control labels treatment variable. estimand = \"ATC\", default m.order \"smallest\", match.matrix component output names control units rownames filled names matched treated units (opposite estimand = \"ATT\"). Note argument supplied estimand necessarily correspond estimand actually targeted; merely switch trigger treatment group considered \"focal\". Note GenMatch() Match() support ATE estimand, matchit() supports ATT ATC genetic matching.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_genetic.html","id":"reproducibility","dir":"Reference","previous_headings":"","what":"Reproducibility","title":"Genetic Matching — method_genetic","text":"Genetic matching involves random component, seed must set using set.seed() ensure reproducibility. cluster used parallel processing, seed must compatible parallel processing (e.g., setting type = \"L'Ecuyer-CMRG\").","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_genetic.html","id":"outputs","dir":"Reference","previous_headings":"","what":"Outputs","title":"Genetic Matching — method_genetic","text":"outputs described matchit() returned method = \"genetic\". replace = TRUE, subclass component omitted. include.obj = TRUE call matchit(), output call MatchingGenMatch included output.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_genetic.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Genetic Matching — method_genetic","text":"manuscript, sure cite following papers using matchit() method = \"genetic\": Diamond, ., & Sekhon, J. S. (2013). Genetic matching estimating causal effects: general multivariate matching method achieving balance observational studies. Review Economics Statistics, 95(3), 932–945. doi:10.1162/REST_a_00318 Sekhon, J. S. (2011). Multivariate Propensity Score Matching Software Automated Balance Optimization: Matching package R. Journal Statistical Software, 42(1), 1–52. doi:10.18637/jss.v042.i07 example, sentence might read: Genetic matching performed using MatchIt package (Ho, Imai, King, & Stuart, 2011) R, calls functions Matching package (Diamond & Sekhon, 2013; Sekhon, 2011).","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_genetic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genetic Matching — method_genetic","text":"","code":"data(\"lalonde\")  # 1:1 genetic matching with PS as a covariate m.out1 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"genetic\",                   pop.size = 10) #use much larger pop.size m.out1 #> A `matchit` object #>  - method: 1:1 genetic matching without replacement #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 370 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out1) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"genetic\", pop.size = 10) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.3510          1.0280     0.6880    0.1748 #> age              25.8162       25.9135         -0.0136     0.4954    0.0670 #> educ             10.3459       10.0865          0.1290     0.5967    0.0245 #> raceblack         0.8432        0.4703          1.0259          .    0.3730 #> racehispan        0.0595        0.2811         -0.9372          .    0.2216 #> racewhite         0.0973        0.2486         -0.5107          .    0.1514 #> nodegree          0.7081        0.6486          0.1308          .    0.0595 #> married           0.1892        0.3405         -0.3864          .    0.1514 #> re74           2095.5737     3393.9055         -0.2657     0.7718    0.0949 #> re75           1532.0553     2011.2096         -0.1488     1.0304    0.0713 #>            eCDF Max Std. Pair Dist. #> distance     0.4216          1.0326 #> age          0.1946          1.1664 #> educ         0.0703          0.4463 #> raceblack    0.3730          1.0259 #> racehispan   0.2216          1.3943 #> racewhite    0.1514          0.5107 #> nodegree     0.0595          0.1308 #> married      0.1514          0.6625 #> re74         0.2973          0.3498 #> re75         0.2054          0.4251 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       185     185 #> Unmatched     244       0 #> Discarded       0       0 #>   # 2:1 genetic matching with replacement without PS m.out2 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"genetic\", replace = TRUE,                   ratio = 2, distance = \"mahalanobis\",                   pop.size = 10) #use much larger pop.size m.out2 #> A `matchit` object #>  - method: 2:1 genetic matching with replacement #>  - distance: Mahalanobis - number of obs.: 614 (original), 302 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out2, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"genetic\", distance = \"mahalanobis\",  #>     replace = TRUE, ratio = 2, pop.size = 10) #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              25.8162       25.0595          0.1058     0.7234    0.0412 #> educ             10.3459       10.3189          0.0134     1.0229    0.0074 #> raceblack         0.8432        0.8378          0.0149          .    0.0054 #> racehispan        0.0595        0.0595          0.0000          .    0.0000 #> racewhite         0.0973        0.1027         -0.0182          .    0.0054 #> nodegree          0.7081        0.7081          0.0000          .    0.0000 #> married           0.1892        0.1622          0.0690          .    0.0270 #> re74           2095.5737     2071.5698          0.0049     1.3109    0.0287 #> re75           1532.0553     1104.6774          0.1328     1.7164    0.0382 #>            eCDF Max Std. Pair Dist. #> age          0.1703          0.4397 #> educ         0.0324          0.2420 #> raceblack    0.0054          0.0149 #> racehispan   0.0000          0.0000 #> racewhite    0.0054          0.0182 #> nodegree     0.0000          0.0000 #> married      0.0270          0.1104 #> re74         0.1757          0.2469 #> re75         0.0865          0.2999 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   40.74     185 #> Matched        117.       185 #> Unmatched      312.         0 #> Discarded        0.         0 #>   # 1:1 genetic matching on just age, educ, re74, and re75 # within calipers on PS and educ; other variables are # used to estimate PS m.out3 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"genetic\",                   mahvars = ~ age + educ + re74 + re75,                   caliper = c(.05, educ = 2),                   std.caliper = c(TRUE, FALSE),                   pop.size = 10) #use much larger pop.size m.out3 #> A `matchit` object #>  - method: 1:1 genetic matching without replacement #>  - distance: Mahalanobis [matching] #>              Propensity score [caliper] #>  #>              - estimated with logistic regression #>  - caliper: <distance> (0.015), educ (2) #>  - number of obs.: 614 (original), 206 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out3, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"genetic\", mahvars = ~age +  #>     educ + re74 + re75, caliper = c(0.05, educ = 2), std.caliper = c(TRUE,  #>     FALSE), pop.size = 10) #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.4937        0.4870          0.0305     1.0220    0.0105 #> age              25.5340       24.9612          0.0801     0.4989    0.0784 #> educ             10.1553       10.2913         -0.0676     0.9739    0.0133 #> raceblack         0.7184        0.6990          0.0534          .    0.0194 #> racehispan        0.1068        0.0971          0.0411          .    0.0097 #> racewhite         0.1748        0.2039         -0.0983          .    0.0291 #> nodegree          0.7087        0.6699          0.0854          .    0.0388 #> married           0.2233        0.2039          0.0496          .    0.0194 #> re74           2681.1038     2015.1915          0.1363     2.2258    0.0576 #> re75           1891.5406     1535.6796          0.1105     1.9425    0.0316 #>            eCDF Max Std. Pair Dist. #> distance     0.0777          0.0390 #> age          0.2718          0.9186 #> educ         0.0680          0.3573 #> raceblack    0.0194          0.1068 #> racehispan   0.0097          0.3695 #> racewhite    0.0291          0.1638 #> nodegree     0.0388          0.3844 #> married      0.0194          0.5454 #> re74         0.2524          0.5029 #> re75         0.1068          0.5474 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       103     103 #> Unmatched     326      82 #> Discarded       0       0 #>"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":null,"dir":"Reference","previous_headings":"","what":"Nearest Neighbor Matching — method_nearest","title":"Nearest Neighbor Matching — method_nearest","text":"matchit(), setting method = \"nearest\" performs greedy nearest neighbor matching. distance computed treated unit control unit, , one one, treated unit assigned control unit match. matching \"greedy\" sense action taken optimize overall criterion; match selected without considering matches may occur subsequently. page details allowable arguments method = \"nearest\". See matchit() explanation argument means general context can specified. matchit() used nearest neighbor matching:","code":"matchit(formula,         data = NULL,         method = \"nearest\",         distance = \"glm\",         link = \"logit\",         distance.options = list(),         estimand = \"ATT\",         exact = NULL,         mahvars = NULL,         antiexact = NULL,         discard = \"none\",         reestimate = FALSE,         s.weights = NULL,         replace = TRUE,         m.order = NULL,         caliper = NULL,         ratio = 1,         min.controls = NULL,         max.controls = NULL,         verbose = FALSE,         ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nearest Neighbor Matching — method_nearest","text":"formula two-sided formula object containing treatment covariates used creating distance measure used matching. data data frame containing variables named formula. found data, variables sought environment. method set \"nearest\". distance distance measure used. See distance allowable options. Can supplied distance matrix. link distance specified method estimating propensity scores, additional argument controlling link function used estimating distance measure. See distance allowable options option. distance.options named list containing additional arguments supplied function estimates distance measure determined argument distance. estimand string containing desired estimand. Allowable options include \"ATT\" \"ATC\". See Details. exact variables exact matching take place; two units different values exact matching variable paired. mahvars variables Mahalanobis distance matching take place distance corresponds propensity score (e.g., caliper matching discard units common support). specified, distance measure used matching. antiexact variables anti-exact matching take place; two units value anti-exact matching variable paired. discard string containing method discarding units outside region common support. allowed distance corresponds propensity score. reestimate discard \"none\", whether re-estimate propensity score remaining sample prior matching. s.weights variable containing sampling weights incorporated propensity score models balance statistics. replace whether matching done replacement (.e., whether control units can used matches multiple times). See also reuse.max argument . Default FALSE matching without replacement. m.order order matching takes place. Allowable options include \"largest\", matching takes place descending order distance measures; \"smallest\", matching takes place ascending order distance measures; \"closest\", matching takes place ascending order smallest distance units; \"farthest\", matching takes place descending order smallest distance units; \"random\", matching takes place random order; \"data\" matching takes place based order units data. m.order = \"random\", results may differ across different runs code unless seed set specified set.seed(). default NULL corresponds \"largest\" propensity score estimated supplied vector \"data\" otherwise. See Details information. caliper width(s) caliper(s) used caliper matching. Two units difference caliper variable larger caliper paired. See Details Examples. std.caliper logical; calipers specified, whether standard deviation units (TRUE) raw units (FALSE). ratio many control units matched treated unit k:1 matching. variable ratio matching, see section \"Variable Ratio Matching\" Details . ratio greater 1, treated units attempted matched control unit treated unit matched second control unit, etc. reduces possibility control units used treated units receive matches. min.controls, max.controls variable ratio matching, minimum maximum number controls units matched treated unit. See section \"Variable Ratio Matching\" Details . verbose logical; whether information matching process printed console. TRUE, progress bar implemented using RcppProgress displayed along estimate time remaining. ... additional arguments control matching specification: reuse.max numeric; maximum number times control can used match. Setting reuse.max = 1 corresponds matching without replacement (.e., replace = FALSE), setting reuse.max = Inf corresponds traditional matching replacement (.e., replace = TRUE) limit number times control unit can matched. values restrict number times control can matched matching replacement. replace ignored reuse.max specified. unit.id one variables containing unit ID observation, .e., case multiple observations correspond unit. control observation matched, observation unit ID can used matches. ensures control unit used even multiple observations associated . Omitting argument giving observation unique ID.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"mahalanobis-distance-matching","dir":"Reference","previous_headings":"","what":"Mahalanobis Distance Matching","title":"Nearest Neighbor Matching — method_nearest","text":"Mahalanobis distance matching can done one two ways: propensity score needs estimated, distance set \"mahalanobis\", Mahalanobis distance matching occur using variables formula. Arguments discard mahvars ignored, caliper can placed named variables. example, perform simple Mahalanobis distance matching, following run: propensity score needs estimated reason, e.g., common support discard creating caliper, distance whatever method used estimate propensity score vector distance measures. Use mahvars specify variables used create Mahalanobis distance. example, perform Mahalanobis within propensity score caliper, following run:","code":"matchit(treat ~ X1 + X2, method = \"nearest\",         distance = \"mahalanobis\") matchit(treat ~ X1 + X2 + X3, method = \"nearest\",         distance = \"glm\", caliper = .25,         mahvars = ~ X1 + X2)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"estimand","dir":"Reference","previous_headings":"","what":"Estimand","title":"Nearest Neighbor Matching — method_nearest","text":"estimand argument controls whether control units selected matched treated units (estimand = \"ATT\") treated units selected matched control units (estimand = \"ATC\"). \"focal\" group (e.g., treated units ATT) typically made smaller treatment group, warning thrown set way unless replace = TRUE. Setting estimand = \"ATC\" equivalent swapping treated control labels treatment variable. estimand = \"ATC\", default m.order \"smallest\", match.matrix component output names control units rownames filled names matched treated units (opposite estimand = \"ATT\"). Note argument supplied estimand necessarily correspond estimand actually targeted; merely switch trigger treatment group considered \"focal\".","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"variable-ratio-matching","dir":"Reference","previous_headings":"","what":"Variable Ratio Matching","title":"Nearest Neighbor Matching — method_nearest","text":"matchit() can perform variable ratio \"extremal\" matching described Ming Rosenbaum (2000). method tends result better balance fixed ratio matching expense precision. ratio > 1, rather requiring treated units receive ratio matches, treated unit assigned value corresponds number control units matched . values controlled arguments min.controls max.controls, correspond \\(\\alpha\\) \\(\\beta\\), respectively, Ming Rosenbaum (2000), trigger variable ratio matching occur. treated units receive min.controls matches others receive max.controls matches (one unit may intermediate number matches); many units assigned number matches determined algorithm described Ming Rosenbaum (2000, p119). ratio controls many total control units matched: n1 * ratio control units matched, n1 number treated units, yielding total number matched controls fixed ratio matching . Variable ratio matching used Mahalanobis distance matching distance supplied matrix. calculations numbers control units treated unit matched occurs without consideration caliper discard. ratio integer must greater 1 less n0/n1, n0 n1 number control treated units, respectively. Setting ratio = n0/n1 performs crude form full matching control units matched. min.controls specified, set 1 default. min.controls must less ratio, max.controls must greater ratio. See Examples example use.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"using-m-order-closest-or-farthest-","dir":"Reference","previous_headings":"","what":"Using m.order = \"closest\" or \"farthest\"","title":"Nearest Neighbor Matching — method_nearest","text":"m.order can set \"closest\" \"farthest\", work regardless distance measure specified. matches order distance units. First, closest match found treated units pairwise distances computed; m.order = \"closest\" pair smallest distances matched first, m.order = \"farthest\", pair largest distances matched first. , pair second smallest (largest) matched second. matched control ineligible (.e., already used prior match), new match found treated unit, new pair's distance re-computed, pairs re-ordered distance. Using m.order = \"closest\" ensures best possible matches given priority, sense perform similarly m.order = \"smallest\". can used ensure best matches, especially matching caliper. Using m.order = \"farthest\" ensures hardest units match given best chance find close match, sense perform similarly m.order = \"largest\". can used reduce possibility extreme imbalance hard--match units competing controls. Note m.order = \"farthest\" implement \"far matching\" (.e., finding farthest control unit treated unit); defines order closest matches selected.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"reproducibility","dir":"Reference","previous_headings":"","what":"Reproducibility","title":"Nearest Neighbor Matching — method_nearest","text":"Nearest neighbor matching involves random component m.order = \"random\" (propensity estimated using method randomness; see distance details), seed must set case using set.seed() ensure reproducibility. Otherwise, purely deterministic, ties broken based order data appear.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Nearest Neighbor Matching — method_nearest","text":"Sometimes error produced Rcpp along lines \"function 'Rcpp_precious_remove' provided package 'Rcpp'\". immediately clear happens, though thread appears provide insight. fresh session, run remove.packages(c(\"MatchIt\", \"Rcpp\")); install.packages(\"MatchIt\"). sync MatchIt Rcpp ensure work correctly.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"outputs","dir":"Reference","previous_headings":"","what":"Outputs","title":"Nearest Neighbor Matching — method_nearest","text":"outputs described matchit() returned method = \"nearest\". replace = TRUE, subclass component omitted. include.obj ignored.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nearest Neighbor Matching — method_nearest","text":"manuscript, need cite another package using method = \"nearest\" matching performed completely within MatchIt. example, sentence might read: Nearest neighbor matching performed using MatchIt package (Ho, Imai, King, & Stuart, 2011) R.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_nearest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nearest Neighbor Matching — method_nearest","text":"","code":"data(\"lalonde\")  # 1:1 greedy NN matching on the PS m.out1 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"nearest\") m.out1 #> A `matchit` object #>  - method: 1:1 nearest neighbor matching without replacement #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 370 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out1) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"nearest\") #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.3629          0.9739     0.7566    0.1321 #> age              25.8162       25.3027          0.0718     0.4568    0.0847 #> educ             10.3459       10.6054         -0.1290     0.5721    0.0239 #> raceblack         0.8432        0.4703          1.0259          .    0.3730 #> racehispan        0.0595        0.2162         -0.6629          .    0.1568 #> racewhite         0.0973        0.3135         -0.7296          .    0.2162 #> nodegree          0.7081        0.6378          0.1546          .    0.0703 #> married           0.1892        0.2108         -0.0552          .    0.0216 #> re74           2095.5737     2342.1076         -0.0505     1.3289    0.0469 #> re75           1532.0553     1614.7451         -0.0257     1.4956    0.0452 #>            eCDF Max Std. Pair Dist. #> distance     0.4216          0.9740 #> age          0.2541          1.3938 #> educ         0.0757          1.2474 #> raceblack    0.3730          1.0259 #> racehispan   0.1568          1.0743 #> racewhite    0.2162          0.8390 #> nodegree     0.0703          1.0106 #> married      0.0216          0.8281 #> re74         0.2757          0.7965 #> re75         0.2054          0.7381 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       185     185 #> Unmatched     244       0 #> Discarded       0       0 #>   # 3:1 NN Mahalanobis distance matching with # replacement within a PS caliper m.out2 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"nearest\", replace = TRUE,                   mahvars = ~ age + educ + re74 + re75,                   ratio = 3, caliper = .02) m.out2 #> A `matchit` object #>  - method: 3:1 nearest neighbor matching with replacement #>  - distance: Mahalanobis [matching] #>              Propensity score [caliper] #>  #>              - estimated with logistic regression #>  - caliper: <distance> (0.006) #>  - number of obs.: 614 (original), 300 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out2, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"nearest\", mahvars = ~age +  #>     educ + re74 + re75, replace = TRUE, caliper = 0.02, ratio = 3) #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5660        0.5660          0.0003     0.9880    0.0037 #> age              25.5000       24.0010          0.2095     0.5178    0.0835 #> educ             10.3086       10.3930         -0.0420     0.7356    0.0115 #> raceblack         0.8210        0.8169          0.0113          .    0.0041 #> racehispan        0.0679        0.0576          0.0435          .    0.0103 #> racewhite         0.1111        0.1255         -0.0486          .    0.0144 #> nodegree          0.7037        0.6852          0.0407          .    0.0185 #> married           0.1914        0.1132          0.1996          .    0.0782 #> re74           1831.9348     2119.9268         -0.0589     1.2783    0.0528 #> re75           1400.4354     1386.7669          0.0042     2.2735    0.0623 #>            eCDF Max Std. Pair Dist. #> distance     0.0432          0.0128 #> age          0.3508          0.9787 #> educ         0.0381          0.7836 #> raceblack    0.0041          0.0358 #> racehispan   0.0103          0.2643 #> racewhite    0.0144          0.1845 #> nodegree     0.0185          0.5556 #> married      0.0782          0.4588 #> re74         0.2984          0.4634 #> re75         0.2428          0.5274 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   64.23     162 #> Matched        138.       162 #> Unmatched      291.        23 #> Discarded        0.         0 #>   # 1:1 NN Mahalanobis distance matching within calipers # on re74 and re75 and exact matching on married and race m.out3 <- matchit(treat ~ age + educ + re74 + re75, data = lalonde,                   method = \"nearest\", distance = \"mahalanobis\",                   exact = ~ married + race,                   caliper = c(re74 = .2, re75 = .15)) #> Warning: Fewer control units than treated units in some `exact` strata; not all #> treated units will get a match. m.out3 #> A `matchit` object #>  - method: 1:1 nearest neighbor matching without replacement #>  - distance: Mahalanobis - caliper: re74 (1295.593), re75 (494.352) #>  - number of obs.: 614 (original), 166 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, re74, re75, married, race summary(m.out3, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + re74 + re75, data = lalonde,  #>     method = \"nearest\", distance = \"mahalanobis\", exact = ~married +  #>         race, caliper = c(re74 = 0.2, re75 = 0.15)) #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              24.7711       24.6024          0.0236     0.4804    0.0753 #> educ             10.3976       10.0482          0.1738     0.4610    0.0361 #> re74            705.7326      864.0131         -0.0324     0.9038    0.0270 #> re75            592.6384      640.9355         -0.0150     1.0194    0.0150 #> married           0.1687        0.1687          0.0000          .    0.0000 #> raceblack         0.7349        0.7349          0.0000          .    0.0000 #> racehispan        0.0723        0.0723          0.0000          .    0.0000 #> racewhite         0.1928        0.1928          0.0000          .    0.0000 #>            eCDF Max Std. Pair Dist. #> age          0.2410          0.7544 #> educ         0.0964          0.7131 #> re74         0.2410          0.0537 #> re75         0.1084          0.0358 #> married      0.0000          0.0000 #> raceblack    0.0000          0.0000 #> racehispan   0.0000          0.0000 #> racewhite    0.0000          0.0000 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched        83      83 #> Unmatched     346     102 #> Discarded       0       0 #>   # 2:1 variable ratio NN matching on the PS m.out4 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"nearest\", ratio = 2,                   min.controls = 1, max.controls = 12) m.out4 #> A `matchit` object #>  - method: Variable ratio 2:1 nearest neighbor matching without replacement #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 555 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out4, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"nearest\", ratio = 2,  #>     min.controls = 1, max.controls = 12) #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.3608          0.9835     0.7425    0.1414 #> age              25.8162       25.4459          0.0518     0.4560    0.0830 #> educ             10.3459       10.4887         -0.0710     0.5654    0.0236 #> raceblack         0.8432        0.4703          1.0259          .    0.3730 #> racehispan        0.0595        0.2110         -0.6408          .    0.1515 #> racewhite         0.0973        0.3187         -0.7472          .    0.2214 #> nodegree          0.7081        0.6517          0.1240          .    0.0564 #> married           0.1892        0.2218         -0.0833          .    0.0326 #> re74           2095.5737     2614.8070         -0.1063     1.1615    0.0611 #> re75           1532.0553     1714.9169         -0.0568     1.3486    0.0498 #>            eCDF Max Std. Pair Dist. #> distance     0.4216          0.5600 #> age          0.2457          1.4044 #> educ         0.0659          1.3187 #> raceblack    0.3730          0.5129 #> racehispan   0.1515          1.0629 #> racewhite    0.2214          0.8390 #> nodegree     0.0564          1.0760 #> married      0.0326          1.0420 #> re74         0.2912          0.9210 #> re75         0.2020          0.8587 #>  #> Sample Sizes: #>               Control Treated #> All               429     185 #> Matched (ESS)     202     185 #> Matched           370     185 #> Unmatched          59       0 #> Discarded           0       0 #>   # Some units received 1 match and some received 12 table(table(m.out4$subclass[m.out4$treat == 0])) #>  #>   1  10  12  #> 168   1  16"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_optimal.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal Pair Matching — method_optimal","title":"Optimal Pair Matching — method_optimal","text":"matchit(), setting method = \"optimal\" performs optimal pair matching. matching optimal sense sum absolute pairwise distances matched sample small possible. method functionally relies optmatchfullmatch. Advantages optimal pair matching include matching order required specified less likely extreme within-pair distances large, unlike nearest neighbor matching. Generally, however, subset selection method, optimal pair matching tends perform similarly nearest neighbor matching similar subsets units selected matched. page details allowable arguments method = \"optmatch\". See matchit() explanation argument means general context can specified. matchit() used optimal pair matching:","code":"matchit(formula,         data = NULL,         method = \"optimal\",         distance = \"glm\",         link = \"logit\",         distance.options = list(),         estimand = \"ATT\",         exact = NULL,         mahvars = NULL,         antiexact = NULL,         discard = \"none\",         reestimate = FALSE,         s.weights = NULL,         ratio = 1,         min.controls = NULL,         max.controls = NULL,         verbose = FALSE,         ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_optimal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal Pair Matching — method_optimal","text":"formula two-sided formula object containing treatment covariates used creating distance measure used matching. formula supplied functions estimate distance measure. data data frame containing variables named formula. found data, variables sought environment. method set \"optimal\". distance distance measure used. See distance allowable options. Can supplied distance matrix. link distance specified method estimating propensity scores, additional argument controlling link function used estimating distance measure. See distance allowable options option. distance.options named list containing additional arguments supplied function estimates distance measure determined argument distance. estimand string containing desired estimand. Allowable options include \"ATT\" \"ATC\". See Details. exact variables exact matching take place. mahvars variables Mahalanobis distance matching take place distance corresponds propensity score (e.g., caliper matching discard units common support). specified, distance measure used matching. antiexact variables anti-exact matching take place. Anti-exact matching processed using optmatchantiExactMatch. discard string containing method discarding units outside region common support. allowed distance \"mahalanobis\" matrix. reestimate discard \"none\", whether re-estimate propensity score remaining sample prior matching. s.weights variable containing sampling weights incorporated propensity score models balance statistics. ratio many control units matched treated unit k:1 matching. variable ratio matching, see section \"Variable Ratio Matching\" Details . min.controls, max.controls variable ratio matching, minimum maximum number controls units matched treated unit. See section \"Variable Ratio Matching\" Details . verbose logical; whether information matching process printed console. printed depends matching method. Default FALSE printing warnings. ... additional arguments passed optmatchfullmatch. Allowed arguments include tol solver. See optmatchfullmatch documentation details. general, tol set low number (e.g., 1e-7) get precise solution (default 1e-3). arguments replace, caliper, m.order ignored warning.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_optimal.html","id":"mahalanobis-distance-matching","dir":"Reference","previous_headings":"","what":"Mahalanobis Distance Matching","title":"Optimal Pair Matching — method_optimal","text":"Mahalanobis distance matching can done one two ways: propensity score needs estimated, distance set \"mahalanobis\", Mahalanobis distance matching occur using variables formula. Arguments discard mahvars ignored. example, perform simple Mahalanobis distance matching, following run: propensity score needs estimated common support discard, distance whatever method used estimate propensity score vector distance measures, .e., \"mahalanobis\". Use mahvars specify variables used create Mahalanobis distance. example, perform Mahalanobis discarding units outside common support propensity score groups, following run:","code":"matchit(treat ~ X1 + X2, method = \"nearest\",         distance = \"mahalanobis\") matchit(treat ~ X1 + X2 + X3, method = \"nearest\",         distance = \"glm\", discard = \"both\",         mahvars = ~ X1 + X2)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_optimal.html","id":"estimand","dir":"Reference","previous_headings":"","what":"Estimand","title":"Optimal Pair Matching — method_optimal","text":"estimand argument controls whether control units selected matched treated units (estimand = \"ATT\") treated units selected matched control units (estimand = \"ATC\"). \"focal\" group (e.g., treated units ATT) typically made smaller treatment group, warning thrown set . Setting estimand = \"ATC\" equivalent swapping treated control labels treatment variable. estimand = \"ATC\", match.matrix component output names control units rownames filled names matched treated units (opposite estimand = \"ATT\"). Note argument supplied estimand necessarily correspond estimand actually targeted; merely switch trigger treatment group considered \"focal\".","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_optimal.html","id":"variable-ratio-matching","dir":"Reference","previous_headings":"","what":"Variable Ratio Matching","title":"Optimal Pair Matching — method_optimal","text":"matchit() can perform variable ratio matching, involves matching different number control units treated unit. ratio > 1, rather requiring treated units receive ratio matches, arguments max.controls min.controls can specified control maximum minimum number matches treated unit can . ratio controls many total control units matched: n1 * ratio control units matched, n1 number treated units, yielding total number matched controls fixed ratio matching . Variable ratio matching can used distance specification. ratio integer must greater 1 less n0/n1, n0 n1 number control treated units, respectively. Setting ratio = n0/n1 performs restricted form full matching control units matched. min.controls specified, set 1 default. min.controls must less ratio, max.controls must greater ratio. See Examples section method_nearest() example use, optimal matching.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_optimal.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Optimal Pair Matching — method_optimal","text":"Optimal pair matching restricted form optimal full matching number treated units subclass equal 1, whereas unrestricted full matching, multiple treated units can assigned subclass. optmatchpairmatch simply wrapper optmatchfullmatch, performs optimal full matching workhorse method_full. way, matchit() uses optmatch::fullmatch() hood, imposing restrictions make optimal full matching function like optimal pair matching (simply set min.controls >= 1 pass ratio mean.controls argument). distinction important regular use may interest examining source code. option \"optmatch_max_problem_size\" automatically set Inf matching process, different default optmatch. enables matching problems size run, may also let huge, infeasible problems get potentially take long time crash R. See optmatchsetMaxProblemSize details. preprocessing algorithm describe Sävje (2020) used improve speed matching 1:1 matching propensity score. adding additional constraint guarantees solution optimal solution found without constraint, constraint often dramatically reduces size matching problem cost. However, may introduce differences results obtained MatchIt optmatch, though differences shrink smaller values tol used.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_optimal.html","id":"outputs","dir":"Reference","previous_headings":"","what":"Outputs","title":"Optimal Pair Matching — method_optimal","text":"outputs described matchit() returned method = \"optimal\". include.obj = TRUE call matchit(), output call optmatch::fullmatch() included output. exact specified, list objects, one stratum exact variables.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_optimal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal Pair Matching — method_optimal","text":"manuscript, sure cite following paper using matchit() method = \"optimal\": Hansen, B. B., & Klopfer, S. O. (2006). Optimal Full Matching Related Designs via Network Flows. Journal Computational Graphical Statistics, 15(3), 609–627. doi:10.1198/106186006X137047 example, sentence might read: Optimal pair matching performed using MatchIt package (Ho, Imai, King, & Stuart, 2011) R, calls functions optmatch package (Hansen & Klopfer, 2006).","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_optimal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal Pair Matching — method_optimal","text":"","code":"data(\"lalonde\")  #1:1 optimal PS matching with exact matching on race m.out1 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"optimal\", exact = ~race) #> Warning: Fewer control units than treated units in some `exact` strata; not all #> treated units will get a match. m.out1 #> A `matchit` object #>  - method: 1:1 optimal pair matching #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 232 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out1) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"optimal\", exact = ~race) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.4972        0.4901          0.0325     1.0026    0.0056 #> age              25.7845       25.9569         -0.0241     0.4984    0.0711 #> educ             10.0948       10.3966         -0.1501     0.6260    0.0286 #> raceblack         0.7500        0.7500          0.0000          .    0.0000 #> racehispan        0.0948        0.0948          0.0000          .    0.0000 #> racewhite         0.1552        0.1552          0.0000          .    0.0000 #> nodegree          0.6810        0.6121          0.1517          .    0.0690 #> married           0.2414        0.2672         -0.0660          .    0.0259 #> re74           2862.5644     3046.0687         -0.0376     1.4317    0.0569 #> re75           1785.7677     1873.2021         -0.0272     1.6241    0.0506 #>            eCDF Max Std. Pair Dist. #> distance     0.0776          0.0436 #> age          0.2069          1.2024 #> educ         0.0776          1.1705 #> raceblack    0.0000          0.0000 #> racehispan   0.0000          0.0000 #> racewhite    0.0000          0.0000 #> nodegree     0.0690          0.9102 #> married      0.0259          0.5503 #> re74         0.2759          0.7299 #> re75         0.1379          0.8456 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       116     116 #> Unmatched     313      69 #> Discarded       0       0 #>   #2:1 optimal matching on the scaled Euclidean distance m.out2 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"optimal\", ratio = 2,                   distance = \"scaled_euclidean\") m.out2 #> A `matchit` object #>  - method: 2:1 optimal pair matching #>  - distance: Scaled Euclidean - number of obs.: 614 (original), 555 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out2, un = FALSE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"optimal\", distance = \"scaled_euclidean\",  #>     ratio = 2) #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> age              25.8162       26.4757         -0.0922     0.4947    0.0658 #> educ             10.3459       10.2730          0.0363     0.5810    0.0286 #> raceblack         0.8432        0.2351          1.6726          .    0.6081 #> racehispan        0.0595        0.1216         -0.2629          .    0.0622 #> racewhite         0.0973        0.6432         -1.8422          .    0.5459 #> nodegree          0.7081        0.6243          0.1843          .    0.0838 #> married           0.1892        0.4432         -0.6487          .    0.2541 #> re74           2095.5737     4120.1633         -0.4143     0.7972    0.1577 #> re75           1532.0553     2107.1613         -0.1786     1.0608    0.0935 #>            eCDF Max Std. Pair Dist. #> age          0.1405          0.5477 #> educ         0.0865          0.3750 #> raceblack    0.6081          1.6726 #> racehispan   0.0622          0.2629 #> racewhite    0.5459          1.8422 #> nodegree     0.0838          0.1843 #> married      0.2541          0.6487 #> re74         0.4081          0.4806 #> re75         0.2595          0.3195 #>  #> Sample Sizes: #>           Control Treated #> All           429     185 #> Matched       370     185 #> Unmatched      59       0 #> Discarded       0       0 #>"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_quick.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast Generalized Full Matching — method_quick","title":"Fast Generalized Full Matching — method_quick","text":"matchit(), setting method = \"quick\" performs generalized full matching, form subclassification wherein units, treatment control (.e., \"full\" sample), assigned subclass receive least one match. uses algorithm extremely fast compared optimal full matching, labeled \"quick\", expense true optimality. method described Sävje, Higgins, & Sekhon (2021). method relies wrapper quickmatchquickmatch. Advantages generalized full matching include matching order required specified, units need discarded, less likely extreme within-subclass distances large, unlike standard subclassification. primary output generalized full matching set matching weights can applied matched sample; way, generalized full matching can seen robust alternative propensity score weighting, robust sense propensity score model need correct estimate treatment effect without bias. page details allowable arguments method = \"quick\". See matchit() explanation argument means general context can specified. matchit() used generalized full matching:","code":"matchit(formula,         data = NULL,         method = \"quick\",         distance = \"glm\",         link = \"logit\",         distance.options = list(),         estimand = \"ATT\",         exact = NULL,         mahvars = NULL,         discard = \"none\",         reestimate = FALSE,         s.weights = NULL,         caliper = NULL,         std.caliper = TRUE,         verbose = FALSE,         ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_quick.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast Generalized Full Matching — method_quick","text":"formula two-sided formula object containing treatment covariates used creating distance measure used matching. formula supplied functions estimate distance measure. data data frame containing variables named formula. found data, variables sought environment. method set \"quick\". distance distance measure used. See distance allowable options. supplied matrix. link distance specified method estimating propensity scores, additional argument controlling link function used estimating distance measure. See distance allowable options option. distance.options named list containing additional arguments supplied function estimates distance measure determined argument distance. estimand string containing desired estimand. Allowable options include \"ATT\", \"ATC\", \"ATE\". estimand controls weights computed; see Computing Weights section matchit() details. exact variables exact matching take place. mahvars variables Mahalanobis distance matching take place distance corresponds propensity score (e.g., discard units common support). specified, distance measure used matching. discard string containing method discarding units outside region common support. allowed distance corresponds propensity score. reestimate discard \"none\", whether re-estimate propensity score remaining sample prior matching. s.weights variable containing sampling weights incorporated propensity score models balance statistics. caliper width caliper used caliper matching. caliper can placed propensity score negative. std.caliper logical; caliper specified, whether standard deviation units (TRUE) raw units (FALSE). verbose logical; whether information matching process printed console. ... additional arguments passed quickmatchquickmatch. Allowed arguments include treatment_constraints, size_constraint, target, arguments passed scclust::sc_clustering() (see quickmatchquickmatch details). particular, changing seed_method default can improve performance. arguments passed distances::distances(). arguments replace, ratio, min.controls, max.controls, m.order, antiexact ignored warning.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_quick.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fast Generalized Full Matching — method_quick","text":"Generalized full matching similar optimal full matching, additional flexibility can controlled extra arguments available. default, method = \"quick\" performs standard full match units matched (unless restricted caliper) assigned subclass. subclass contain multiple units treatment group. subclasses chosen minimize largest within-subclass distance units (including units treatment group). Notably, generalized full matching requires less memory can run much faster optimal full matching optimal pair matching , cases, even nearest neighbor matching, can used huge datasets (e.g., millions) running minute.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_quick.html","id":"outputs","dir":"Reference","previous_headings":"","what":"Outputs","title":"Fast Generalized Full Matching — method_quick","text":"outputs described matchit() returned method = \"quick\" except match.matrix. matching strata indexed treated units forms matching. include.obj = TRUE call matchit(), output call quickmatchquickmatch included output. exact specified, list objects, one stratum exact variables.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_quick.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fast Generalized Full Matching — method_quick","text":"manuscript, sure cite quickmatch package using matchit() method = \"quick\": Sävje, F., Sekhon, J., & Higgins, M. (2018). quickmatch: Quick generalized full matching. https://CRAN.R-project.org/package=quickmatch example, sentence might read: Generalized full matching performed using MatchIt package (Ho, Imai, King, & Stuart, 2011) R, calls functions quickmatch package (Sävje, Sekhon, & Higgins, 2018). also cite following paper, develops describes method: Sävje, F., Higgins, M. J., & Sekhon, J. S. (2021). Generalized Full Matching. Political Analysis, 29(4), 423–447. doi:10.1017/pan.2020.32","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_quick.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast Generalized Full Matching — method_quick","text":"","code":"data(\"lalonde\")  # Generalize full PS matching m.out1 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"quick\") m.out1 #> A `matchit` object #>  - method: Generalized full matching #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 614 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(m.out1) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"quick\") #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance for Matched Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.5764          0.0047     0.9895    0.0044 #> age              25.8162       25.4476          0.0515     0.5099    0.0728 #> educ             10.3459       10.6781         -0.1652     0.5742    0.0251 #> raceblack         0.8432        0.8376          0.0155          .    0.0056 #> racehispan        0.0595        0.0607         -0.0052          .    0.0012 #> racewhite         0.0973        0.1017         -0.0148          .    0.0044 #> nodegree          0.7081        0.6602          0.1054          .    0.0479 #> married           0.1892        0.1355          0.1371          .    0.0537 #> re74           2095.5737     2873.4651         -0.1592     0.8886    0.0709 #> re75           1532.0553     1634.2731         -0.0318     1.8751    0.0736 #>            eCDF Max Std. Pair Dist. #> distance     0.0541          0.0202 #> age          0.2659          1.2519 #> educ         0.0855          1.2506 #> raceblack    0.0056          0.0265 #> racehispan   0.0012          0.4970 #> racewhite    0.0044          0.3641 #> nodegree     0.0479          0.9324 #> married      0.0537          0.4870 #> re74         0.3004          0.8699 #> re75         0.2760          0.8428 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   50.74     185 #> Matched        429.       185 #> Unmatched        0.         0 #> Discarded        0.         0 #>"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_subclass.html","id":null,"dir":"Reference","previous_headings":"","what":"Subclassification — method_subclass","title":"Subclassification — method_subclass","text":"matchit(), setting method = \"subclass\" performs subclassification distance measure (.e., propensity score). Treatment control units placed subclasses based quantiles propensity score treated group, control group, overall, depending desired estimand. Weights computed based proportion treated units subclass. Subclassification implemented rely package. page details allowable arguments method = \"subclass\". See matchit() explanation argument means general context can specified. matchit() used subclassification:","code":"matchit(formula,         data = NULL,         method = \"subclass\",         distance = \"glm\",         link = \"logit\",         distance.options = list(),         estimand = \"ATT\",         discard = \"none\",         reestimate = FALSE,         s.weights = NULL,         verbose = FALSE,         ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_subclass.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subclassification — method_subclass","text":"formula two-sided formula object containing treatment covariates used creating distance measure used subclassification. data data frame containing variables named formula. found data, variables sought environment. method set \"subclass\". distance distance measure used. See distance allowable options. Must vector distance scores name method estimating propensity scores. link distance specified string, additional argument controlling link function used estimating distance measure. See distance allowable options option. distance.options named list containing additional arguments supplied function estimates distance measure determined argument distance. estimand target estimand. \"ATT\", default, subclasses formed based quantiles distance measure treated group; \"ATC\", subclasses formed based quantiles distance measure control group; \"ATE\", subclasses formed based quantiles distance measure full sample. estimand also controls subclassification weights computed; see Computing Weights section matchit() details. discard string containing method discarding units outside region common support. reestimate discard \"none\", whether re-estimate propensity score remaining sample prior subclassification. s.weights variable containing sampling weights incorporated propensity score models balance statistics. verbose logical; whether information matching process printed console. ... additional arguments control subclassification: subclass either number subclasses desired vector quantiles used divide distance measure subclasses. Default 6. min.n minimum number units treatment group assigned subclass. distance measure divided way fewer min.n units treatment group assigned given subclass, units subclasses reassigned fill deficient subclass. Default 1. arguments exact, mahvars, replace, m.order, caliper (related arguments), ratio ignored warning.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_subclass.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Subclassification — method_subclass","text":"subclassification, effect estimates can computed separately subclasses combined, single marginal effect can estimated using weights full sample. using weights, method sometimes referred marginal mean weighting stratification (MMWS; Hong, 2010) fine stratification weighting (Desai et al., 2017). weights can interpreted just like inverse probability weights. See vignette(\"estimating-effects\") details. Changing min.n can change quality weights. Generally, low min.w yield better balance subclasses contain units relatively similar distance values, may yield higher variance extreme weights can occur due members treatment group subclasses. min.n = 0, subclasses may fail contain units treatment groups, case units subclasses dropped. Note subclassification weights can also estimated using WeightIt, provides additional methods estimating propensity scores. propensity score-estimation methods overlap, packages yield weights.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_subclass.html","id":"outputs","dir":"Reference","previous_headings":"","what":"Outputs","title":"Subclassification — method_subclass","text":"outputs described matchit() returned method = \"subclass\" except match.matrix excluded one additional component, q.cut, included, containing vector distance measure cutpoints used define subclasses. Note min.n > 0, subclass assignments may strictly obey quantiles listed q.cut. include.obj ignored.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_subclass.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Subclassification — method_subclass","text":"manuscript, need cite another package using method = \"subclass\" subclassification performed completely within MatchIt. example, sentence might read: Propensity score subclassification performed using MatchIt package (Ho, Imai, King, & Stuart, 2011) R. may good idea cite Hong (2010) Desai et al. (2017) treatment effect estimated using subclassification weights. Desai, R. J., Rothman, K. J., Bateman, B. . T., Hernandez-Diaz, S., & Huybrechts, K. F. (2017). Propensity-score-based Fine Stratification Approach Confounding Adjustment Exposure Infrequent: Epidemiology, 28(2), 249–257. doi:10.1097/EDE.0000000000000595 Hong, G. (2010). Marginal mean weighting stratification: Adjustment selection bias multilevel data. Journal Educational Behavioral Statistics, 35(5), 499–531. doi:10.3102/1076998609359785","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/method_subclass.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subclassification — method_subclass","text":"","code":"data(\"lalonde\")  # PS subclassification for the ATT with 7 subclasses s.out1 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"subclass\", subclass = 7) s.out1 #> A `matchit` object #>  - method: Subclassification (7 subclasses) #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 614 (matched) #>  - target estimand: ATT #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(s.out1, subclass = TRUE) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"subclass\", subclass = 7) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance by Subclass: #>  #> - Subclass 1 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.1141        0.0674          0.9626     1.0379    0.2771 #> age              24.4815       28.6536         -0.6501     0.3615    0.1150 #> educ             10.7407       10.2590          0.2544     0.4213    0.0401 #> raceblack         0.0370        0.0030          0.1802          .    0.0340 #> racehispan        0.2963        0.1506          0.3191          .    0.1457 #> racewhite         0.6667        0.8464         -0.3812          .    0.1797 #> nodegree          0.5556        0.5723         -0.0337          .    0.0167 #> married           0.2593        0.5904         -0.7555          .    0.3311 #> re74           3205.1533     6429.1274         -0.4426     1.0648    0.2177 #> re75           1983.7216     2631.3105         -0.2054     0.9066    0.0980 #>            eCDF Max #> distance     0.4934 #> age          0.2446 #> educ         0.1169 #> raceblack    0.0340 #> racehispan   0.1457 #> racewhite    0.1797 #> nodegree     0.0167 #> married      0.3311 #> re74         0.4266 #> re75         0.2263 #>  #> - Subclass 2 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.4522        0.3958          0.6193     0.8134    0.1707 #> age              29.1154       29.5135         -0.0603     0.3486    0.1308 #> educ              9.1538        9.7568         -0.2064     0.9233    0.0599 #> raceblack         0.8846        0.7027          0.5694          .    0.1819 #> racehispan        0.1154        0.2973         -0.5694          .    0.1819 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.6923        0.6757          0.0360          .    0.0166 #> married           0.5000        0.5405         -0.0811          .    0.0405 #> re74           6754.9455     5617.3241          0.1467     1.5744    0.0817 #> re75           3312.9595     3257.5161          0.0116     1.5170    0.0581 #>            eCDF Max #> distance     0.2994 #> age          0.3129 #> educ         0.1674 #> raceblack    0.1819 #> racehispan   0.1819 #> racewhite    0.0000 #> nodegree     0.0166 #> married      0.0405 #> re74         0.2453 #> re75         0.1746 #>  #> - Subclass 3 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5998        0.6097         -0.4590     1.2565    0.1421 #> age              26.6923       25.9000          0.1037     0.2696    0.2119 #> educ             10.3846        8.8000          0.7416     0.3682    0.1731 #> raceblack         1.0000        1.0000          0.0000          .    0.0000 #> racehispan        0.0000        0.0000          0.0000          .    0.0000 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.6923        0.5000          0.4167          .    0.1923 #> married           0.5000        0.0000          1.0000          .    0.5000 #> re74           2416.9731     1748.8415          0.1851     2.6567    0.1324 #> re75           1350.8111     1004.3709          0.1863     1.8285    0.0677 #>            eCDF Max #> distance     0.3615 #> age          0.5077 #> educ         0.3846 #> raceblack    0.0000 #> racehispan   0.0000 #> racewhite    0.0000 #> nodegree     0.1923 #> married      0.5000 #> re74         0.2769 #> re75         0.2077 #>  #> - Subclass 4 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.6582        0.6588         -0.0428     0.9551    0.0452 #> age              22.2963       24.2941         -0.4195     0.2181    0.1053 #> educ             10.4074       11.0588         -0.3613     0.5596    0.0787 #> raceblack         1.0000        1.0000          0.0000          .    0.0000 #> racehispan        0.0000        0.0000          0.0000          .    0.0000 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.4815        0.5294         -0.0959          .    0.0479 #> married           0.0370        0.2353         -1.0498          .    0.1983 #> re74            663.6473     1733.6054         -0.6576     0.1297    0.0617 #> re75            498.2558     1882.9978         -1.0580     0.1094    0.1153 #>            eCDF Max #> distance     0.1307 #> age          0.1808 #> educ         0.1765 #> raceblack    0.0000 #> racehispan   0.0000 #> racewhite    0.0000 #> nodegree     0.0479 #> married      0.1983 #> re74         0.1678 #> re75         0.2048 #>  #> - Subclass 5 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.7013        0.6979          0.2860     0.8887    0.0765 #> age              24.3846       22.2941          0.2995     0.7142    0.1296 #> educ             10.1154        9.8824          0.1297     1.3668    0.0637 #> raceblack         1.0000        1.0000          0.0000          .    0.0000 #> racehispan        0.0000        0.0000          0.0000          .    0.0000 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.7308        0.8235         -0.2091          .    0.0928 #> married           0.0385        0.0000          0.2000          .    0.0385 #> re74            932.1795      812.5195          0.0403     3.9223    0.0899 #> re75           1551.4350      586.9098          0.1945    23.9287    0.0601 #>            eCDF Max #> distance     0.2805 #> age          0.3032 #> educ         0.0928 #> raceblack    0.0000 #> racehispan   0.0000 #> racewhite    0.0000 #> nodegree     0.0928 #> married      0.0385 #> re74         0.2783 #> re75         0.2014 #>  #> - Subclass 6 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.7396        0.7425         -0.2126     1.4075    0.1214 #> age              23.8846       22.4615          0.1747     0.6952    0.1058 #> educ             10.3462       11.3846         -0.8436     0.4905    0.1202 #> raceblack         1.0000        1.0000          0.0000          .    0.0000 #> racehispan        0.0000        0.0000          0.0000          .    0.0000 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.9231        0.7692          0.5774          .    0.1538 #> married           0.0000        0.0000          0.0000          .    0.0000 #> re74            591.5328      517.2464          0.0596     2.0185    0.0545 #> re75            974.8401      479.1179          0.2851     4.6722    0.0769 #>            eCDF Max #> distance     0.2692 #> age          0.3462 #> educ         0.3077 #> raceblack    0.0000 #> racehispan   0.0000 #> racewhite    0.0000 #> nodegree     0.1538 #> married      0.0000 #> re74         0.1538 #> re75         0.1923 #>  #> - Subclass 7 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.7837        0.7774          0.2999     2.7433    0.1407 #> age              29.8889       25.6667          0.6648     0.3002    0.2333 #> educ             11.2222       10.6667          0.3763     6.5385    0.0679 #> raceblack         1.0000        1.0000          0.0000          .    0.0000 #> racehispan        0.0000        0.0000          0.0000          .    0.0000 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.8889        1.0000         -0.3536          .    0.1111 #> married           0.0000        0.0000          0.0000          .    0.0000 #> re74            190.2635      281.4813         -0.1585     1.3943    0.0889 #> re75           1091.6910     1912.6611         -0.3734     2.5440    0.2189 #>            eCDF Max #> distance     0.2963 #> age          0.6667 #> educ         0.1481 #> raceblack    0.0000 #> racehispan   0.0000 #> racewhite    0.0000 #> nodegree     0.1111 #> married      0.0000 #> re74         0.2222 #> re75         0.7407 #>  #> Sample Sizes by Subclass: #>           1  2  3  4  5  6  7 All #> Control 332 37 10 17 17 13  3 429 #> Treated  27 26 26 27 26 26 27 185 #> Total   359 63 36 44 43 39 30 614 #>   # PS subclassification for the ATE with 10 subclasses # and at least 2 units in each group per subclass s.out2 <- matchit(treat ~ age + educ + race + nodegree +                     married + re74 + re75, data = lalonde,                   method = \"subclass\", subclass = 10,                   estimand = \"ATE\", min.n = 2) s.out2 #> A `matchit` object #>  - method: Subclassification (10 subclasses) #>  - distance: Propensity score #>              - estimated with logistic regression #>  - number of obs.: 614 (original), 614 (matched) #>  - target estimand: ATE #>  - covariates: age, educ, race, nodegree, married, re74, re75 summary(s.out2) #>  #> Call: #> matchit(formula = treat ~ age + educ + race + nodegree + married +  #>     re74 + re75, data = lalonde, method = \"subclass\", estimand = \"ATE\",  #>     subclass = 10, min.n = 2) #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7569     0.9211    0.3774 #> age              25.8162       28.0303         -0.2419     0.4400    0.0813 #> educ             10.3459       10.2354          0.0448     0.4959    0.0347 #> raceblack         0.8432        0.2028          1.6708          .    0.6404 #> racehispan        0.0595        0.1422         -0.2774          .    0.0827 #> racewhite         0.0973        0.6550         -1.4080          .    0.5577 #> nodegree          0.7081        0.5967          0.2355          .    0.1114 #> married           0.1892        0.5128         -0.7208          .    0.3236 #> re74           2095.5737     5619.2365         -0.5958     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2870     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> married      0.3236 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance Across Subclasses #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.3104        0.2972          0.0585     1.0249    0.0454 #> age              25.1099       27.1896         -0.2272     0.3247    0.0996 #> educ             10.5836       10.3105          0.1106     0.5537    0.0332 #> raceblack         0.4040        0.3898          0.0371          .    0.0142 #> racehispan        0.0894        0.1233         -0.1139          .    0.0340 #> racewhite         0.5066        0.4869          0.0498          .    0.0197 #> nodegree          0.5194        0.6163         -0.2049          .    0.0969 #> married           0.2688        0.4150         -0.3257          .    0.1462 #> re74           2489.2647     4627.1084         -0.3614     0.5922    0.1342 #> re75           1532.5437     2199.1568         -0.2047     0.9287    0.0962 #>            eCDF Max #> distance     0.1674 #> age          0.2203 #> educ         0.0969 #> raceblack    0.0142 #> racehispan   0.0340 #> racewhite    0.0197 #> nodegree     0.0969 #> married      0.1462 #> re74         0.3399 #> re75         0.1839 #>  #> Sample Sizes: #>               Control Treated #> All            429.    185.   #> Matched (ESS)  332.11   42.66 #> Matched        429.    185.   #> Unmatched        0.      0.   #> Discarded        0.      0.   #>"},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.matchit.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Balance Plots after Matching and Subclassification — plot.matchit","title":"Generate Balance Plots after Matching and Subclassification — plot.matchit","text":"Generates plots displaying distributional balance overlap covariates propensity scores matching subclassification. displaying balance solely covariate standardized mean differences, see plot.summary.matchit(). plots can used assess degree covariate propensity score distributions balanced weighting discarding affect distribution propensity scores.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.matchit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Balance Plots after Matching and Subclassification — plot.matchit","text":"","code":"# S3 method for class 'matchit' plot(x, type = \"qq\", interactive = TRUE, which.xs = NULL, data = NULL, ...)  # S3 method for class 'matchit.subclass' plot(x, type = \"qq\", interactive = TRUE, which.xs = NULL, subclass, ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.matchit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Balance Plots after Matching and Subclassification — plot.matchit","text":"x matchit object; output call matchit(). type type plot display. Options include \"qq\", \"ecdf\", \"density\", \"jitter\", \"histogram\". See Details. Default \"qq\". Abbreviations allowed. interactive logical; whether graphs displayed interactive way. applies type = \"qq\", \"ecdf\", \"density\", \"jitter\". See Details. .xs type = \"qq\", \"ecdf\", \"density\", covariate(s) plots displayed. Factor variables named original variable name rather names individual dummy variables created expansion model.matrix. Can supplied character vector one-sided formula. data optional data frame containing variables named .xs present matchit object. ... arguments passed plot() control appearance plot. options accepted. subclass subclassification type = \"qq\", \"ecdf\", \"density\", whether display balance individual subclasses, , , ones. Can TRUE (display plots subclasses), FALSE (display plots aggregate), indices (e.g., 1:6) specific subclasses display balance. unspecified, interactive = TRUE, asked subclasses plots desired, otherwise, plots displayed aggregate.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.matchit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Balance Plots after Matching and Subclassification — plot.matchit","text":"plot.matchit() makes one five different plots depending argument supplied type. first three, \"qq\", \"ecdf\", \"density\", assess balance covariates. interactive = TRUE, plots three variables displayed time, prompt console allows move next set variables. interactive = FALSE, multiple pages plotted time, last variables visible displayed plot. see specific variables time, use .xs argument display plots just variables. fewer three variables available (expanding factors dummies), interactive ignored. type = \"qq\", empirical quantile-quantile (eQQ) plots created covariate matching. plots involve interpolating points smaller group based weighted quantiles group. points approximately 45-degree line, distributions treatment control groups approximately equal. Major deviations indicate departures distributional balance. variable fewer 5 unique values, points jittered easily visualize counts. type = \"ecdf\", empirical cumulative distribution function (eCDF) plots created covariate matching. Two eCDF lines produced plot: gray one control units black one treated units. point lines corresponds proportion units (proportionate share weights) less equal corresponding covariate value (x-axis). Deviations lines plot indicates distributional imbalance treatment groups covariate. eCDF eQQ statistics summary.matchit() correspond plots: eCDF max (also known Kolmogorov-Smirnov statistic) mean largest average vertical distance lines, eQQ max mean largest average horizontal distance lines. type = \"density\", density plots created covariate matching. Two densities produced plot: gray one control units black one treated units. x-axis corresponds value covariate y-axis corresponds density probability covariate value corresponding group. binary covariates, bar plots produced, interpretation. Deviations black gray lines represent imbalances covariate distribution; lines coincide (.e., black line visible), distributions identical. last two plots, \"jitter\" \"histogram\", visualize distance (.e., propensity score) distributions. plots heuristic purposes since purpose matching achieve balance covariates , propensity score. type = \"jitter\", jitter plot displayed distance values matching. method requires distance variable (e.g., propensity score) estimated supplied call matchit(). plot displays individuals values matched unmatched treatment control units arranged horizontally propensity scores. Points jitter counts easier see. size points increases receive higher weights. interactive = TRUE, can click points graph identify rownames indices probe extreme values, example. subclassification, vertical lines representing subclass boundaries overlay plots. type = \"histogram\", histogram distance values displayed treatment control groups matching. method requires distance variable (e.g., propensity score) estimated supplied call matchit(). subclassification, vertical lines representing subclass boundaries overlay plots. methods, sampling weights incorporated weights present.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.matchit.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Balance Plots after Matching and Subclassification — plot.matchit","text":"Sometimes, bugs plotting functions can cause strange layout size issues. Running frame() dev.() can used reset plotting pane (note latter delete plots plot history).","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.matchit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Balance Plots after Matching and Subclassification — plot.matchit","text":"","code":"data(\"lalonde\")  m.out <- matchit(treat ~ age + educ + married +                    race + re74, data = lalonde,                  method = \"nearest\") plot(m.out, type = \"qq\", interactive = FALSE,      which.xs = ~age + educ + re74)  plot(m.out, type = \"histogram\")   s.out <- matchit(treat ~ age + educ + married +                    race + nodegree + re74 + re75,                  data = lalonde, method = \"subclass\") plot(s.out, type = \"density\", interactive = FALSE,      which.xs = ~age + educ + re74,      subclass = 3)  plot(s.out, type = \"jitter\", interactive = FALSE)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.summary.matchit.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Love Plot of Standardized Mean Differences — plot.summary.matchit","title":"Generate a Love Plot of Standardized Mean Differences — plot.summary.matchit","text":"Generates Love plot, dot plot variable names y-axis standardized mean differences x-axis. point represents standardized mean difference corresponding covariate matched unmatched sample. Love plots simple way display covariate balance matching. plots generated using dotchart() points().","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.summary.matchit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Love Plot of Standardized Mean Differences — plot.summary.matchit","text":"","code":"# S3 method for class 'summary.matchit' plot(   x,   abs = TRUE,   var.order = \"data\",   threshold = c(0.1, 0.05),   position = \"bottomright\",   ... )"},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.summary.matchit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Love Plot of Standardized Mean Differences — plot.summary.matchit","text":"x summary.matchit object; output call summary.matchit(). standardize argument must set TRUE (default) call summary. abs logical; whether standardized mean differences displayed absolute value (TRUE, default) FALSE. var.order variables ordered. Allowable options include \"data\", ordering variables appear summary output; \"unmatched\", ordered variables based standardized mean differences matching; \"matched\", ordered variables based standardized mean differences matching; \"alphabetical\", ordering variables alphabetically. Default \"data\". Abbreviations allowed. threshold numeric values place vertical lines indicating balance threshold. can make easier see variables balance achieved given threshold. Multiple values can supplied add multiple lines. abs = FALSE, lines displayed sides zero. lines drawn abline linetype (lty) argument corresponding order entered variables (see options par()). default c(.1, .05) solid line (lty = 1) .1 dashed line (lty = 2) .05, indicating acceptable good balance, respectively. Enter value NA skip value lty (e.g., c(NA, .05) dashed vertical line .05). position position legend. one allowed keyword options supplied x legend() (e.g., \"right\", \"bottomright\", etc.). Default \"bottomright\". Set NULL legend included. Note legend cover points careful; setting var.order appropriately can help avoiding . ... ignored.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.summary.matchit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Love Plot of Standardized Mean Differences — plot.summary.matchit","text":"plot displayed, x invisibly returned.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.summary.matchit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a Love Plot of Standardized Mean Differences — plot.summary.matchit","text":"matching methods subclassification, plot.summary.matchit uses x$sum.[,\"Std. Mean Diff.\"] x$sum.matched[,\"Std. Mean Diff.\"] x-axis values. subclassification, addition points unadjusted aggregate subclass balance, numerals representing balance individual subclasses plotted subclass = TRUE call summary. Aggregate subclass standardized mean differences taken x$sum.across[,\"Std. Mean Diff.\"] subclass-specific mean differences taken x$sum.subclass.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.summary.matchit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a Love Plot of Standardized Mean Differences — plot.summary.matchit","text":"Noah Greifer","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/plot.summary.matchit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Love Plot of Standardized Mean Differences — plot.summary.matchit","text":"","code":"data(\"lalonde\") m.out <- matchit(treat ~ age + educ + married +                    race + re74, data = lalonde,                  method = \"nearest\") plot(summary(m.out, interactions = TRUE),      var.order = \"unmatched\")   s.out <- matchit(treat ~ age + educ + married +                    race + nodegree + re74 + re75,                  data = lalonde, method = \"subclass\") plot(summary(s.out, subclass = TRUE),      var.order = \"unmatched\", abs = FALSE)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/rbind.matchdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Append matched datasets together — rbind.matchdata","title":"Append matched datasets together — rbind.matchdata","text":"functions rbind() methods objects resulting calls match_data() get_matches(). function nearly identically rbind.data.frame(); see Details differ.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/rbind.matchdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Append matched datasets together — rbind.matchdata","text":"","code":"# S3 method for class 'matchdata' rbind(..., deparse.level = 1)  # S3 method for class 'getmatches' rbind(..., deparse.level = 1)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/rbind.matchdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Append matched datasets together — rbind.matchdata","text":"... Two matchdata getmatches objects output calls match_data() get_matches(), respectively. Supplied objects must either matchdata objects getmatches objects. deparse.level Passed rbind().","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/rbind.matchdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Append matched datasets together — rbind.matchdata","text":"object class supplied (.e., matchdata object matchdata objects supplied getmatches object getmatches objects supplied). rbind() called objects adjusting variables appropriate method dispatched corresponding class original data object.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/rbind.matchdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Append matched datasets together — rbind.matchdata","text":"rbind() appends two datasets row-wise. can useful matching performed separately subsets original data combined single dataset effect estimation. Using regular data.frame method rbind() pose problem, however; subclass variable repeated names across different datasets, even though units belong subclasses respective datasets. rbind.matchdata() renames subclasses correct subclass membership maintained. supplied matched datasets must generated original dataset, , variables . added components (e.g., weights, subclass) can named differently different datasets changed name output. rbind.getmatches() rbind.matchdata() identical.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/rbind.matchdata.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Append matched datasets together — rbind.matchdata","text":"Noah Greifer","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/rbind.matchdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Append matched datasets together — rbind.matchdata","text":"","code":"data(\"lalonde\")  # Matching based on race subsets m.out_b <- matchit(treat ~ age + educ + married +                     nodegree + re74 + re75,                   data = subset(lalonde, race == \"black\")) #> Warning: Fewer control units than treated units; not all treated units will get #> a match. md_b <- match_data(m.out_b)  m.out_h <- matchit(treat ~ age + educ + married +                     nodegree + re74 + re75,                   data = subset(lalonde, race == \"hispan\")) md_h <- match_data(m.out_h)  m.out_w <- matchit(treat ~ age + educ + married +                     nodegree + re74 + re75,                   data = subset(lalonde, race == \"white\")) md_w <- match_data(m.out_w)  #Bind the datasets together md_all <- rbind(md_b, md_h, md_w)  #Subclass conflicts are avoided levels(md_all$subclass) #>   [1] \"1_1\"  \"1_2\"  \"1_3\"  \"1_4\"  \"1_5\"  \"1_6\"  \"1_7\"  \"1_8\"  \"1_9\"  \"1_10\" #>  [11] \"1_11\" \"1_12\" \"1_13\" \"1_14\" \"1_15\" \"1_16\" \"1_17\" \"1_18\" \"1_19\" \"1_20\" #>  [21] \"1_21\" \"1_22\" \"1_23\" \"1_24\" \"1_25\" \"1_26\" \"1_27\" \"1_28\" \"1_29\" \"1_30\" #>  [31] \"1_31\" \"1_32\" \"1_33\" \"1_34\" \"1_35\" \"1_36\" \"1_37\" \"1_38\" \"1_39\" \"1_40\" #>  [41] \"1_41\" \"1_42\" \"1_43\" \"1_44\" \"1_45\" \"1_46\" \"1_47\" \"1_48\" \"1_49\" \"1_50\" #>  [51] \"1_51\" \"1_52\" \"1_53\" \"1_54\" \"1_55\" \"1_56\" \"1_57\" \"1_58\" \"1_59\" \"1_60\" #>  [61] \"1_61\" \"1_62\" \"1_63\" \"1_64\" \"1_65\" \"1_66\" \"1_67\" \"1_68\" \"1_69\" \"1_70\" #>  [71] \"1_71\" \"1_72\" \"1_73\" \"1_74\" \"1_75\" \"1_76\" \"1_77\" \"1_78\" \"1_79\" \"1_80\" #>  [81] \"1_81\" \"1_82\" \"1_83\" \"1_84\" \"1_85\" \"1_86\" \"1_87\" \"2_1\"  \"2_2\"  \"2_3\"  #>  [91] \"2_4\"  \"2_5\"  \"2_6\"  \"2_7\"  \"2_8\"  \"2_9\"  \"2_10\" \"2_11\" \"3_1\"  \"3_2\"  #> [101] \"3_3\"  \"3_4\"  \"3_5\"  \"3_6\"  \"3_7\"  \"3_8\"  \"3_9\"  \"3_10\" \"3_11\" \"3_12\" #> [111] \"3_13\" \"3_14\" \"3_15\" \"3_16\" \"3_17\" \"3_18\""},{"path":"https://kosukeimai.github.io/MatchIt/reference/summary.matchit.html","id":null,"dir":"Reference","previous_headings":"","what":"View a balance summary of a matchit object — summary.matchit","title":"View a balance summary of a matchit object — summary.matchit","text":"Computes prints balance statistics matchit matchit.subclass objects. Balance assessed ensure matching subclassification effective eliminating treatment group imbalance reported write-results analysis.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/summary.matchit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"View a balance summary of a matchit object — summary.matchit","text":"","code":"# S3 method for class 'matchit' summary(   object,   interactions = FALSE,   addlvariables = NULL,   standardize = TRUE,   data = NULL,   pair.dist = TRUE,   un = TRUE,   improvement = FALSE,   ... )  # S3 method for class 'matchit.subclass' summary(   object,   interactions = FALSE,   addlvariables = NULL,   standardize = TRUE,   data = NULL,   pair.dist = FALSE,   subclass = FALSE,   un = TRUE,   improvement = FALSE,   ... )  # S3 method for class 'summary.matchit' print(x, digits = max(3, getOption(\"digits\") - 3), ...)"},{"path":"https://kosukeimai.github.io/MatchIt/reference/summary.matchit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"View a balance summary of a matchit object — summary.matchit","text":"object matchit object; output call matchit(). interactions logical; whether compute balance statistics two-way interactions squares covariates. Default FALSE. addlvariables additional variable balance statistics computed along covariates matchit object. Can entered one three ways: data frame covariates many rows units original matchit() call, string containing names variables data, right-sided formula additional variables (possibly transformations) found data, environment, matchit object. Balance squares interactions additional variables included interactions = TRUE. standardize logical; whether compute standardized (TRUE) unstandardized (FALSE) statistics. standardized statistics standardized mean difference mean maximum difference (weighted) empirical cumulative distribution functions (ECDFs). unstandardized statistics raw mean difference mean maximum quantile-quantile (QQ) difference. Variance ratios produced either way. See Details . Default TRUE. data optional data frame containing variables named addlvariables specified string formula. pair.dist logical; whether compute average absolute pair distances. matching methods include match.matrix component output (.e., exact matching, coarsened exact matching, full matching, subclassification), computing pair differences can take long time, especially large datasets many covariates. methods (.e., nearest neighbor, optimal, genetic matching), computation fairly quick. Default FALSE subclassification TRUE otherwise. un logical; whether compute balance statistics unmatched sample. Default TRUE; set FALSE concise output. improvement logical; whether compute percent reduction imbalance. Default FALSE. Ignored un = FALSE. ... ignored. subclass subclassification, whether display balance individual subclasses, , , ones. Can TRUE (display balance subclasses), FALSE (display balance aggregate), indices (e.g., 1:6) specific subclasses display balance. anything FALSE, aggregate balance statistics displayed. Default FALSE. x summay.matchit summary.matchit.subclass object; output call summary(). digits number digits round balance statistics .","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/summary.matchit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"View a balance summary of a matchit object — summary.matchit","text":"matchit objects, summary.matchit object, list following components: call original call matchit() nn matrix sample sizes original (unmatched) matched samples sum.un = TRUE, matrix balance statistics covariate original (unmatched) sample sum.matched matrix balance statistics covariate matched sample reduction improvement = TRUE, matrix percent reduction imbalance covariate matched sample match.subclass objects, summary.matchit.subclass object, list containing following components: call original call matchit() sum.un = TRUE, matrix balance statistics covariate original sample sum.subclass subclass FALSE, list matrices balance statistics subclass sum.across matrix balance statistics covariate computed using subclassification weights reduction improvement = TRUE, matrix percent reduction imbalance covariate matched sample qn matrix sample sizes within subclass nn matrix sample sizes original (unmatched) matched samples","code":""},{"path":"https://kosukeimai.github.io/MatchIt/reference/summary.matchit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"View a balance summary of a matchit object — summary.matchit","text":"summary() computes balance summary matchit object. include balance matching subclassification, well percent improvement balance. variables balance statistics computed included formula, exact, mahvars arguments matchit(), well distance measure distance supplied numeric vector method estimating propensity scores. X component matchit object used supply covariates. standardized mean differences computed matching subclassification difference treatment group means divided standardization factor computed unmatched (original) sample. standardization factor depends argument supplied estimand matchit(): \"ATT\", standard deviation treated group; \"ATC\", standard deviation control group; \"ATE\", square root average variances within treatment group. post-matching mean difference computed weighted means treatment groups using matching subclassification weights. variance ratio computed ratio treatment group variances. Variance ratios computed binary variables variance function solely mean. matching, weighted variances computed using formula used cov.wt(). percent reduction bias computed using log variance ratios. eCDF difference statistics computed creating (weighted) eCDF group taking difference covariate value. eCDF function outputs (weighted) proportion units covariate values lower input value. maximum eCDF difference thing Kolmogorov-Smirnov statistic. values bounded zero one, values closer zero indicating good overlap covariate distributions treated control groups. binary variables, eCDF differences equal (weighted) difference proportion computed way. QQ difference statistics computed creating two samples size interpolating values larger one. values arranged order sample. QQ difference quantile difference observed covariate values quantile two groups. difference scale original covariate. Values close zero indicate good overlap covariate distributions treated control groups. weighted interpolation used post-matching QQ differences. binary variables, QQ differences equal (weighted) difference proportion computed way. pair distance average absolute differences variable pairs. example, treated unit paired four control units, set units contribute four absolute differences average. Within subclass, combination treated control unit forms pair contributes average. pair distance described Stuart Green (2008) value minimized using optimal (full) matching. standardize = TRUE, standardized versions variables used, standardization factor described standardized mean differences. Pair distances computed unmatched sample (pairs). pair distance can take compute, especially large datasets many covariates, setting pair.dist = FALSE one way speed summary(). effective sample size (ESS) measure size hypothetical unweighted sample roughly precision weighted sample. non-uniform matching weights computed (e.g., result full matching, matching replacement, subclassification), ESS can used quantify potential precision remaining matched sample. ESS always less equal matched sample size, reflecting loss precision due using weights. non-uniform weights, printed sample size table; otherwise, removed contain additional information matched sample size. subclassification, aggregate balance statistics computed using subclassification weights rather averaging across subclasses. balance statistics (except pair differences) computed incorporating sampling weights supplied matchit(), . unadjusted balance statistics include sampling weights adjusted balance statistics use matching weights multiplied sampling weights. printing, NA values replaced periods (.), pair distance column unmatched percent balance improvement components output omitted.","code":""},{"path":[]},{"path":"https://kosukeimai.github.io/MatchIt/reference/summary.matchit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"View a balance summary of a matchit object — summary.matchit","text":"","code":"data(\"lalonde\") m.out <- matchit(treat ~ age + educ + married +                    race + re74, data = lalonde,                  method = \"nearest\", exact = ~ married,                  replace = TRUE) summary(m.out, interactions = TRUE) #>  #> Call: #> matchit(formula = treat ~ age + educ + married + race + re74,  #>     data = lalonde, method = \"nearest\", exact = ~married, replace = TRUE) #>  #> Summary of Balance for All Data: #>                      Means Treated Means Control Std. Mean Diff. Var. Ratio #> distance                    0.5710        0.1850          1.7864     0.8760 #> age                        25.8162       28.0303         -0.3094     0.4400 #> educ                       10.3459       10.2354          0.0550     0.4959 #> married                     0.1892        0.5128         -0.8263          . #> raceblack                   0.8432        0.2028          1.7615          . #> racehispan                  0.0595        0.1422         -0.3498          . #> racewhite                   0.0973        0.6550         -1.8819          . #> re74                     2095.5737     5619.2365         -0.7211     0.5181 #> age²                      717.3946      901.7786         -0.4276     0.3627 #> age * educ                266.9784      282.3636         -0.1663     0.4912 #> age * married               5.5568       16.4872         -0.9147     0.4615 #> age * raceblack            21.9081        5.2867          1.4327     1.0055 #> age * racehispan            1.3568        3.7646         -0.4368     0.3127 #> age * racewhite             2.5514       18.9790         -2.0322     0.2424 #> age * re74              54074.0365   185650.1507         -0.9974     0.2539 #> educ²                     111.0595      112.8974         -0.0468     0.5173 #> educ * married              1.9622        5.0816         -0.7475     0.5927 #> educ * raceblack            8.6973        2.0466          1.5803     0.9801 #> educ * racehispan           0.5784        1.2634         -0.2940     0.4869 #> educ * racewhite            1.0703        6.9254         -1.7671     0.3652 #> educ * re74             22898.7264    60430.2774         -0.6539     0.5188 #> married * raceblack         0.1568        0.0583          0.2709          . #> married * racehispan        0.0162        0.0676         -0.4068          . #> married * racewhite         0.0162        0.3869         -2.9352          . #> married * re74            760.6329     4324.5356         -0.9734     0.2918 #> raceblack * re74         1817.2003      632.1307          0.2490     3.1701 #> racehispan * re74         151.3968      678.4817         -0.4400     0.1844 #> racewhite * re74          126.9766     4308.6240         -4.5164     0.0198 #> re74²                28141411.5686 77555527.0664         -0.4331     0.6548 #>                      eCDF Mean eCDF Max #> distance                0.3765   0.6419 #> age                     0.0813   0.1577 #> educ                    0.0347   0.1114 #> married                 0.3236   0.3236 #> raceblack               0.6404   0.6404 #> racehispan              0.0827   0.0827 #> racewhite               0.5577   0.5577 #> re74                    0.2248   0.4470 #> age²                    0.0813   0.1577 #> age * educ              0.0570   0.1187 #> age * married           0.1517   0.3236 #> age * raceblack         0.1831   0.6521 #> age * racehispan        0.0396   0.0827 #> age * racewhite         0.1966   0.5577 #> age * re74              0.2338   0.4470 #> educ²                   0.0347   0.1114 #> educ * married          0.1732   0.3166 #> educ * raceblack        0.3537   0.6451 #> educ * racehispan       0.0457   0.0781 #> educ * racewhite        0.2791   0.5554 #> educ * re74             0.2185   0.4400 #> married * raceblack     0.0985   0.0985 #> married * racehispan    0.0514   0.0514 #> married * racewhite     0.3707   0.3707 #> married * re74          0.1889   0.3626 #> raceblack * re74        0.0861   0.1523 #> racehispan * re74       0.0405   0.0794 #> racewhite * re74        0.2539   0.4959 #> re74²                   0.2248   0.4470 #>  #> Summary of Balance for Matched Data: #>                      Means Treated Means Control Std. Mean Diff. Var. Ratio #> distance                    0.5710        0.5705          0.0023     0.9769 #> age                        25.8162       25.9568         -0.0196     0.4500 #> educ                       10.3459       10.6054         -0.1290     0.5297 #> married                     0.1892        0.1892          0.0000          . #> raceblack                   0.8432        0.8324          0.0297          . #> racehispan                  0.0595        0.0595          0.0000          . #> racewhite                   0.0973        0.1081         -0.0365          . #> re74                     2095.5737     1882.1670          0.0437     1.5002 #> age²                      717.3946      785.1351         -0.1571     0.3693 #> age * educ                266.9784      268.1514         -0.0127     0.6110 #> age * married               5.5568        5.3459          0.0176     1.0543 #> age * raceblack            21.9081       21.1243          0.0676     0.7602 #> age * racehispan            1.3568        1.7297         -0.0677     0.5429 #> age * racewhite             2.5514        3.1027         -0.0682     0.6518 #> age * re74              54074.0365    56189.4636         -0.0160     0.9095 #> educ²                     111.0595      119.9459         -0.2261     0.5337 #> educ * married              1.9622        2.0432         -0.0194     0.9014 #> educ * raceblack            8.6973        8.7730         -0.0180     0.7955 #> educ * racehispan           0.5784        0.6054         -0.0116     0.8764 #> educ * racewhite            1.0703        1.2270         -0.0473     0.8114 #> educ * re74             22898.7264    21438.6573          0.0254     1.4256 #> married * raceblack         0.1568        0.1514          0.0149          . #> married * racehispan        0.0162        0.0216         -0.0428          . #> married * racewhite         0.0162        0.0162          0.0000          . #> married * re74            760.6329      626.0440          0.0368     2.2366 #> raceblack * re74         1817.2003     1629.7393          0.0394     1.4586 #> racehispan * re74         151.3968       90.2110          0.0511     3.1377 #> racewhite * re74          126.9766      162.2167         -0.0381     1.0624 #> re74²                28141411.5686 19125662.0900          0.0790     2.9783 #>                      eCDF Mean eCDF Max Std. Pair Dist. #> distance                0.0032   0.0432          0.0165 #> age                     0.0765   0.2216          1.1241 #> educ                    0.0353   0.1892          0.9194 #> married                 0.0000   0.0000          0.0000 #> raceblack               0.0108   0.0108          0.0297 #> racehispan              0.0000   0.0000          0.0216 #> racewhite               0.0108   0.0108          0.0365 #> re74                    0.0544   0.2919          0.3888 #> age²                    0.0765   0.2216          1.1358 #> age * educ              0.0342   0.0973          0.6831 #> age * married           0.0082   0.0649          0.1172 #> age * raceblack         0.0611   0.1946          0.5549 #> age * racehispan        0.0112   0.0270          0.2265 #> age * racewhite         0.0132   0.0270          0.1698 #> age * re74              0.0551   0.2919          0.4300 #> educ²                   0.0353   0.1892          0.9382 #> educ * married          0.0081   0.0811          0.0816 #> educ * raceblack        0.0337   0.1568          0.3956 #> educ * racehispan       0.0047   0.0216          0.1415 #> educ * racewhite        0.0079   0.0216          0.0963 #> educ * re74             0.0507   0.2919          0.4119 #> married * raceblack     0.0054   0.0054          0.0149 #> married * racehispan    0.0054   0.0054          0.0428 #> married * racewhite     0.0000   0.0000          0.0000 #> married * re74          0.0129   0.0865          0.1146 #> raceblack * re74        0.0448   0.2486          0.3194 #> racehispan * re74       0.0055   0.0162          0.1888 #> racewhite * re74        0.0069   0.0378          0.1735 #> re74²                   0.0544   0.2919          0.2207 #>  #> Sample Sizes: #>               Control Treated #> All             429.      185 #> Matched (ESS)    47.6     185 #> Matched          86.      185 #> Unmatched       343.        0 #> Discarded         0.        0 #>   s.out <- matchit(treat ~ age + educ + married +                    race + nodegree + re74 + re75,                  data = lalonde, method = \"subclass\") summary(s.out, addlvariables = ~log(age) + I(re74==0)) #>  #> Call: #> matchit(formula = treat ~ age + educ + married + race + nodegree +  #>     re74 + re75, data = lalonde, method = \"subclass\") #>  #> Summary of Balance for All Data: #>                  Means Treated Means Control Std. Mean Diff. Var. Ratio #> distance                0.5774        0.1822          1.7941     0.9211 #> age                    25.8162       28.0303         -0.3094     0.4400 #> educ                   10.3459       10.2354          0.0550     0.4959 #> married                 0.1892        0.5128         -0.8263          . #> raceblack               0.8432        0.2028          1.7615          . #> racehispan              0.0595        0.1422         -0.3498          . #> racewhite               0.0973        0.6550         -1.8819          . #> nodegree                0.7081        0.5967          0.2450          . #> re74                 2095.5737     5619.2365         -0.7211     0.5181 #> re75                 1532.0553     2466.4844         -0.2903     0.9563 #> log(age)                3.2167        3.2659         -0.1913     0.5093 #> I(re74 == 0)TRUE        0.7081        0.2611          0.9833          . #>                  eCDF Mean eCDF Max #> distance            0.3774   0.6444 #> age                 0.0813   0.1577 #> educ                0.0347   0.1114 #> married             0.3236   0.3236 #> raceblack           0.6404   0.6404 #> racehispan          0.0827   0.0827 #> racewhite           0.5577   0.5577 #> nodegree            0.1114   0.1114 #> re74                0.2248   0.4470 #> re75                0.1342   0.2876 #> log(age)            0.0813   0.1577 #> I(re74 == 0)TRUE    0.4470   0.4470 #>  #> Summary of Balance Across Subclasses #>                  Means Treated Means Control Std. Mean Diff. Var. Ratio #> distance                0.5774        0.5610          0.0744     0.8183 #> age                    25.8162       26.2522         -0.0609     0.4375 #> educ                   10.3459       10.2809          0.0323     0.6392 #> married                 0.1892        0.2425         -0.1361          . #> raceblack               0.8432        0.8279          0.0423          . #> racehispan              0.0595        0.0360          0.0990          . #> racewhite               0.0973        0.1361         -0.1309          . #> nodegree                0.7081        0.6984          0.0214          . #> re74                 2095.5737     2811.9421         -0.1466     0.8806 #> re75                 1532.0553     1834.5600         -0.0940     1.2233 #> log(age)                3.2167        3.1959          0.0808     0.4883 #> I(re74 == 0)TRUE        0.7081        0.4443          0.5803          . #>                  eCDF Mean eCDF Max #> distance            0.0366   0.0815 #> age                 0.0886   0.2558 #> educ                0.0147   0.0499 #> married             0.0533   0.0533 #> raceblack           0.0154   0.0154 #> racehispan          0.0234   0.0234 #> racewhite           0.0388   0.0388 #> nodegree            0.0097   0.0097 #> re74                0.0611   0.2638 #> re75                0.0644   0.2178 #> log(age)            0.0886   0.2558 #> I(re74 == 0)TRUE    0.2638   0.2638 #>  #> Sample Sizes: #>               Control Treated #> All            429.       185 #> Matched (ESS)   66.49     185 #> Matched        429.       185 #> Unmatched        0.         0 #> Discarded        0.         0 #>  summary(s.out, subclass = TRUE) #>  #> Call: #> matchit(formula = treat ~ age + educ + married + race + nodegree +  #>     re74 + re75, data = lalonde, method = \"subclass\") #>  #> Summary of Balance for All Data: #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5774        0.1822          1.7941     0.9211    0.3774 #> age              25.8162       28.0303         -0.3094     0.4400    0.0813 #> educ             10.3459       10.2354          0.0550     0.4959    0.0347 #> married           0.1892        0.5128         -0.8263          .    0.3236 #> raceblack         0.8432        0.2028          1.7615          .    0.6404 #> racehispan        0.0595        0.1422         -0.3498          .    0.0827 #> racewhite         0.0973        0.6550         -1.8819          .    0.5577 #> nodegree          0.7081        0.5967          0.2450          .    0.1114 #> re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248 #> re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342 #>            eCDF Max #> distance     0.6444 #> age          0.1577 #> educ         0.1114 #> married      0.3236 #> raceblack    0.6404 #> racehispan   0.0827 #> racewhite    0.5577 #> nodegree     0.1114 #> re74         0.4470 #> re75         0.2876 #>  #> Summary of Balance by Subclass: #>  #> - Subclass 1 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.1376        0.0763          0.7782     1.5087    0.2760 #> age              25.5806       28.4595         -0.4173     0.4163    0.0915 #> educ             10.4839       10.2543          0.1056     0.5625    0.0291 #> married           0.2903        0.5780         -0.6339          .    0.2877 #> raceblack         0.0968        0.0145          0.2784          .    0.0823 #> racehispan        0.3226        0.1734          0.3191          .    0.1492 #> racewhite         0.5806        0.8121         -0.4691          .    0.2315 #> nodegree          0.5806        0.5809         -0.0006          .    0.0003 #> re74           3445.7771     6311.1947         -0.3806     1.1631    0.2055 #> re75           2080.7043     2637.3832         -0.1629     1.0676    0.1057 #>            eCDF Max #> distance     0.4866 #> age          0.1600 #> educ         0.0959 #> married      0.2877 #> raceblack    0.0823 #> racehispan   0.1492 #> racewhite    0.2315 #> nodegree     0.0003 #> re74         0.4293 #> re75         0.2623 #>  #> - Subclass 2 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.5081        0.4669          0.6017     1.3761    0.1939 #> age              26.9032       32.2500         -0.8559     0.3404    0.1742 #> educ              9.6129        9.3750          0.0872     0.6596    0.0370 #> married           0.4194        0.6667         -0.5012          .    0.2473 #> raceblack         0.9677        0.9583          0.0533          .    0.0094 #> racehispan        0.0323        0.0417         -0.0533          .    0.0094 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.6129        0.6250         -0.0248          .    0.0121 #> re74           6437.9113     6609.9134         -0.0259     0.9023    0.0549 #> re75           3089.0804     3401.3890         -0.0749     0.9876    0.0819 #>            eCDF Max #> distance     0.3858 #> age          0.4220 #> educ         0.1035 #> married      0.2473 #> raceblack    0.0094 #> racehispan   0.0094 #> racewhite    0.0000 #> nodegree     0.0121 #> re74         0.1882 #> re75         0.2325 #>  #> - Subclass 3 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.6262        0.6292         -0.1585     1.0943    0.0541 #> age              25.5517       25.1765          0.0452     0.4654    0.1030 #> educ             10.2759       10.0000          0.1312     0.3845    0.0986 #> married           0.4138        0.0588          0.7207          .    0.3550 #> raceblack         1.0000        1.0000          0.0000          .    0.0000 #> racehispan        0.0000        0.0000          0.0000          .    0.0000 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.6897        0.4706          0.4735          .    0.2191 #> re74            806.7050     2110.7067         -0.5707     0.2635    0.1379 #> re75            628.5508      940.9724         -0.2348     0.6585    0.0723 #>            eCDF Max #> distance     0.1197 #> age          0.2677 #> educ         0.2191 #> married      0.3550 #> raceblack    0.0000 #> racehispan   0.0000 #> racewhite    0.0000 #> nodegree     0.2191 #> re74         0.3225 #> re75         0.1460 #>  #> - Subclass 4 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.6823        0.6824         -0.0044     1.4231    0.0509 #> age              23.5000       23.8571         -0.0793     0.2048    0.1491 #> educ             10.1875       10.4762         -0.1570     1.0063    0.0599 #> married           0.0312        0.1429         -0.6414          .    0.1116 #> raceblack         1.0000        1.0000          0.0000          .    0.0000 #> racehispan        0.0000        0.0000          0.0000          .    0.0000 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.6250        0.6667         -0.0861          .    0.0417 #> re74           1099.4532     1134.9752         -0.0121     2.2051    0.0857 #> re75           1446.2640     1704.0458         -0.0568     1.7074    0.0762 #>            eCDF Max #> distance     0.1860 #> age          0.2902 #> educ         0.1711 #> married      0.1116 #> raceblack    0.0000 #> racehispan   0.0000 #> racewhite    0.0000 #> nodegree     0.0417 #> re74         0.3051 #> re75         0.2902 #>  #> - Subclass 5 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.7296        0.7346         -0.3468     0.7370    0.1180 #> age              24.0000       22.1111          0.2361     0.7413    0.1059 #> educ             10.2903       10.8889         -0.4814     0.5077    0.0737 #> married           0.0000        0.0000          0.0000          .    0.0000 #> raceblack         1.0000        1.0000          0.0000          .    0.0000 #> racehispan        0.0000        0.0000          0.0000          .    0.0000 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.8710        0.8333          0.1123          .    0.0376 #> re74            525.2020      432.2360          0.0781     2.3025    0.0602 #> re75            754.4831      357.4678          0.2722     4.2576    0.0773 #>            eCDF Max #> distance     0.2832 #> age          0.2885 #> educ         0.1774 #> married      0.0000 #> raceblack    0.0000 #> racehispan   0.0000 #> racewhite    0.0000 #> nodegree     0.0376 #> re74         0.1398 #> re75         0.1613 #>  #> - Subclass 6 #>            Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance          0.7805        0.7774          0.1490     2.8080    0.1250 #> age              29.4194       25.6667          0.5095     0.4039    0.1945 #> educ             11.2258       10.6667          0.3908     6.1419    0.0707 #> married           0.0000        0.0000          0.0000          .    0.0000 #> raceblack         1.0000        1.0000          0.0000          .    0.0000 #> racehispan        0.0000        0.0000          0.0000          .    0.0000 #> racewhite         0.0000        0.0000          0.0000          .    0.0000 #> nodegree          0.8710        1.0000         -0.3849          .    0.1290 #> re74            207.3736      281.4813         -0.1288     1.3924    0.0878 #> re75           1137.7261     1912.6611         -0.3450     2.6542    0.2079 #>            eCDF Max #> distance     0.3441 #> age          0.6022 #> educ         0.1398 #> married      0.0000 #> raceblack    0.0000 #> racehispan   0.0000 #> racewhite    0.0000 #> nodegree     0.1290 #> re74         0.2043 #> re75         0.7419 #>  #> Sample Sizes by Subclass: #>           1  2  3  4  5  6 All #> Control 346 24 17 21 18  3 429 #> Treated  31 31 29 32 31 31 185 #> Total   377 55 46 53 49 34 614 #>"},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-470","dir":"Changelog","previous_headings":"","what":"MatchIt 4.7.0","title":"MatchIt 4.7.0","text":"nearest neighbor matching, optimal full matching, genetic matching, calipers can now negative, forces paired units away given variables. using method = \"optimal\" 1:1 matching propensity score, new preprocessing algorithm used speed matching process. algorithm ensures resulting match good match found without preprocessing step shrinking size matching problem. Typically, matched set selected, units may paired differently (general optimization problem often multiple solutions value objective function; algorithm adds additional constraint select among fewer solutions). algorithm described Sävje (2020) implemented C++ fast. Fixed bug matching nonzero ratio subclass membership incorrectly calculated. Thanks Simon Loewe (@simon-lowe) originally pointing . (#207, #208) match.data() renamed match_data(), match.data() remain alias backward compatibility. Fixed bug printing. Documentation fixes.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-460","dir":"Changelog","previous_headings":"","what":"MatchIt 4.6.0","title":"MatchIt 4.6.0","text":"CRAN release: 2024-11-13 improvements related performance. dramatically improve speeds large datasets. come improvements Rcpp code. using method = \"nearest\", m.order can now set \"farthest\" prioritize hard--match treated units. Note implement “far matching” simply changes order closest matches selected. Speed improvements method = \"nearest\", especially matching propensity score. Speed improvements summary() pair.dist = TRUE match.matrix component included output (e.g., method = \"full\" method = \"quick\"). Speed improvements method = \"subclass\" min.n greater 0. new normalize argument added matchit(). set TRUE (default, used option), nonzero weights treatment group rescaled average 1. FALSE, weights generated directly matching returned instead. using method = \"nearest\" m.order = \"closest\", full distance matrix longer computed, increases support larger samples. uses adaptation algorithm described Rassen et al. (2012). using method = \"nearest\" verbose = TRUE, progress bar now displays estimate much time remains. using method = \"nearest\" m.order = \"closest\" ratio greater 1, eligible units receive first match receive second, etc. Previously, closest pairs matched regardless whether units matched. ensures consistency m.order arguments. Speed memory improvements method = \"cem\" many covariates large sample size. Previous versions used Cartesian expansion levels factor variables, easily explode. using method = \"cem\" k2k = TRUE, m.order can set select matching order. Allowable options include \"data\" (default), \"closest\", \"farthest\", \"random\". \"closest\" recommended, \"data\" default now remain consistent previous versions. Documentation updates. Fixed bug using method = \"optimal\" method = \"full\" discard specified data given tibble (tbl_df object). (#185) Fixed bug using method = \"cardinality\" single covariate. (#194)","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-455","dir":"Changelog","previous_headings":"","what":"MatchIt 4.5.5","title":"MatchIt 4.5.5","text":"CRAN release: 2023-10-13 using method = \"cardinality\", new solver, HiGHS, can requested setting solver = \"highs\", relies highs package. much faster reliable GLPK free easy install regular R package additional requirements. Fixed bug using method = \"optimal\" discard exact specified. Thanks @NikNakk issue fix. (#171)","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-454","dir":"Changelog","previous_headings":"","what":"MatchIt 4.5.4","title":"MatchIt 4.5.4","text":"CRAN release: 2023-06-14 method = \"nearest\", m.order can now set \"closest\" request closest potential pairs matched first. can used whether propensity score used . Fixed bugs distance = NULL covariates specified matchit(). Changed “empirical cumulative density function” “empirical cumulative distribution function” documentation. (#166) Fixed bug calipers work properly systems. Thanks Bill Dunlap solution. (#163) Fixed bug . present formulas. Thanks @dmolitor. (#167) Fixed bug nearest neighbor matching ATC distance supplied numeric distance matrix.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-453","dir":"Changelog","previous_headings":"","what":"MatchIt 4.5.3","title":"MatchIt 4.5.3","text":"CRAN release: 2023-04-13 Error messages improved using chk rlang, now dependencies. Fixed bug using method = \"nearest\" replace = TRUE ratio greater 1. Thanks Julia Kretschmann. (#159) Fixed bug using method = \"nearest\" exact ratio greater 1. Thanks Sarah Conner. Fixed bug occur due numerical imprecision plot.matchit(). Thanks @hkmztrk. (#158) Fixed bugs using method = \"cem\" covariate omitted coarsening. Thanks @jfhelmer. (#160) Fixed typos vignettes. Thanks @fBedecarrats. (#156) Updated vignettes use marginaleffects v0.11.0 syntax.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-452","dir":"Changelog","previous_headings":"","what":"MatchIt 4.5.2","title":"MatchIt 4.5.2","text":"CRAN release: 2023-03-22 Fixed bug using method = \"quick\" exact specified. Thanks @m-marquis. (#149) Improved performance fixed bugs using exact cases strata contain units one treatment group. Thanks @m-marquis others pointing . (#151)","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-451","dir":"Changelog","previous_headings":"","what":"MatchIt 4.5.1","title":"MatchIt 4.5.1","text":"CRAN release: 2023-02-23 Nearest neighbor matching now uses much faster algorithm (6x times faster) distance propensity score mahvars specified. Differences sort order might cause results differ previous versions units identical propensity scores. Template matching renamed profile matching documentation. cardinality profile matching using method = \"cardinality\" ratio set whole number, possible perform optimal Mahalanobis distance matching matched sample supplying desired matching variables mahvars. Previously, user run separate pairing step. Fixed typos vignettes. Fixed bug character variables flagged non-finite. Thanks @isfraser. (#138) Added alt text images README vignettes. (#134)","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-450","dir":"Changelog","previous_headings":"","what":"MatchIt 4.5.0","title":"MatchIt 4.5.0","text":"CRAN release: 2022-11-16 Generalized full matching, described Sävje, Higgins, Sekhon (2021), can now implemented setting method = \"quick\" matchit(). dramatically faster alternative optimal full matching can support much larger datasets otherwise similar balancing performance. See ?method_quick vignette(\"matching-methods\") information. functionality relies quickmatch package. package structure updated, include use Roxygen documentation. affect use, source code look different previous versions. method = \"subclass\" min.n = 0 (default), units placed subclass now considered “unmatched” given weights 0. Previously left . method = \"genetic\", default distance.tolerance now 0. previous versions, argument ignored; now . plot.matchit(), .xs argument can specified one-sided formula. new data argument allowed variables formula among original covariates. factor variable supplied plot.matchit() type = \"density\", plot now displays factor levels plot instead separate plots level, similar cobalt::bal.plot(). “Estimating Effects” vignette (vignette(\"estimating-effects\")) rewritten much shorter (hopefully clearer) use marginaleffects package, now Suggested package. new vignette focuses using g-computation estimate treatment effects using single workflow slight modifications different situations. error message covariates missing non-finite values now clearer, identifying variables afflicted. fixes bug mentioned #115. Fixed bug using matchit() method = \"cem\", k2k = TRUE, k2k.method = NULL. Thanks Florian B. Mayr. Fixed bug using method = \"optimal\" method = \"full\" exact antiexact specified, wherein warning occur drop argument subsetting. Fixed bug antiexact work correctly method = \"nearest\". Thanks @gli-1. (#119) Fixed typos documentation vignettes. Calculating pair distances summary() pair.dist = TRUE now faster. Improved printing balance results covariates supplied. Updates Estimating Effects vignette dramatically increase speed cluster bootstrap average marginal effects matching. Thanks Yohei Hashimoto pointing inefficiency. Updates Assessing Balance vignette fix errors vignettes help files better protected Suggested packages available CRAN.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-440","dir":"Changelog","previous_headings":"","what":"MatchIt 4.4.0","title":"MatchIt 4.4.0","text":"CRAN release: 2022-05-18 optmatch returned CRAN, now open-source license! new solver argument can passed matchit() method = \"full\" method = \"optimal\" control solver used perform optimization used matching. Note using default (open source) solver LEMON may yield results different obtained prior optmatch 0.10.0. reproducibility questions, please contact optmatch maintainers. New functions added compute Euclidean distance (euclidean_dist()), scaled Euclidean distance (scaled_euclidean_dist()), Mahalanobis distance (mahalanobis_dist()), robust Mahalanobis distance (robust_mahalanobis_dist()). produce distance matrices can supplied distance argument matchit(), see . New distance options available matchit() based distance functions : \"robust_mahalanobis\", \"euclidean\", \"scaled_euclidean\", complement \"mahalanobis\". Similar \"mahalanobis\", involve estimating propensity score rather operate covariates directly. can used nearest neighbor matching, optimal matching, full matching, coarsened exact matching k2k = TRUE. Mahalanobis distance now computed using pooled within-group covariance matrix (computed treatment group-mean centering covariate computing covariance full sample), line computed optmatch recommended Rubin (1980) among others. cause results differ version prior versions MatchIt used Mahalanobis distance computed ignoring group membership. Added unit.id argument matchit() method = \"nearest\", defines unit IDs control observation given unit ID matched treated unit, control units ID can used future matches, ensuring unit ID used . useful , e.g., multiple rows correspond control firm want control firm matched , case firm ID supplied unit.id. See example use case. summary.matchit(), improvement now set FALSE default hide percentage improvement balance. Set TRUE recover prior behavior. Added clearer errors required packages missing certain distance methods. Fixed bug using matchit() method = \"nearest\", ratio greater 1, reuse.max specified. bug allowed previously matched control unit matched treatment unit, thereby essentially ignoring ratio argument. now works intended. Fixed bug matchit() method = \"nearest\" distance supplied matrix Inf values present. Fixed bug using exact matching caused infinite loop variable levels contained commas. Thanks @bking124. (#111) Fixed bug introduced optmatch version 0.10.3. Documentation updates. Updated logo, thanks Ben Stillerman.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-434","dir":"Changelog","previous_headings":"","what":"MatchIt 4.3.4","title":"MatchIt 4.3.4","text":"CRAN release: 2022-03-08 optmatch removed CRAN. Instructions installing ?method_optimal ?method_full. s.weights supplied distance = \"randomforest\", weights supplied randomForest::randomForest(). Improved conditional use packages, especially optmatch. may mean certain examples fail run vignettes.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-433","dir":"Changelog","previous_headings":"","what":"MatchIt 4.3.3","title":"MatchIt 4.3.3","text":"CRAN release: 2022-01-20 Fixed bug rbind.matchdata() produce datasets twice expected length. Thanks @sconti555. (#98)","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-432","dir":"Changelog","previous_headings":"","what":"MatchIt 4.3.2","title":"MatchIt 4.3.2","text":"CRAN release: 2021-11-23 Fixed bug q.cut component matchit object method = \"subclass\" included. Now . Thanks @aldencabajar. (#92) nn qn components matchit object removed. now computed summary.matchit() included summary.matchit object. Removed code disable compiler checks satisfy CRAN requirements.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-431","dir":"Changelog","previous_headings":"","what":"MatchIt 4.3.1","title":"MatchIt 4.3.1","text":"CRAN release: 2021-11-11 Added reuse.max argument matchit() method = \"nearest\". controls maximum number times control unit can used match. Setting reuse.max = 1 equivalent matching without replacement (.e., like setting replace = FALSE), setting reuse.max = Inf equivalent matching replacement restriction reuse controls (.e., like setting replace = TRUE). Values restrict many times control unit can used match. Higher values tend improve balance decrease precision. Mahalanobis distance matching method = \"nearest\" now bit faster. Fixed bug method = \"full\" fail exact matching strata contained exactly one treated unit exactly one control unit. (#88) Fixed bug introduced 4.3.0 inclusion character variables cause error \"Non-finite values allowed covariates.\" Thanks Moaath Mustafa. Documentation updates.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-430","dir":"Changelog","previous_headings":"","what":"MatchIt 4.3.0","title":"MatchIt 4.3.0","text":"CRAN release: 2021-09-13 Cardinality template matching can now used setting method = \"cardinality\" matchit(). methods use mixed integer programming directly select matched subsample without pairing stratifying units satisfied user-supplied balance constraints. results can dramatically improved using Gurobi optimizer. See ?method_cardinality vignette(\"matching-methods\") information. Added \"lasso\", \"ridge\", \"elasticnet\" options distance. estimate propensity scores using lasso, ridge, elastic net regression, respectively, implemented glmnet package. Added \"gbm\" option distance. estimates propensity scores using generalized boosted models implemented gbm package. implementation differs twang using cross-validation --bag error choose tuning parameter opposed balance. new argument, include.obj, added matchit(). TRUE, intermediate matching object created internally included output obj component. See individual methods pages information included output. ignored methods. Density plots can now requested using plot.matchit() setting type = \"density\". display density covariate treatment groups matching similar plots created cobalt::bal.plot(). Density plots can easier interpret eCDF plots. vignette(\"assessing-balance\") updated addition. clearer error now produced treatment variable omitted formula argument matchit(). Improvements match.data() finds original dataset. ’s still always safer supply argument data, now match.data() look environment matchit formula, calling environment match.data(), model component matchit object. clearer error message now printed valid dataset found places. Fixed bug occur using summary.matchit() just one covariate. verbose = TRUE propensity score estimated (.e., using distance argument), message saying displayed. Fixed bug print.matchit() indicate propensity score used caliper caliper specified, even propensity score. Now, indicate propensity score used caliper actually . Fixed bug plot.matchit() occur level factor values. Speed improvements method = \"full\" exact specified. changes can make current results differ slightly past results tol value high. recommended always use low value tol. Typo fixes documentation vignettes. Fixed bug supplying “GAM” string distance argument (.e., using syntax prior version 4.0.0) ignore link supplied. incompatible argument supplied matchit() (e.g., reestimate distance = \"mahalanobis\"), error warning produced argument set value default (e.g., setting reestimate = FALSE longer throw error). fixes issue brought Vu Ng using MatchThem. clearer error produced non-finite values present covariates.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-420","dir":"Changelog","previous_headings":"","what":"MatchIt 4.2.0","title":"MatchIt 4.2.0","text":"CRAN release: 2021-05-26 distance can now supplied distance matrix containing pairwise distances nearest neighbor, optimal, full matching. means users can create distance matrix outside MatchIt (e.g., using optmatch::match_on() dist()) matchit() use distances matching. See ?distance details. Added rbind.matchdata() method matchdata getmatches objects (output match.data() get_matches(), respectively) avoid subclass conflicts combining matched samples matching within subgroups. Added section vignette(\"estimating-effects\") moderation analysis matching, making use new rbind() method. Added antiexact argument perform anti-exact matching, .e., matching ensures treated control units different values certain variables. See examples feature requested might useful. Anti-exact matching works nearest neighbor, optimal, full, genetic matching. argument antiexact similar argument exact: either string one-sided formula containing names anti-exact matching variables. Slight speed improvements nearest neighbor matching, especially exact specified. method = \"nearest\", verbose = TRUE, exact specified, separate messages progress bars shown subgroup exact variable(s). spurious warning appear using large ratio replace = TRUE method = \"nearest\" longer appears. Fixed bug trying supply distance labeled numeric vector (e.g., resulting haven). Fixed typos documentation vignettes.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-410","dir":"Changelog","previous_headings":"","what":"MatchIt 4.1.0","title":"MatchIt 4.1.0","text":"CRAN release: 2020-12-15 Coarsened exact matching (.e., matchit() method = \"cem\") completely rewritten longer involves cem package, eliminating spurious warning messages fixing bugs. arguments can still used, old code run, though results differ slightly. Additional options available matching performance improved. See ?method_cem details differences implementation current version MatchIt cem older versions MatchIt. general, changes make coarsened exact matching function one expect , circumventing peculiarities bugs cem package. Variable ratio matching now compatible method = \"optimal\" way method = \"nearest\", .e., using min.controls max.controls arguments. method = \"full\" method = \"optimal\", maximum problem size set unlimited, larger datasets can used methods without error. may take long time run, though. Processing improvements method = \"optimal\" due rewriting functions Rcpp. Using method = \"optimal\" runs smoothly combining exact matching exact argument. using ratio different 1 method = \"nearest\" method = \"optimal\" exact matching, errors warnings number units matched clearer. Certain ratios produce errors now produce warnings. Fixed bug argument supplied data matchit(). Improvements vignettes documentation.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-401","dir":"Changelog","previous_headings":"","what":"MatchIt 4.0.1","title":"MatchIt 4.0.1","text":"CRAN release: 2020-11-27 Restored cem functionality taken re-uploaded. Added pkgdown website. Computing matching weights matching replacement faster due programming Rcpp. Fixed issues Rcpp code required C++11. C++11 added SystemRequirements DESCRIPTION, MatchIt now requires R version 3.1.0 later.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-400","dir":"Changelog","previous_headings":"","what":"MatchIt 4.0.0","title":"MatchIt 4.0.0","text":"CRAN release: 2020-11-14","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"general-fixes-and-new-features-4-0-0","dir":"Changelog","previous_headings":"","what":"General Fixes and New Features","title":"MatchIt 4.0.0","text":"match.data(), used create matched datasets, new arguments. data argument can supplied dataset matching weights subclasses added. supplied, match.data() try figure appropriate dataset like past. drop.unmatched argument controls whether unmatched units dropped output. default TRUE, consistent past behavior. Warnings now informative. get_matches(), seems rarely used since performed similar function match.data(), revamped. creates dataset one row per unit per matched pair. unit part two separate pairs (e.g., result matching replacement), get two rows output dataset. goal able implement standard error estimators rely repeated use unit subclass/pair membership, e.g., Austin & Cafri (2020). Otherwise, functions similarly match.data(). NOTE: changes get_matches() breaking changes! Legacy code work new syntax! print.matchit() completely changed now prints information matching type specifications. summary.matchit() contains information old print method. new function, add_s.weights(), adds sampling weights matchit objects use balance checking effect estimation. Sampling weights can also directly supplied matchit() new s.weights argument. new vignette describing using MatchIt sampling weights available vignette(\"sampling-weights\"). included dataset, lalonde, now uses race variable instead separate black hispan variables. makes easier see character variables treated MatchIt functions. Added extensive documentation every function, matching method, distance specification. Documentation longer links gking.harvard.edu/matchit now stands alone.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"matchit-4-0-0","dir":"Changelog","previous_headings":"","what":"matchit()","title":"MatchIt 4.0.0","text":"argument data longer required variables formula present environment. missing values present dataset treatment matching variables, error used appear longer . exact argument can supplied either character vector names variables data one-sided formula. full cross included variables used create bins within matching take place. mahvars argument can also supplied either character vector names variables data one-sided formula. Mahalanobis distance matching occur variables formula, processed model.matrix(). Use performing Mahalanobis distance matching variables within caliper defined propensity scores estimated variables main formula using argument distance. regular Mahalanobis distance matching (without propensity score caliper), supply variables main formula set distance = \"mahalanobis\". caliper argument can now specified numeric vector caliper variable named . means can separately impose calipers individual variables well instead propensity score. example, require units within pairs must .2 standard deviations X1 away , one specify caliper = c(X1 = .2). new option std.caliper allows choice whether caliper standard deviation units , one value per entry caliper can supplied. unnamed entry caliper applies caliper propensity score default std.caliper FALSE, doesn’t change behavior old code. options apply methods accept calipers, namely \"nearest\", \"genetic\", \"full\". new estimand argument can supplied specify target estimand analysis. methods, ATT ATC available ATT default, consistent prior behavior. methods, ATE additionally available. Note setting estimand doesn’t actually mean estimand targeted; calipers, common support, restrictions applied, target population shift requested. estimand just triggers choice level treatment focal formula used compute weights subclasses. methods accept , m.order can set “data”, matches order data appear. distance = \"mahalanobis\", m.order can “random” “data”, “data” default. Otherwise, m.order can \"largest\", \"smallest\", \"random\", \"data\", \"largest\" default (consistent prior behavior). output matchit() changed slightly; component X now data frame, result call model.frame() formula provided. exact mahvars specified, variables included well, already present. included methods methods. past, result call model.matrix() included methods. key arguments supplied methods don’t accept , warning thrown. method can set NULL perform matching create matchit object, possibly propensity score estimated using distance common support restriction using discard, purpose supplying summary.matchit() assess balance prior matching.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"method--nearest-4-0-0","dir":"Changelog","previous_headings":"matchit()","what":"method = \"nearest\"","title":"MatchIt 4.0.0","text":"Matching much faster due re-programming Rcpp. method = \"nearest\", subclass component containing pair membership now included output replace = FALSE (default), optimal full matching. using method = \"nearest\" distance = \"mahalanobis\", factor variables can now included main formula. design matrix longer full rank generalized inverse used compute Mahalanobis distance. Unless m.order = \"random\", results identical across runs. Previously, several random choices occur break ties. Ties broken based order data; shuffling order data may therefore yield different matches. using method = \"nearest\" caliper specified, nearest control unit matched treated unit one available. Previously, random control unit within caliper selected. eliminates need calclosest argument, removed. Variable ratio extremal matching described Ming & Rosenbaum (2000) can implemented using new min.controls max.controls arguments. Added ability display progress bar matching, can activated setting verbose = TRUE.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"method--optimal-and-method--full-4-0-0","dir":"Changelog","previous_headings":"matchit()","what":"method = \"optimal\" and method = \"full\"","title":"MatchIt 4.0.0","text":"Fixed bug method = \"optimal\", produced results match optmatch. Now . Added support optimal full Mahalanobis distance matching setting method = \"mahalanobis\" method = \"optimal\" method = \"full\". Previously, methods perform random match method set \"mahalanobis\". Now use native support optmatch::pairmatch() optmatch::fullmatch() Mahalanobis distance matching. Added support exact matching method = \"optimal\" method = \"full\". method = \"nearest\", names variables exact matches required supplied exact argument. relies optmatch::exactMatch(). warning used occur order match guaranteed original data longer occurs. method = \"full\", estimand argument can set \"ATT\", \"ATC\", \"ATE\" compute matching weights correspond given estimand. See ?matchit details weights computed estimand.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"method--genetic-4-0-0","dir":"Changelog","previous_headings":"matchit()","what":"method = \"genetic\"","title":"MatchIt 4.0.0","text":"Fixed bug method = \"genetic\" caused error ratio greater 1. default replace method = \"genetic\" now FALSE, method = \"nearest\". verbose = FALSE, default, output printed method = \"genetic\". verbose = TRUE, printed output Matching::GenMatch() print.level = 2 displayed. exact argument now correctly functions method = \"genetic\". Previously, specified accordance use Matching::GenMatch(). Different ways match variables now allowed method = \"genetic\", similar method = \"nearest\". distance = \"mahalanobis\", propensity score computed, genetic matching performed just variables supplied formula. mahvars specified, genetic matching performed variables supplied mahvars, balance optimized covariates supplied formula. Otherwise, genetic matching performed variables supplied formula propensity score. Previously, mahvars ignored. Balance now always optimized variables included formula never propensity score, whereas past propensity score always included balance optimization. caliper argument now works method = \"nearest\" methods rather needing supplied way Matching::Match() accept. subclass component now included output replace = FALSE (default), optimal full matching.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"method--cem-and-method--exact-4-0-0","dir":"Changelog","previous_headings":"matchit()","what":"method = \"cem\" and method = \"exact\"","title":"MatchIt 4.0.0","text":"method = \"cem\", k2k argument now recognized. Previously ignored unless argument k2k.method supplied. estimand argument can set \"ATT\", \"ATC\", \"ATE\" compute matching weights correspond given estimand. Previously ATT weights computed. See ?matchit details weights computed estimand.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"method--subclass-4-0-0","dir":"Changelog","previous_headings":"matchit()","what":"method = \"subclass\"","title":"MatchIt 4.0.0","text":"Performance improvements. new argument, min.n, can supplied, controls minimum size treatment group can subclass. estimated subclass doesn’t enough members treatment group, units subclasses pulled fill every subclass least min.n units treatment group. uses mechanism used WeightIt. default min.n 1 ensure least one treated control unit subclass. Rather producing warnings just using default number subclasses (6), inappropriate argument supplied subclass, error occur. new subclass argument summary() can used control whether subclass balance statistics computed; can TRUE (display balance subclasses), FALSE (display balance subclasses), vector subclass indices assess balance. default FALSE. summary(), balance aggregating across subclasses now computed using subclass weights instead combining subclass-specific balance statistics. sub.argument replaced estimand, can set \"ATT\", \"ATC\", \"ATE\" replace sub.inputs \"treat\", \"control\", \"\", respectively. Previously, weights sub.wasn’t \"treat\" incorrect; now correctly computed inputs estimand.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"distance-4-0-0","dir":"Changelog","previous_headings":"matchit()","what":"distance","title":"MatchIt 4.0.0","text":"allowable options distance changed slightly. input either \"mahalanobis\" Mahalanobis distance matching (without propensity score caliper), numeric vector distance values (.e., values whose absolute pairwise differences form distances), one allowable options. new allowable values include \"glm\" propensity scores estimated glm(), \"gam\" propensity scores estimated mgcv::gam(), \"rpart\" propensity scores estimated rpart::rpart(), \"nnet\" propensity scores estimated nnet::nnet(), \"cbps\" propensity scores estimated CBPS::CBPS(), bart propensity scores estimated dbarts::bart2(). specify link (e.g., probit regression), specify argument new link parameter. linear versions propensity score, specify link \"linear.{link}\". example, linear probit regression propensity scores, one specify distance = \"glm\", link = \"linear.probit\". default distance \"glm\" default link \"logit\", can omitted either desired. methods accept link, don’t, ignored. old-style distance supplied, converted appropriate specification warning (except distance = \"logit\", converted without warning). Added \"cbps\" option distance. estimates propensity scores using covariate balancing propensity score (CBPS) algorithm implemented CBPS package. Set link = \"linear\" use linear version CBPS. Added \"bart\" option distance. estimates propensity scores using Bayesian Additive Regression Trees (BART) implemented dbarts package. Added \"randomforest\" option distance. estimates propensity scores using random forests implemented randomForest package. Bugs distance = \"rpart\" fixed.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"summarymatchit-4-0-0","dir":"Changelog","previous_headings":"","what":"summary.matchit()","title":"MatchIt 4.0.0","text":"interactions = TRUE, interactions longer computed distance measure dummy variables factor. Variable names cleaned easier read. argument addlvariables can specified data frame matrix covariates, formula additional covariates (transformations) right side, character vector containing names additional covariates. latter two, variables named exist X component matchit output object environment, argument data can supplied summary() contains variables. output summary() now methods (except subclassification). Previously different methods different types matching. eCDF median (QQ median) statistics replaced variance ratio, better studied part several sets published recommendations. eCDF QQ median statistics provide little information beyond corresponding mean statistics. variance ratio uses variances weighted matching weights. eCDF QQ statistics adjusted. now use weights computed part matching. eCDF QQ statistics binary variables set difference group proportions. standard deviation control group removed output. default standardize now TRUE, standardized mean differences eCDF statistics displayed default. new column average absolute pair difference covariate included output. values indicate far treated control units within pairs . additional argument summary.matchit(), pair.dist, controls whether value computed. can take long time matching methods omitted speed computation. Balance prior matching can now suppressed setting un = FALSE. Percent balance improvement can now suppressed setting improvement = FALSE. un = FALSE, improvement automatically set FALSE.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"plotmatchit-4-0-0","dir":"Changelog","previous_headings":"","what":"plot.matchit()","title":"MatchIt 4.0.0","text":"Plots now use weighted summaries weights present, removing need num.draws argument. Added new plot type, \"ecdf\", creates empirical CDF plots matching. appearance plots improved (e.g., text appropriately centered, axes clearly labeled). eQQ plots binary variables variables take values, plots look like clusters snakes. argument type can abbreviated (e.g., \"j\" jitter). Fixed bug caused plots generated using plot(., type = \"hist\") small. specifying argument .xs control variables balance displayed graphically, input name original variable rather version appears summary() output. particular, factor variable supplied matchit(), referred name rather names split dummies. makes easier view balance factor variables without know type names levels. eQQ plots can now used matching methods. Previously, attempting plot() method = \"exact\" fail.","code":""},{"path":"https://kosukeimai.github.io/MatchIt/news/index.html","id":"plotsummarymatchit-4-0-0","dir":"Changelog","previous_headings":"","what":"plot.summary.matchit()","title":"MatchIt 4.0.0","text":"summary plot completely redesigned. now Love plot made using graphics::dotchart(). options available ordering variables, presenting absolute raw standardized mean differences, placing threshold lines plots. sophisticated interface, see cobalt::love.plot(), natively supports matchit objects uses ggplot2 engine.","code":""}]
